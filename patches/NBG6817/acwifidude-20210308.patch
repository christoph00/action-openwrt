diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/6in4_26_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/6in4_26_all.ipk
new file mode 100644
index 0000000000..7cfc0f4ec6
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/6in4_26_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/6rd_10_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/6rd_10_all.ipk
new file mode 100644
index 0000000000..c5030d790f
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/6rd_10_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/6to4_13_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/6to4_13_all.ipk
new file mode 100644
index 0000000000..bcdce50581
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/6to4_13_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages b/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages
new file mode 100644
index 0000000000..4aba7f01d9
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages
@@ -0,0 +1,1183 @@
+Package: 6in4
+Version: 26
+Depends: libc, kmod-sit, uclient-fetch
+License: GPL-2.0
+Section: net
+Architecture: all
+Installed-Size: 1707
+Filename: 6in4_26_all.ipk
+Size: 2525
+SHA256sum: e78ac6473fca05ce09f654178596756f8e00f80f03387c1b0cc3b846a0a3fc07
+Description:  Provides support for 6in4 tunnels in /etc/config/network.
+ Refer to http://wiki.openwrt.org/doc/uci/network for
+ configuration details.
+
+Package: 6rd
+Version: 10
+Depends: libc, kmod-sit
+License: GPL-2.0
+Section: net
+Architecture: all
+Installed-Size: 2778
+Filename: 6rd_10_all.ipk
+Size: 3574
+SHA256sum: 044da0f6f342b5316cf48b24f854872cf235aba440441e1f475fe135c6696050
+Description:  Provides support for 6rd tunnels in /etc/config/network.
+ Refer to http://wiki.openwrt.org/doc/uci/network for
+ configuration details.
+
+Package: 6to4
+Version: 13
+Depends: libc, kmod-sit
+License: GPL-2.0
+Section: net
+Architecture: all
+Installed-Size: 1044
+Filename: 6to4_13_all.ipk
+Size: 1863
+SHA256sum: f50812f9713e7be533c26f2355ded619e253fae5086f0dfdf192655f72a1433d
+Description:  Provides support for 6to4 tunnels in /etc/config/network.
+ Refer to https://openwrt.org/docs/guide-user/base-system/basic-networking
+ configuration details.
+
+Package: ath10k-board-qca988x
+Version: 20201118-3
+Depends: libc
+Section: firmware
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 777
+Filename: ath10k-board-qca988x_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1535
+SHA256sum: 5fab8af06e1f1adf269eff10443f653204f47dc3408281c64875b62a1079100c
+Description:  ath10k qca988x board firmware
+
+Package: ath10k-board-qca9984
+Version: 20201118-3
+Depends: libc
+Section: firmware
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 9801
+Filename: ath10k-board-qca9984_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10486
+SHA256sum: 84a549885f91374940eae43b25693be3c337f41f5548edc06ad6771b8caba2fa
+Description:  ath10k qca9984 board firmware
+
+Package: ath10k-board-qca99x0
+Version: 20201118-3
+Depends: libc
+Section: firmware
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4560
+Filename: ath10k-board-qca99x0_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5237
+SHA256sum: 9422e7c3cb31ef716bc0605a26cfac58613047bb0c6fa92e437a07394883c8a1
+Description:  ath10k qca99x0 board firmware
+
+Package: ath10k-firmware-qca988x-ct
+Version: 2020-11-08-1
+Depends: libc, ath10k-board-qca988x
+Conflicts: ath10k-firmware-qca988x
+Provides: ath10k-firmware-qca988x
+Section: firmware
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 181716
+Filename: ath10k-firmware-qca988x-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 182779
+SHA256sum: cb3b3e78af0a2bce2155f2926c054aacc332e4df33bde4b6767a516b05647c02
+Description:  Alternative ath10k firmware for QCA988X from Candela Technologies.
+ Enables IBSS and other features.  See:
+ http://www.candelatech.com/ath10k-10.1.php
+ This firmware will NOT be used unless the standard ath10k-firmware-qca988x
+ is un-selected since the driver will try to load firmware-5.bin before
+ firmware-2.bin
+
+Package: ath10k-firmware-qca9984-ct
+Version: 2020-11-08-1
+Depends: libc, ath10k-board-qca9984
+Conflicts: ath10k-firmware-qca9984
+Provides: ath10k-firmware-qca9984
+Section: firmware
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 471490
+Filename: ath10k-firmware-qca9984-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 468951
+SHA256sum: 33ba972eb5d1288a3f35461790cd5c916943b33ccde2b8e9c3c697c6a92adb6a
+Description:  Alternative ath10k firmware for QCA9984 from Candela Technologies.
+ Enables IBSS and other features.  See:
+ http://www.candelatech.com/ath10k-10.4.php
+ This firmware conflicts with the standard 9984 firmware, so select only
+ one.
+
+Package: ath10k-firmware-qca99x0-ct
+Version: 2020-11-08-1
+Depends: libc, ath10k-board-qca99x0
+Conflicts: ath10k-firmware-qca99x0
+Provides: ath10k-firmware-qca99x0
+Section: firmware
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 436039
+Filename: ath10k-firmware-qca99x0-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 433795
+SHA256sum: 22052191d1c44f5df8d1f999773991cfdf739206b372d8716664c29d52ff6535
+Description:  Alternative ath10k firmware for QCA99x0 from Candela Technologies.
+ Enables IBSS and other features.  See:
+ http://www.candelatech.com/ath10k-10.4.php
+ This firmware conflicts with the standard 99x0 firmware, so select only
+ one.
+
+Package: busybox
+Version: 1.33.0-1
+Depends: libc, jsonfilter
+Conflicts: busybox-selinux
+License: GPL-2.0
+Section: base
+CPE-ID: cpe:/a:busybox:busybox
+Essential: yes
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 237704
+Filename: busybox_1.33.0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 238192
+SHA256sum: 17e53d06a42461a5a0b614ce730e154f1a4858686d4fc4c28a6894573638e13c
+Description:  The Swiss Army Knife of embedded Linux.
+ It slices, it dices, it makes Julian Fries.
+
+Package: ca-bundle
+Version: 20210119-1
+Depends: libc
+Provides: ca-certs
+Section: base
+Architecture: all
+Installed-Size: 115934
+Filename: ca-bundle_20210119-1_all.ipk
+Size: 116753
+SHA256sum: 25c56bda0da57605637af64390656c34c4575851197d62288d664dea5768b1ee
+Description:  System CA certificates as a bundle
+
+Package: ca-certificates
+Version: 20210119-1
+Depends: libc
+Provides: ca-certs
+Section: base
+Architecture: all
+Installed-Size: 125674
+Filename: ca-certificates_20210119-1_all.ipk
+Size: 126354
+SHA256sum: 852f642f984244cd4cc446e6c5f79fcbdf39b9da1a0d36847067acba888e9719
+Description:  System CA certificates
+
+Package: dnsmasq
+Version: 2.84-1
+Depends: libc, libubus20210215
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:thekelleys:dnsmasq
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 125775
+Filename: dnsmasq_2.84-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 126386
+SHA256sum: d630436486d18b387c72e6047537c98ba72b4c921610cee7bda16560d3493464
+Description:  It is intended to provide coupled DNS and DHCP service to a LAN.
+
+Package: e2fsprogs
+Version: 1.45.6-2
+Depends: libc, libuuid1, libext2fs2
+License: GPL-2.0
+Section: utils
+CPE-ID: cpe:/a:e2fsprogs_project:e2fsprogs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 181731
+Filename: e2fsprogs_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 181821
+SHA256sum: eb293aebaf61c2762475864e01e08456619e460ead7447fd50d9a8ae648c699f
+Description:  This package contains essential ext2 filesystem utilities which consists of
+ e2fsck, mke2fs and most of the other core ext2 filesystem utilities.
+
+Package: firewall
+Version: 2020-09-05-8c2f9fad-1
+Depends: libc, libubox20201212, libubus20210215, libuci20130104, libip4tc2, libip6tc2, libxtables12, kmod-ipt-core, kmod-ipt-conntrack, kmod-nf-conntrack6, kmod-ipt-nat
+License: ISC
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 47508
+Filename: firewall_2020-09-05-8c2f9fad-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 48254
+SHA256sum: 45159f383811fb37e7b440221a07b4e556cf256491326813f990e0f68f76a803
+Description:  This package provides a config-compatible C implementation of the UCI firewall.
+
+Package: getrandom
+Version: 2020-10-25-9ef88681-1
+Depends: libc
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1389
+Filename: getrandom_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2180
+SHA256sum: 8c2c86c8499dd7e51c37764058a7c45111a1bc2b7cbebfb449fd948b0183ce21
+Description:  OpenWrt getrandom system helper
+
+Package: hostapd-common
+Version: 2020-06-08-5a8b3662-32
+Depends: libc
+License: BSD-3-Clause
+Section: net
+CPE-ID: cpe:/a:w1.fi:hostapd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10843
+Filename: hostapd-common_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11663
+SHA256sum: c7ad7095a925b28ec75047628f1042ffdd39a9655b9489fdc5581ceb71b1812f
+Description:  hostapd/wpa_supplicant common support files
+
+Package: hostapd-utils
+Version: 2020-06-08-5a8b3662-32
+Depends: libc
+License: BSD-3-Clause
+Section: net
+CPE-ID: cpe:/a:w1.fi:hostapd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 16950
+Filename: hostapd-utils_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
+Size: 17830
+SHA256sum: 113e6b4710ff78ed44cad7df59d867179ef706ac21218b215058743cd8ad44be
+Description:  This package contains a command line utility to control the
+ IEEE 802.1x/WPA/EAP/RADIUS Authenticator.
+
+Package: ip-tiny
+Version: 5.10.0-1
+Depends: libc, libnl-tiny1
+Provides: ip
+Alternatives: 200:/sbin/ip:/usr/libexec/ip-tiny
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:iproute2_project:iproute2
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 138539
+Filename: ip-tiny_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 139215
+SHA256sum: f88e9fe1799df5846ef591cc25bdea89917f69c895a788beaa466fd92b3d1dbd
+Description:  Routing control utility (Minimal)
+
+Package: ipset
+Version: 7.6-1
+Depends: libc, kmod-ipt-ipset, libmnl0, libipset13
+License: GPL-2.0
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1136
+Filename: ipset_7.6-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1920
+SHA256sum: db64fee7e759ccbd1979d6a11fed00793500a169ef0e099572f661e1dd90093f
+Description:  IPset administration utility
+
+Package: iw
+Version: 5.9-1
+Depends: libc, libnl-tiny1
+License: GPL-2.0
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 42998
+Filename: iw_5.9-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 43817
+SHA256sum: 3cc358a74ac0ac42139b5b381601b3744fdacc042e57d59afdf611b6a20b1e46
+Description:  cfg80211 interface configuration utility
+
+Package: jshn
+Version: 2020-12-12-35787769-1
+Depends: libc, libjson-c5, libubox20201212, libblobmsg-json20201212
+License: ISC
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6337
+Filename: jshn_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7173
+SHA256sum: 85b7262fc4a9d9d50b48c69f83a4274243f91bfa6d050aad5db150f2b030c8dc
+Description:  Library for parsing and generating JSON from shell scripts
+
+Package: jsonfilter
+Version: 2018-02-04-c7e938d6-1
+Depends: libc, libubox20201212, libjson-c5
+License: ISC
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 9225
+Filename: jsonfilter_2018-02-04-c7e938d6-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9992
+SHA256sum: cfaa4544f018a3ab2be79c20a30f5bfafbe3c6c9de4cf154a06e0da4bc3651b0
+Description:  OpenWrt JSON filter utility
+
+Package: libblkid1
+Version: 2.36.1-2
+Depends: libc, libuuid1
+Provides: libblkid
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:kernel:util-linux
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 118653
+Filename: libblkid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 119246
+SHA256sum: 3b35ddc7c0e84f8da01b3f1e113be5edb7bdd8eec9a74704235c4d0fb0a509a0
+Description:  The libblkid library is used to identify block devices (disks) as to their
+ content (e.g. filesystem type, partitions) as well as extracting additional
+ information such as filesystem labels/volume names, partitions, unique
+ identifiers/serial numbers...
+
+Package: libblobmsg-json20201212
+Version: 2020-12-12-35787769-1
+Depends: libc, libjson-c5, libubox20201212
+Provides: libblobmsg-json
+License: ISC
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3383
+Filename: libblobmsg-json20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4144
+SHA256sum: 38ca68b80de0d1d46b80af9ca6383d4c9315386b8f8a5013fc937b5ad8cbe699
+Description:  blobmsg <-> json conversion library
+
+Package: libcomerr0
+Version: 1.45.6-2
+Depends: libc, libuuid1
+Provides: libcomerr
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:e2fsprogs_project:e2fsprogs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3653
+Filename: libcomerr0_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4436
+SHA256sum: c043c8bd2939fb59ce6a8bb9b612d0817df45fb9173e437f97723f2cc621ede5
+Description:  This package contains libcom_err, the common error description library
+ bundled with e2fsprogs.
+
+Package: libelf1
+Version: 0.180-1
+Depends: libc, zlib
+Provides: libelf, libelf11
+License: GPL-3.0-or-later
+Section: libs
+CPE-ID: cpe:/a:elfutils_project:elfutils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 38161
+Filename: libelf1_0.180-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 39072
+SHA256sum: c72f5c8cda5e82af3febbe894d178709078aa70636006240488ab9fee3a9438f
+Description:  ELF manipulation libraries (libelf)
+
+Package: libext2fs2
+Version: 1.45.6-2
+Depends: libc, libuuid1, libblkid1, libss2, libcomerr0
+Provides: libext2fs
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:e2fsprogs_project:e2fsprogs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 165825
+Filename: libext2fs2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 165903
+SHA256sum: 2d2a629e7920d79616863565ae6c7d6b9480bb4120b91418dccc3c770e42726e
+Description:  libext2fs is a library which can access ext2, ext3 and ext4 filesystems.
+
+Package: libipset13
+Version: 7.6-1
+Depends: libc, kmod-ipt-ipset, libmnl0
+Provides: libipset
+License: GPL-2.0
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 40303
+Filename: libipset13_7.6-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 40852
+SHA256sum: 26e573831eec6fe0d9993ddf52a32b773b70575dc61375defdccd65141f96f44
+Description:  IPset administration utility
+
+Package: libjson-c5
+Version: 0.15-1
+Depends: libc
+Provides: libjson-c
+License: MIT
+Section: libs
+CPE-ID: cpe:/a:json-c_project:json-c
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 23588
+Filename: libjson-c5_0.15-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 24327
+SHA256sum: 3166ee378f9b3da9ef6bb3cb0713c60cec8dca0f29e4f1a26d7dd7b98cf103db
+Description:  This package contains a library for javascript object notation backends.
+
+Package: libjson-script20201212
+Version: 2020-12-12-35787769-1
+Depends: libc, libubox20201212
+Provides: libjson-script
+License: ISC
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4228
+Filename: libjson-script20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4987
+SHA256sum: 50eea04b358d6430d69d41982b72de76481d8a4ae3cb00052e37e8d1589c4cc7
+Description:  Minimalistic JSON based scripting engine
+
+Package: libltdl7
+Version: 2.4.6-2
+Depends: libc
+Provides: libltdl
+License: GPL-2.0+
+Section: libs
+CPE-ID: cpe:/a:gnu:libtool
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 13186
+Filename: libltdl7_2.4.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13862
+SHA256sum: 087f9a9dda0bfd8c8db6c1985f4514a245ad08a08136fc2b19e25ae695c5fc69
+Description:  A generic dynamic object loading library
+
+Package: liblua5.1.5
+Version: 5.1.5-8
+Depends: libc
+Provides: liblua
+License: MIT
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 60107
+Filename: liblua5.1.5_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk
+Size: 60884
+SHA256sum: be3cb66fa9674aa9a83d43f8f180371db53ab437e748db037ed15d2ddf287020
+Description:  Lua is a powerful light-weight programming language designed for extending 
+ applications. Lua is also frequently used as a general-purpose, stand-alone 
+ language. Lua is free software.
+ This package contains the Lua shared libraries, needed by other programs.
+
+Package: libmnl0
+Version: 1.0.4-2
+Depends: libc
+Provides: libmnl
+License: LGPL-2.1+
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5360
+Filename: libmnl0_1.0.4-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6595
+SHA256sum: 0e2077f3e7a8d7749867f9e9e15110cde3f317cc6bb2c7ca19f9279749b38508
+Description:  libmnl is a minimalistic user-space library oriented to Netlink developers.
+ There are a lot of common tasks in parsing, validating, constructing of
+ both the Netlink header and TLVs that are repetitive and easy to get wrong.
+ This library aims to provide simple helpers that allows you to re-use code
+ and to avoid re-inventing the wheel. The main features of this library are:
+ .
+ * Small: the shared library requires around 30KB for an x86-based computer.
+ .
+ * Simple: this library avoids complexity and elaborated abstractions that
+ tend to hide Netlink details.
+ .
+ * Easy to use: the library simplifies the work for Netlink-wise developers.
+ It provides functions to make socket handling, message building, validating,
+ parsing and sequence tracking, easier.
+ .
+ * Easy to re-use: you can use the library to build your own abstraction layer
+ on top of this library.
+ .
+ * Decoupling: the interdependency of the main bricks that compose the library
+ is reduced, i.e. the library provides many helpers, but the programmer is not
+ forced to use them.
+
+Package: libncurses6
+Version: 6.2-1
+Depends: libc, terminfo
+Provides: libncursesw, libncurses, libncursesw6
+License: MIT
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 155131
+Filename: libncurses6_6.2-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 153256
+SHA256sum: 9208b75feb937c58d74acaba9d6eb2dbef4ab6d0ee26b8e353a99c0b3df8dc96
+Description:  Terminal handling library (Unicode)
+
+Package: libnl-tiny1
+Version: 2020-08-05-c291088f-1
+Depends: libc
+Provides: libnl-tiny
+License: LGPL-2.1
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12609
+Filename: libnl-tiny1_2020-08-05-c291088f-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13397
+SHA256sum: 539b2da9f8b7d4e9a23c4a13fab4fb19338aefe767a8b48ad0f001115ef0ea5f
+Description:  This package contains a stripped down version of libnl
+
+Package: libopenssl-conf
+Version: 1.1.1j-1
+Depends: libc, libopenssl1.1
+License: OpenSSL
+Section: libs
+CPE-ID: cpe:/a:openssl:openssl
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4784
+Filename: libopenssl-conf_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5803
+SHA256sum: 8db69c78948c43265af97ab6df974b65d4ae8df4d1130cb32214be9c16d011ba
+Description:  The OpenSSL Project is a collaborative effort to develop a robust,
+ commercial-grade, full-featured, and Open Source toolkit implementing the
+ Transport Layer Security (TLS) protocol as well as a full-strength
+ general-purpose cryptography library.
+ This package installs the OpenSSL configuration file /etc/ssl/openssl.cnf.
+
+Package: libopenssl-devcrypto
+Version: 1.1.1j-1
+Depends: libc, libopenssl1.1, kmod-cryptodev, libopenssl-conf
+License: OpenSSL
+Section: libs
+CPE-ID: cpe:/a:openssl:openssl
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7289
+Filename: libopenssl-devcrypto_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8332
+SHA256sum: 6e006672bb6dfdc6e117cfb95941558d393951599e919446a32e215f2fd0ba90
+Description:  This package adds an engine that enables hardware acceleration
+ through the /dev/crypto kernel interface.
+ To use it, you need to configure the engine in /etc/ssl/openssl.cnf
+ See https://www.openssl.org/docs/man1.1.1/man5/config.html#Engine-Configuration-Module
+ and https://openwrt.org/docs/techref/hardware/cryptographic.hardware.accelerators
+ The engine_id is "devcrypto"
+
+Package: libopenssl1.1
+Version: 1.1.1j-1
+Depends: libc
+Provides: libopenssl
+License: OpenSSL
+Section: libs
+CPE-ID: cpe:/a:openssl:openssl
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1098416
+Filename: libopenssl1.1_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1088303
+SHA256sum: 55b5828a7729169ef5a4bee93720363a63a4774a32e697682a2bedcb3fb9c3d5
+Description:  The OpenSSL Project is a collaborative effort to develop a robust,
+ commercial-grade, full-featured, and Open Source toolkit implementing the
+ Transport Layer Security (TLS) protocol as well as a full-strength
+ general-purpose cryptography library.
+ This package contains the OpenSSL shared libraries, needed by other programs.
+
+Package: libsmartcols1
+Version: 2.36.1-2
+Depends: libc, librt
+Provides: libsmartcols
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:kernel:util-linux
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 77755
+Filename: libsmartcols1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 78557
+SHA256sum: 2df478a134d71756d9122cbd989c0cc8f36e373e0361d2446601516f2b37b8ee
+Description:  The smartcols library is used to print tables and trees in a pretty way.
+
+Package: libss2
+Version: 1.45.6-2
+Depends: libc, libcomerr0
+Provides: libss
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:e2fsprogs_project:e2fsprogs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7563
+Filename: libss2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8409
+SHA256sum: 894ba39f4b63840e8953ad034677e8b2b87c35be0dc9444760c7fca5bb2ba488
+Description:  This pacakge contains libss, a command-line interface parsing library
+ bundled with e2fsprogs.
+
+Package: libubox20201212
+Version: 2020-12-12-35787769-1
+Depends: libc
+Provides: libubox
+License: ISC
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 18261
+Filename: libubox20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19011
+SHA256sum: ae0f868ed3ccff3b35d73839ac1e6bf76b009fc7e7574d66da4acc5e2db880b2
+Description:  Basic utility library
+
+Package: libubus-lua
+Version: 2021-02-15-2537be01-1
+Depends: libc, libubus20210215, liblua5.1.5
+License: LGPL-2.1
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6110
+Filename: libubus-lua_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6884
+SHA256sum: 3bb71120aaa884e12aa2a2f738860ec798627db5aa12578c08df8f959c146e0b
+Description:  Lua binding for the OpenWrt RPC client
+
+Package: libubus20210215
+Version: 2021-02-15-2537be01-1
+Depends: libc, libubox20201212
+Provides: libubus
+License: LGPL-2.1
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8850
+Filename: libubus20210215_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9676
+SHA256sum: 1ef02c65489f715f83d1d78c5ffc16c9c18e0ee3256043459942d2f3cfdf8b30
+Description:  OpenWrt RPC client library
+
+Package: libuci20130104
+Version: 2020-10-06-52bbc99f-4
+Depends: libc, libubox20201212
+Provides: libuci
+License: LGPL-2.1
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 14925
+Filename: libuci20130104_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15707
+SHA256sum: 9add6afdd157075b077ec32de312ffe43e139c1ce445e4c426cd376815f8d7d6
+Description:  C library for the Unified Configuration Interface (UCI)
+
+Package: libuclient20201210
+Version: 2020-12-10-2c843b2b-1
+Depends: libc, libubox20201212
+Provides: libuclient
+License: ISC
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8803
+Filename: libuclient20201210_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9583
+SHA256sum: a4ef160f23b7d45382da11789f690f4d8cf1bc2dedb08bf5f15dad964bfa1ae4
+Description:  HTTP/1.1 client library
+
+Package: libustream-openssl20201210
+Version: 2020-12-10-68d09243-1
+Depends: libc, libubox20201212, libopenssl1.1
+Provides: libustream-openssl
+License: ISC
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3830
+Filename: libustream-openssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4604
+SHA256sum: 28726cfdc00070f061fe03fb0f356f7a782b362545559741d7fe4b206a503807
+Description:  ustream SSL Library (openssl)
+
+Package: libustream-wolfssl20201210
+Version: 2020-12-10-68d09243-1
+Depends: libc, libubox20201212, libwolfssl4.7.0.66253b90
+Provides: libustream-wolfssl
+License: ISC
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3477
+Filename: libustream-wolfssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4222
+SHA256sum: 260889c28fae55a43e397c914e2e6d5d02cfb46b704ba2e7aec1daa0f5e5a1f2
+Description:  ustream SSL Library (wolfssl)
+
+Package: libuuid1
+Version: 2.36.1-2
+Depends: libc, librt
+Provides: libuuid
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:kernel:util-linux
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 11277
+Filename: libuuid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12251
+SHA256sum: 3ec3e7b6369055670fc9bba851d1aea2e5c9a4593e7c14b14eeaa50d0b5f8f3d
+Description:  The UUID library is used to generate unique identifiers for objects
+ that may be accessible beyond the local system. This library
+ generates UUIDs compatible with those created by the Open Software
+ Foundation (OSF) Distributed Computing Environment (DCE) utility.
+
+Package: libwolfssl4.7.0.66253b90
+Version: 4.7.0-stable-1
+Depends: libc
+Provides: libcyassl, libwolfssl, libcyassl4.7.0.66253b90
+License: GPL-2.0-or-later
+Section: libs
+CPE-ID: cpe:/a:wolfssl:wolfssl
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 406417
+Filename: libwolfssl4.7.0.66253b90_4.7.0-stable-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 404885
+SHA256sum: 7a128f0da2452f1b60c4518c81c31f1d57399451c7b93d5d8624f5fcb58ace49
+Description:  wolfSSL (formerly CyaSSL) is an SSL library optimized for small
+ footprint, both on disk and for memory use.
+
+Package: logd
+Version: 2020-10-25-9ef88681-1
+Depends: libc, libubox20201212, libubus20210215, libblobmsg-json20201212
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10143
+Filename: logd_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10907
+SHA256sum: 9f40c5299504fea60a718dad4d2dca32d32242c6321307a784e933de020c30cc
+Description:  OpenWrt system log implementation
+
+Package: losetup
+Version: 2.36.1-2
+Depends: libc, libsmartcols1
+License: GPL-2.0
+Section: utils
+CPE-ID: cpe:/a:kernel:util-linux
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 36930
+Filename: losetup_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 37845
+SHA256sum: 5e4e76b4673735c0dca7e51be5cd8d06b666713bcca92b475e19630f7dcd4fb6
+Description:  losetup is used to associate loop devices with regular files or block devices,
+ to detach loop devices and to query the status of a loop device
+
+Package: lua
+Version: 5.1.5-8
+Depends: libc, liblua5.1.5
+License: MIT
+Section: lang
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4565
+Filename: lua_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5418
+SHA256sum: 702195567586d73ea6f203435145398c2dfafc2904ff59aa67c667e69df5ae32
+Description:  Lua is a powerful light-weight programming language designed for extending 
+ applications. Lua is also frequently used as a general-purpose, stand-alone 
+ language. Lua is free software.
+ This package contains the Lua language interpreter.
+
+Package: netifd
+Version: 2021-01-09-c00c8335-1
+Depends: libc, libuci20130104, libnl-tiny1, libubus20210215, ubus, ubusd, jshn, libubox20201212
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 77449
+Filename: netifd_2021-01-09-c00c8335-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 78193
+SHA256sum: 641e996cb1f5ae1d3ccc4a05767cbde634e663c360a2946561394d5e9a39d7ef
+Description:  OpenWrt Network Interface Configuration Daemon
+
+Package: odhcp6c
+Version: 2021-01-09-53f07e90-16
+Depends: libc, libubox20201212
+License: GPL-2.0
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 25582
+Filename: odhcp6c_2021-01-09-53f07e90-16_arm_cortex-a15_neon-vfpv4.ipk
+Size: 26381
+SHA256sum: ec859942dc3ee6d6c0bc44a780c7a4c6cd51cd90b2dc8e0aff7f2487c91d30f9
+Description:  Embedded DHCPv6-client for OpenWrt
+
+Package: odhcpd-ipv6only
+Version: 2021-01-06-8d8a8cd3-2
+Depends: libc, libubox20201212, libuci20130104, libubus20210215, libnl-tiny1
+License: GPL-2.0
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 35917
+Filename: odhcpd-ipv6only_2021-01-06-8d8a8cd3-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 36926
+SHA256sum: a7b15ed92a8a900628a3ff0f37ff765561c651742e9d63859a7686e1841be0b7
+Description:  odhcpd is a daemon for serving and relaying IP management protocols to
+ configure clients and downstream routers. It tries to follow the RFC 6204
+ requirements for IPv6 home routers.
+ 
+ This is a variant providing server services for RA, stateless and stateful
+ DHCPv6,  prefix delegation and can be used to relay RA, DHCPv6 and NDP between
+ routed (non-bridged) interfaces in case no delegated prefixes are available.
+
+Package: openssl-util
+Version: 1.1.1j-1
+Depends: libc, libopenssl1.1, libopenssl-conf
+License: OpenSSL
+Section: utils
+CPE-ID: cpe:/a:openssl:openssl
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 247758
+Filename: openssl-util_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 246094
+SHA256sum: 5907722d6bea600a5fb0bb6958c5f459c221785d4a2f16d90cc359f3006738d7
+Description:  The OpenSSL Project is a collaborative effort to develop a robust,
+ commercial-grade, full-featured, and Open Source toolkit implementing the
+ Transport Layer Security (TLS) protocol as well as a full-strength
+ general-purpose cryptography library.
+ This package contains the OpenSSL command-line utility.
+
+Package: openwrt-keyring
+Version: 2021-02-20-49283916-1
+Depends: libc
+Provides: lede-keyring
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1392
+Filename: openwrt-keyring_2021-02-20-49283916-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2202
+SHA256sum: acee633533cd81b62643919fa764b61d0b41eadce9b6307acaed79b7200e14d1
+Description:  The keyring of with the developer using and gpg public keys.
+
+Package: opkg
+Version: 2020-12-24-9bbc7eae-1
+Depends: libc, uclient-fetch, libpthread, libubox20201212
+License: GPL-2.0
+Section: base
+Essential: yes
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 66151
+Filename: opkg_2020-12-24-9bbc7eae-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 67180
+SHA256sum: 42e945d19808882bb00108530d8616c6868ca3a30422e9fe60d419c41d17187c
+Description:  Lightweight package management system
+ opkg is the opkg Package Management System, for handling
+ installation and removal of packages on a system. It can
+ recursively follow dependencies and download all packages
+ necessary to install a particular package.
+ 
+ opkg knows how to install both .ipk and .deb packages.
+
+Package: ppp-mod-pppoe
+Version: 2.4.8.git-2020-10-03-3
+Depends: libc, kmod-pppoe
+License: BSD-4-Clause
+Section: net
+CPE-ID: cpe:/a:samba:ppp
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10035
+Filename: ppp-mod-pppoe_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10857
+SHA256sum: 384dd82a7b5ef74bf98062c6c9d71a503a16424a4c9939ab972c06c13d27b7e0
+Description:  This package contains a PPPoE (PPP over Ethernet) plugin for ppp.
+
+Package: ppp
+Version: 2.4.8.git-2020-10-03-3
+Depends: libc, kmod-ppp
+License: BSD-4-Clause
+Section: net
+CPE-ID: cpe:/a:samba:ppp
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 121542
+Filename: ppp_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 121713
+SHA256sum: 23b2e95464442c19257674fe9922eae99b94a5c244b72a7efcfe9b46a6710bae
+Description:  This package contains the PPP (Point-to-Point Protocol) daemon.
+
+Package: procd
+Version: 2021-02-08-08938fe1-2
+Depends: libc, ubusd, ubus, libjson-script20201212, ubox, libubox20201212, libubus20210215, libblobmsg-json20201212, libjson-c5, jshn
+Conflicts: procd-selinux
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 49024
+Filename: procd_2021-02-08-08938fe1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 49816
+SHA256sum: 47ae41278297d24b5e22fc35a7e5efc9049b409b1b0ab59d7bf7f68ecc3c2473
+Description:  OpenWrt system process manager
+
+Package: rpcd-mod-file
+Version: 2021-01-06-ea7f4717-1
+Depends: libc, libubus20210215, libubox20201212, rpcd
+License: ISC
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6201
+Filename: rpcd-mod-file_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7044
+SHA256sum: 37fd1ea75a9753d6fc6b52f70a997fbc3dd1a5517a3749348f39800e7d0c79dc
+Description:  Provides ubus calls for file and directory operations.
+
+Package: rpcd-mod-iwinfo
+Version: 2021-01-06-ea7f4717-1
+Depends: libc, libubus20210215, libubox20201212, rpcd, libiwinfo20210106
+License: ISC
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6902
+Filename: rpcd-mod-iwinfo_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7752
+SHA256sum: 9e8522c16ad0df1f712797723fc462f2b5eab2a00e593389594056e0f9d6bbb7
+Description:  Provides ubus calls for accessing iwinfo data.
+
+Package: rpcd
+Version: 2021-01-06-ea7f4717-1
+Depends: libc, libubus20210215, libubox20201212, libuci20130104, libblobmsg-json20201212, libjson-c5
+License: ISC
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 22190
+Filename: rpcd_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 22938
+SHA256sum: e4ba8318f7f218771f176c212d3e765763a4b1bc127177450535b8c6c1d2685a
+Description:  This package provides the UBUS RPC backend server to expose various
+ functionality to frontend programs via JSON-RPC.
+
+Package: swconfig
+Version: 12
+Depends: libc, libuci20130104, libnl-tiny1
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8600
+Filename: swconfig_12_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9379
+SHA256sum: 895ce7c112c6ff69908fbf7c88713a2a09ca8fb0297efaff13bdc1e1664e1689
+Description:  Switch configuration utility
+
+Package: tc
+Version: 5.10.0-1
+Depends: libc, kmod-sched-core, libxtables12, libelf1
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:iproute2_project:iproute2
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 179431
+Filename: tc_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 180057
+SHA256sum: c9837a429a8795c0e916c6441df2bfc0979cebea47f73de1f0438ca53ee66571
+Description:  Traffic control utility
+
+Package: terminfo
+Version: 6.2-1
+Depends: libc
+License: MIT
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6292
+Filename: terminfo_6.2-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6981
+SHA256sum: f5baba6db25384582548d444c45df52d7b95a92e71877d521f946a97e897f485
+Description:  Terminal Info Database (ncurses)
+
+Package: ubox
+Version: 2020-10-25-9ef88681-1
+Depends: libc, libubox20201212, ubusd, ubus, libubus20210215, libuci20130104
+Alternatives: 100:/sbin/rmmod:/sbin/kmodloader, 100:/sbin/insmod:/sbin/kmodloader, 100:/sbin/lsmod:/sbin/kmodloader, 100:/sbin/modinfo:/sbin/kmodloader, 100:/sbin/modprobe:/sbin/kmodloader
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 13970
+Filename: ubox_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 14811
+SHA256sum: 0932483dce5a1eaf479a75abf047703abe5c8c0b39114247fd65d05b47a2eb18
+Description:  OpenWrt system helper toolbox
+
+Package: ubus
+Version: 2021-02-15-2537be01-1
+Depends: libc, libubus20210215, libblobmsg-json20201212, ubusd
+License: LGPL-2.1
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5526
+Filename: ubus_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6302
+SHA256sum: e66eaaa548b69f2acd71d150172e316002dae88b2c863bf424b3f921f3b371a9
+Description:  OpenWrt RPC client utility
+
+Package: ubusd
+Version: 2021-02-15-2537be01-1
+Depends: libc, libubox20201212, libblobmsg-json20201212
+License: LGPL-2.1
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10525
+Filename: ubusd_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11299
+SHA256sum: 0fe3380b66e9fc6522133843c0419e4108a24f731d57f1f981d55c3a6dc1c259
+Description:  OpenWrt RPC daemon
+
+Package: uci
+Version: 2020-10-06-52bbc99f-4
+Depends: libc, libuci20130104
+License: LGPL-2.1
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6796
+Filename: uci_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7616
+SHA256sum: 2500cdd6cd5fb5a8d42ba9dcb020be77f355649e2ae422267de853638fd178e6
+Description:  Utility for the Unified Configuration Interface (UCI)
+
+Package: uclient-fetch
+Version: 2020-12-10-2c843b2b-1
+Depends: libc, libuclient20201210
+Provides: wget
+Alternatives: 200:/usr/bin/wget:/bin/uclient-fetch
+License: ISC
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7401
+Filename: uclient-fetch_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8235
+SHA256sum: 5bf2fc49fb29c86d593d67419faa6996f5eb810c4cc3416d9c5a0ee72bc6224f
+Description:  Tiny wget replacement using libuclient
+
+Package: uhttpd-mod-ubus
+Version: 2020-11-23-f53a6399-1
+Depends: libc, uhttpd, libubus20210215, libblobmsg-json20201212
+License: ISC
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7348
+Filename: uhttpd-mod-ubus_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8215
+SHA256sum: b8fd0648c73908366a2ee4e4f25b0d1816f33baac0b3f71dd7ab59ebd6272069
+Description:  The ubus plugin adds a HTTP/JSON RPC proxy for ubus and publishes the
+ session.* namespace and procedures.
+
+Package: uhttpd
+Version: 2020-11-23-f53a6399-1
+Depends: libc, libubox20201212, libblobmsg-json20201212, libjson-script20201212, libjson-c5
+License: ISC
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 25604
+Filename: uhttpd_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 26439
+SHA256sum: 4dddb5190238a5d5e45e7d586c62bbc3f7a1e1c529aa9730e3e0de896243b342
+Description:  uHTTPd is a tiny single threaded HTTP server with TLS, CGI and Lua
+ support. It is intended as a drop-in replacement for the Busybox
+ HTTP daemon.
+
+Package: umdns
+Version: 2021-01-26-78aa36b0-1
+Depends: libc, libubox20201212, libubus20210215, libblobmsg-json20201212
+License: LGPL-2.1
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 14927
+Filename: umdns_2021-01-26-78aa36b0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15727
+SHA256sum: efdf4c46fa00eee2481c7fe476014e851958a4355f7f7dcc7342f49b192afd5c
+Description:  OpenWrt Multicast DNS Daemon
+
+Package: urandom-seed
+Version: 3
+Depends: libc, getrandom
+License: GPL-2.0-only
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 836
+Filename: urandom-seed_3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1586
+SHA256sum: b4b8530bad2b3efad0f9135a50fd622a8ecfcec4ffc328767f0f0f839a34a326
+Description:  /etc/urandom.seed handling for OpenWrt
+
+Package: urngd
+Version: 2020-01-21-c7f7b6b6-1
+Depends: libc, libubox20201212
+License: GPL-2.0 BSD-3-Clause
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4715
+Filename: urngd_2020-01-21-c7f7b6b6-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5706
+SHA256sum: 8202db6a6a3127041f716c2b9ab5ac86726d2abef04ced030da28b2ac55f11b8
+Description:  urngd is OpenWrt's micro non-physical true random number generator based on
+ timing jitter.
+ 
+ Using the Jitter RNG core, the rngd provides an entropy source that feeds into
+ the Linux /dev/random device if its entropy runs low. It updates the
+ /dev/random entropy estimator such that the newly provided entropy unblocks
+ /dev/random.
+ 
+ The seeding of /dev/random also ensures that /dev/urandom benefits from
+ entropy. Especially during boot time, when the entropy of Linux is low, the
+ Jitter RNGd provides a source of sufficient entropy.
+
+Package: usign
+Version: 2020-05-23-f1f65026-1
+Depends: libc, libubox20201212
+License: ISC
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 11173
+Filename: usign_2020-05-23-f1f65026-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11950
+SHA256sum: 7180b7798ce6dabcf2e06ab93dff38e3520b919da03b1029aed61de829c1fe89
+Description:  OpenWrt signature verification utility
+
+Package: wireguard-tools
+Version: 1.0.20200827-2
+Depends: libc
+License: GPL-2.0
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 26139
+Filename: wireguard-tools_1.0.20200827-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 27245
+SHA256sum: d5ee117d7c265c9886c862bf6c2cbc20d68b56fc1815a568cbcaea1445b8ff72
+Description:  WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes
+ state-of-the-art cryptography. It aims to be faster, simpler, leaner, and
+ more useful than IPSec, while avoiding the massive headache. It intends to
+ be considerably more performant than OpenVPN.  WireGuard is designed as a
+ general purpose VPN for running on embedded interfaces and super computers
+ alike, fit for many different circumstances. It uses UDP.
+ 
+ This package provides the userspace control program for WireGuard,
+ `wg(8)`, a netifd protocol helper, and a re-resolve watchdog script.
+
+Package: wireless-regdb
+Version: 2020.11.20-1
+Depends: libc
+Section: firmware
+Architecture: all
+Installed-Size: 1929
+Filename: wireless-regdb_2020.11.20-1_all.ipk
+Size: 2672
+SHA256sum: 16f8847ae8a3b482c664f250bd91bda582defb7b2fd3f990b7ea370ecb55f2c1
+Description:  Wireless Regulatory Database
+
+Package: wpad-basic-wolfssl
+Version: 2020-06-08-5a8b3662-32
+Depends: libc, libnl-tiny1, hostapd-common, libubus20210215, libwolfssl4.7.0.66253b90
+Conflicts: hostapd, hostapd-basic, hostapd-basic-openssl, hostapd-basic-wolfssl, hostapd-mini, hostapd-openssl, hostapd-wolfssl, wpad, wpad-mesh-openssl, wpad-mesh-wolfssl, wpad-basic, wpad-basic-openssl, wpad, wpad-mesh-openssl, wpad-mesh-wolfssl, wpad-basic, wpad-basic-openssl
+Provides: hostapd, wpa-supplicant
+License: BSD-3-Clause
+Section: net
+CPE-ID: cpe:/a:w1.fi:hostapd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 347536
+Filename: wpad-basic-wolfssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
+Size: 347854
+SHA256sum: 15e4f18239bba0aab521ce996be2cd390620009b6f7844dabeca4c5ca2a3d6b6
+Description:  This package contains a basic IEEE 802.1x/WPA Authenticator and Supplicant with WPA-PSK, SAE (WPA3-Personal), 802.11r and 802.11w support.
+
+Package: wpad-openssl
+Version: 2020-06-08-5a8b3662-32
+Depends: libc, libnl-tiny1, hostapd-common, libubus20210215, libopenssl1.1
+Conflicts: hostapd, hostapd-basic, hostapd-basic-openssl, hostapd-basic-wolfssl, hostapd-mini, hostapd-openssl, hostapd-wolfssl, wpad, wpad-mesh-openssl, wpad-mesh-wolfssl, wpad-basic, wpad-basic-openssl, wpad-basic-wolfssl, wpad-mini, wpad, wpad-mesh-openssl, wpad-mesh-wolfssl, wpad-basic, wpad-basic-openssl, wpad-basic-wolfssl, wpad-mini
+Provides: hostapd, wpa-supplicant
+License: BSD-3-Clause
+Section: net
+CPE-ID: cpe:/a:w1.fi:hostapd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 567646
+Filename: wpad-openssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
+Size: 567020
+SHA256sum: f697d4eb6c8416152e8e86ebd67b88ff983ef0f1e64f553135298d0df6918732
+Description:  This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
+ Authenticator and Supplicant
+
+Package: zlib
+Version: 1.2.11-3
+Depends: libc
+License: Zlib
+Section: libs
+CPE-ID: cpe:/a:gnu:zlib
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 41028
+Filename: zlib_1.2.11-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 41860
+SHA256sum: 15f38e5d41ea018ba60034fbcd433e6fd07e7389a4c7761a9bad1d36236fa33a
+Description:  zlib is a lossless data-compression library.
+ This package includes the shared library.
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.gz b/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.gz
new file mode 100644
index 0000000000..f23869d850
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.gz differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.manifest b/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.manifest
new file mode 100644
index 0000000000..8db44f6396
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.manifest
@@ -0,0 +1,1531 @@
+Package: 6in4
+Version: 26
+Depends: libc, kmod-sit, uclient-fetch
+Source: package/network/ipv6/6in4
+SourceName: 6in4
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1594830836
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: all
+Installed-Size: 1707
+Filename: 6in4_26_all.ipk
+Size: 2525
+SHA256sum: e78ac6473fca05ce09f654178596756f8e00f80f03387c1b0cc3b846a0a3fc07
+Description:  Provides support for 6in4 tunnels in /etc/config/network.
+ Refer to http://wiki.openwrt.org/doc/uci/network for
+ configuration details.
+
+Package: 6rd
+Version: 10
+Depends: libc, kmod-sit
+Source: package/network/ipv6/6rd
+SourceName: 6rd
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1594830836
+Maintainer: Steven Barth <cyrus@openwrt.org>
+Architecture: all
+Installed-Size: 2778
+Filename: 6rd_10_all.ipk
+Size: 3574
+SHA256sum: 044da0f6f342b5316cf48b24f854872cf235aba440441e1f475fe135c6696050
+Description:  Provides support for 6rd tunnels in /etc/config/network.
+ Refer to http://wiki.openwrt.org/doc/uci/network for
+ configuration details.
+
+Package: 6to4
+Version: 13
+Depends: libc, kmod-sit
+Source: package/network/ipv6/6to4
+SourceName: 6to4
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1594830836
+Maintainer: Jo-Philipp Wich <xm@subsignal.org>
+Architecture: all
+Installed-Size: 1044
+Filename: 6to4_13_all.ipk
+Size: 1863
+SHA256sum: f50812f9713e7be533c26f2355ded619e253fae5086f0dfdf192655f72a1433d
+Description:  Provides support for 6to4 tunnels in /etc/config/network.
+ Refer to https://openwrt.org/docs/guide-user/base-system/basic-networking
+ configuration details.
+
+Package: ath10k-board-qca988x
+Version: 20201118-3
+Depends: libc
+Source: package/firmware/linux-firmware
+SourceName: ath10k-board-qca988x
+Section: firmware
+SourceDateEpoch: 1609812984
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 777
+Filename: ath10k-board-qca988x_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1535
+SHA256sum: 5fab8af06e1f1adf269eff10443f653204f47dc3408281c64875b62a1079100c
+Description:  ath10k qca988x board firmware
+
+Package: ath10k-board-qca9984
+Version: 20201118-3
+Depends: libc
+Source: package/firmware/linux-firmware
+SourceName: ath10k-board-qca9984
+Section: firmware
+SourceDateEpoch: 1609812984
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 9801
+Filename: ath10k-board-qca9984_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10486
+SHA256sum: 84a549885f91374940eae43b25693be3c337f41f5548edc06ad6771b8caba2fa
+Description:  ath10k qca9984 board firmware
+
+Package: ath10k-board-qca99x0
+Version: 20201118-3
+Depends: libc
+Source: package/firmware/linux-firmware
+SourceName: ath10k-board-qca99x0
+Section: firmware
+SourceDateEpoch: 1609812984
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4560
+Filename: ath10k-board-qca99x0_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5237
+SHA256sum: 9422e7c3cb31ef716bc0605a26cfac58613047bb0c6fa92e437a07394883c8a1
+Description:  ath10k qca99x0 board firmware
+
+Package: ath10k-firmware-qca988x-ct
+Version: 2020-11-08-1
+Depends: libc, ath10k-board-qca988x
+Conflicts: ath10k-firmware-qca988x
+Provides: ath10k-firmware-qca988x
+Source: package/firmware/ath10k-ct-firmware
+SourceName: ath10k-firmware-qca988x-ct
+Section: firmware
+SourceDateEpoch: 1609175254
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 181716
+Filename: ath10k-firmware-qca988x-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 182779
+SHA256sum: cb3b3e78af0a2bce2155f2926c054aacc332e4df33bde4b6767a516b05647c02
+Description:  Alternative ath10k firmware for QCA988X from Candela Technologies.
+ Enables IBSS and other features.  See:
+ http://www.candelatech.com/ath10k-10.1.php
+ This firmware will NOT be used unless the standard ath10k-firmware-qca988x
+ is un-selected since the driver will try to load firmware-5.bin before
+ firmware-2.bin
+
+Package: ath10k-firmware-qca9984-ct
+Version: 2020-11-08-1
+Depends: libc, ath10k-board-qca9984
+Conflicts: ath10k-firmware-qca9984
+Provides: ath10k-firmware-qca9984
+Source: package/firmware/ath10k-ct-firmware
+SourceName: ath10k-firmware-qca9984-ct
+Section: firmware
+SourceDateEpoch: 1609175254
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 471490
+Filename: ath10k-firmware-qca9984-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 468951
+SHA256sum: 33ba972eb5d1288a3f35461790cd5c916943b33ccde2b8e9c3c697c6a92adb6a
+Description:  Alternative ath10k firmware for QCA9984 from Candela Technologies.
+ Enables IBSS and other features.  See:
+ http://www.candelatech.com/ath10k-10.4.php
+ This firmware conflicts with the standard 9984 firmware, so select only
+ one.
+
+Package: ath10k-firmware-qca99x0-ct
+Version: 2020-11-08-1
+Depends: libc, ath10k-board-qca99x0
+Conflicts: ath10k-firmware-qca99x0
+Provides: ath10k-firmware-qca99x0
+Source: package/firmware/ath10k-ct-firmware
+SourceName: ath10k-firmware-qca99x0-ct
+Section: firmware
+SourceDateEpoch: 1609175254
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 436039
+Filename: ath10k-firmware-qca99x0-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 433795
+SHA256sum: 22052191d1c44f5df8d1f999773991cfdf739206b372d8716664c29d52ff6535
+Description:  Alternative ath10k firmware for QCA99x0 from Candela Technologies.
+ Enables IBSS and other features.  See:
+ http://www.candelatech.com/ath10k-10.4.php
+ This firmware conflicts with the standard 99x0 firmware, so select only
+ one.
+
+Package: busybox
+Version: 1.33.0-1
+Depends: libc, jsonfilter
+Conflicts: busybox-selinux
+Source: package/utils/busybox
+SourceName: busybox
+License: GPL-2.0
+LicenseFiles: LICENSE archival/libarchive/bz/LICENSE
+Section: base
+Require-User: ntp=123:ntp=123
+SourceDateEpoch: 1613313369
+CPE-ID: cpe:/a:busybox:busybox
+Essential: yes
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 237704
+Filename: busybox_1.33.0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 238192
+SHA256sum: 17e53d06a42461a5a0b614ce730e154f1a4858686d4fc4c28a6894573638e13c
+Description:  The Swiss Army Knife of embedded Linux.
+ It slices, it dices, it makes Julian Fries.
+
+Package: ca-bundle
+Version: 20210119-1
+Depends: libc
+Provides: ca-certs
+Source: package/system/ca-certificates
+SourceName: ca-bundle
+Section: base
+SourceDateEpoch: 1611951640
+Architecture: all
+Installed-Size: 115934
+Filename: ca-bundle_20210119-1_all.ipk
+Size: 116753
+SHA256sum: 25c56bda0da57605637af64390656c34c4575851197d62288d664dea5768b1ee
+Description:  System CA certificates as a bundle
+
+Package: ca-certificates
+Version: 20210119-1
+Depends: libc
+Provides: ca-certs
+Source: package/system/ca-certificates
+SourceName: ca-certificates
+Section: base
+SourceDateEpoch: 1611951640
+Architecture: all
+Installed-Size: 125674
+Filename: ca-certificates_20210119-1_all.ipk
+Size: 126354
+SHA256sum: 852f642f984244cd4cc446e6c5f79fcbdf39b9da1a0d36847067acba888e9719
+Description:  System CA certificates
+
+Package: dnsmasq
+Version: 2.84-1
+Depends: libc, libubus20210215
+Source: package/network/services/dnsmasq
+SourceName: dnsmasq
+License: GPL-2.0
+LicenseFiles: COPYING
+Section: net
+Require-User: dnsmasq=453:dnsmasq=453
+SourceDateEpoch: 1612790184
+CPE-ID: cpe:/a:thekelleys:dnsmasq
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 125775
+Filename: dnsmasq_2.84-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 126386
+SHA256sum: d630436486d18b387c72e6047537c98ba72b4c921610cee7bda16560d3493464
+Description:  It is intended to provide coupled DNS and DHCP service to a LAN.
+
+Package: e2fsprogs
+Version: 1.45.6-2
+Depends: libc, libuuid1, libext2fs2
+Source: package/utils/e2fsprogs
+SourceName: e2fsprogs
+License: GPL-2.0
+LicenseFiles: NOTICE
+Section: utils
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:e2fsprogs_project:e2fsprogs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 181731
+Filename: e2fsprogs_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 181821
+SHA256sum: eb293aebaf61c2762475864e01e08456619e460ead7447fd50d9a8ae648c699f
+Description:  This package contains essential ext2 filesystem utilities which consists of
+ e2fsck, mke2fs and most of the other core ext2 filesystem utilities.
+
+Package: firewall
+Version: 2020-09-05-8c2f9fad-1
+Depends: libc, libubox20201212, libubus20210215, libuci20130104, libip4tc2, libip6tc2, libxtables12, kmod-ipt-core, kmod-ipt-conntrack, kmod-nf-conntrack6, kmod-ipt-nat
+Source: package/network/config/firewall
+SourceName: firewall
+License: ISC
+Section: net
+SourceDateEpoch: 1599313396
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 47508
+Filename: firewall_2020-09-05-8c2f9fad-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 48254
+SHA256sum: 45159f383811fb37e7b440221a07b4e556cf256491326813f990e0f68f76a803
+Description:  This package provides a config-compatible C implementation of the UCI firewall.
+
+Package: getrandom
+Version: 2020-10-25-9ef88681-1
+Depends: libc
+Source: package/system/ubox
+SourceName: getrandom
+License: GPL-2.0
+Section: base
+SourceDateEpoch: 1603629382
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1389
+Filename: getrandom_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2180
+SHA256sum: 8c2c86c8499dd7e51c37764058a7c45111a1bc2b7cbebfb449fd948b0183ce21
+Description:  OpenWrt getrandom system helper
+
+Package: hostapd-common
+Version: 2020-06-08-5a8b3662-32
+Depends: libc
+Source: package/network/services/hostapd
+SourceName: hostapd-common
+License: BSD-3-Clause
+Section: net
+SourceDateEpoch: 1615144626
+CPE-ID: cpe:/a:w1.fi:hostapd
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10843
+Filename: hostapd-common_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11663
+SHA256sum: c7ad7095a925b28ec75047628f1042ffdd39a9655b9489fdc5581ceb71b1812f
+Description:  hostapd/wpa_supplicant common support files
+
+Package: hostapd-utils
+Version: 2020-06-08-5a8b3662-32
+Depends: libc
+Source: package/network/services/hostapd
+SourceName: hostapd-utils
+License: BSD-3-Clause
+Section: net
+SourceDateEpoch: 1615144626
+CPE-ID: cpe:/a:w1.fi:hostapd
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 16950
+Filename: hostapd-utils_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
+Size: 17830
+SHA256sum: 113e6b4710ff78ed44cad7df59d867179ef706ac21218b215058743cd8ad44be
+Description:  This package contains a command line utility to control the
+ IEEE 802.1x/WPA/EAP/RADIUS Authenticator.
+
+Package: ip-tiny
+Version: 5.10.0-1
+Depends: libc, libnl-tiny1
+Provides: ip
+Alternatives: 200:/sbin/ip:/usr/libexec/ip-tiny
+Source: package/network/utils/iproute2
+SourceName: ip-tiny
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1615144626
+CPE-ID: cpe:/a:iproute2_project:iproute2
+Maintainer: Russell Senior <russell@personaltelco.net>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 138539
+Filename: ip-tiny_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 139215
+SHA256sum: f88e9fe1799df5846ef591cc25bdea89917f69c895a788beaa466fd92b3d1dbd
+Description:  Routing control utility (Minimal)
+
+Package: ipset
+Version: 7.6-1
+Depends: libc, kmod-ipt-ipset, libmnl0, libipset13
+Source: package/network/utils/ipset
+SourceName: ipset
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1136
+Filename: ipset_7.6-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1920
+SHA256sum: db64fee7e759ccbd1979d6a11fed00793500a169ef0e099572f661e1dd90093f
+Description:  IPset administration utility
+
+Package: iw
+Version: 5.9-1
+Depends: libc, libnl-tiny1
+Source: package/network/utils/iw
+SourceName: iw
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613312132
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 42998
+Filename: iw_5.9-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 43817
+SHA256sum: 3cc358a74ac0ac42139b5b381601b3744fdacc042e57d59afdf611b6a20b1e46
+Description:  cfg80211 interface configuration utility
+
+Package: jshn
+Version: 2020-12-12-35787769-1
+Depends: libc, libjson-c5, libubox20201212, libblobmsg-json20201212
+Source: package/libs/libubox
+SourceName: jshn
+License: ISC
+Section: utils
+SourceDateEpoch: 1613411239
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6337
+Filename: jshn_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7173
+SHA256sum: 85b7262fc4a9d9d50b48c69f83a4274243f91bfa6d050aad5db150f2b030c8dc
+Description:  Library for parsing and generating JSON from shell scripts
+
+Package: jsonfilter
+Version: 2018-02-04-c7e938d6-1
+Depends: libc, libubox20201212, libjson-c5
+Source: package/utils/jsonfilter
+SourceName: jsonfilter
+License: ISC
+Section: base
+SourceDateEpoch: 1521049703
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 9225
+Filename: jsonfilter_2018-02-04-c7e938d6-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9992
+SHA256sum: cfaa4544f018a3ab2be79c20a30f5bfafbe3c6c9de4cf154a06e0da4bc3651b0
+Description:  OpenWrt JSON filter utility
+
+Package: libblkid1
+Version: 2.36.1-2
+Depends: libc, libuuid1
+Provides: libblkid
+Source: package/utils/util-linux
+SourceName: libblkid
+License: GPL-2.0
+LicenseFiles: COPYING libblkid/COPYING libmount/COPYING Documentation/licenses/COPYING.GPLv2 Documentation/licenses/COPYING.LGPLv2.1 libuuid/COPYING Documentation/licenses/COPYING.BSD-3
+Section: libs
+SourceDateEpoch: 1613430014
+CPE-ID: cpe:/a:kernel:util-linux
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 118653
+Filename: libblkid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 119246
+SHA256sum: 3b35ddc7c0e84f8da01b3f1e113be5edb7bdd8eec9a74704235c4d0fb0a509a0
+Description:  The libblkid library is used to identify block devices (disks) as to their
+ content (e.g. filesystem type, partitions) as well as extracting additional
+ information such as filesystem labels/volume names, partitions, unique
+ identifiers/serial numbers...
+
+Package: libblobmsg-json20201212
+Version: 2020-12-12-35787769-1
+Depends: libc, libjson-c5, libubox20201212
+Provides: libblobmsg-json
+Source: package/libs/libubox
+SourceName: libblobmsg-json
+License: ISC
+Section: libs
+SourceDateEpoch: 1613411239
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3383
+Filename: libblobmsg-json20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4144
+SHA256sum: 38ca68b80de0d1d46b80af9ca6383d4c9315386b8f8a5013fc937b5ad8cbe699
+Description:  blobmsg <-> json conversion library
+
+Package: libcomerr0
+Version: 1.45.6-2
+Depends: libc, libuuid1
+Provides: libcomerr
+Source: package/utils/e2fsprogs
+SourceName: libcomerr
+License: GPL-2.0
+LicenseFiles: NOTICE
+Section: libs
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:e2fsprogs_project:e2fsprogs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3653
+Filename: libcomerr0_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4436
+SHA256sum: c043c8bd2939fb59ce6a8bb9b612d0817df45fb9173e437f97723f2cc621ede5
+Description:  This package contains libcom_err, the common error description library
+ bundled with e2fsprogs.
+
+Package: libelf1
+Version: 0.180-1
+Depends: libc, zlib
+Provides: libelf, libelf11
+Source: package/libs/elfutils
+SourceName: libelf
+License: GPL-3.0-or-later
+LicenseFiles: COPYING COPYING-GPLV2 COPYING-LGPLV3
+Section: libs
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:elfutils_project:elfutils
+Maintainer: Luiz Angelo Daros de Luca <luizluca@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 38161
+Filename: libelf1_0.180-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 39072
+SHA256sum: c72f5c8cda5e82af3febbe894d178709078aa70636006240488ab9fee3a9438f
+Description:  ELF manipulation libraries (libelf)
+
+Package: libext2fs2
+Version: 1.45.6-2
+Depends: libc, libuuid1, libblkid1, libss2, libcomerr0
+Provides: libext2fs
+Source: package/utils/e2fsprogs
+SourceName: libext2fs
+License: GPL-2.0
+LicenseFiles: NOTICE
+Section: libs
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:e2fsprogs_project:e2fsprogs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 165825
+Filename: libext2fs2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 165903
+SHA256sum: 2d2a629e7920d79616863565ae6c7d6b9480bb4120b91418dccc3c770e42726e
+Description:  libext2fs is a library which can access ext2, ext3 and ext4 filesystems.
+
+Package: libipset13
+Version: 7.6-1
+Depends: libc, kmod-ipt-ipset, libmnl0
+Provides: libipset
+Source: package/network/utils/ipset
+SourceName: libipset
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 40303
+Filename: libipset13_7.6-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 40852
+SHA256sum: 26e573831eec6fe0d9993ddf52a32b773b70575dc61375defdccd65141f96f44
+Description:  IPset administration utility
+
+Package: libjson-c5
+Version: 0.15-1
+Depends: libc
+Provides: libjson-c
+Source: package/libs/libjson-c
+SourceName: libjson-c
+License: MIT
+LicenseFiles: COPYING
+Section: libs
+SourceDateEpoch: 1605361710
+CPE-ID: cpe:/a:json-c_project:json-c
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 23588
+Filename: libjson-c5_0.15-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 24327
+SHA256sum: 3166ee378f9b3da9ef6bb3cb0713c60cec8dca0f29e4f1a26d7dd7b98cf103db
+Description:  This package contains a library for javascript object notation backends.
+
+Package: libjson-script20201212
+Version: 2020-12-12-35787769-1
+Depends: libc, libubox20201212
+Provides: libjson-script
+Source: package/libs/libubox
+SourceName: libjson-script
+License: ISC
+Section: utils
+SourceDateEpoch: 1613411239
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4228
+Filename: libjson-script20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4987
+SHA256sum: 50eea04b358d6430d69d41982b72de76481d8a4ae3cb00052e37e8d1589c4cc7
+Description:  Minimalistic JSON based scripting engine
+
+Package: libltdl7
+Version: 2.4.6-2
+Depends: libc
+Provides: libltdl
+Source: package/libs/libtool
+SourceName: libltdl
+License: GPL-2.0+
+LicenseFiles: COPYING
+Section: libs
+SourceDateEpoch: 1548322770
+CPE-ID: cpe:/a:gnu:libtool
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 13186
+Filename: libltdl7_2.4.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13862
+SHA256sum: 087f9a9dda0bfd8c8db6c1985f4514a245ad08a08136fc2b19e25ae695c5fc69
+Description:  A generic dynamic object loading library
+
+Package: liblua5.1.5
+Version: 5.1.5-8
+Depends: libc
+Provides: liblua
+Source: package/utils/lua
+SourceName: liblua
+License: MIT
+LicenseFiles: COPYRIGHT
+Section: libs
+SourceDateEpoch: 1609983537
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 60107
+Filename: liblua5.1.5_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk
+Size: 60884
+SHA256sum: be3cb66fa9674aa9a83d43f8f180371db53ab437e748db037ed15d2ddf287020
+Description:  Lua is a powerful light-weight programming language designed for extending 
+ applications. Lua is also frequently used as a general-purpose, stand-alone 
+ language. Lua is free software.
+ This package contains the Lua shared libraries, needed by other programs.
+
+Package: libmnl0
+Version: 1.0.4-2
+Depends: libc
+Provides: libmnl
+Source: package/libs/libmnl
+SourceName: libmnl
+License: LGPL-2.1+
+Section: libs
+SourceDateEpoch: 1548322770
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5360
+Filename: libmnl0_1.0.4-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6595
+SHA256sum: 0e2077f3e7a8d7749867f9e9e15110cde3f317cc6bb2c7ca19f9279749b38508
+Description:  libmnl is a minimalistic user-space library oriented to Netlink developers.
+ There are a lot of common tasks in parsing, validating, constructing of
+ both the Netlink header and TLVs that are repetitive and easy to get wrong.
+ This library aims to provide simple helpers that allows you to re-use code
+ and to avoid re-inventing the wheel. The main features of this library are:
+ .
+ * Small: the shared library requires around 30KB for an x86-based computer.
+ .
+ * Simple: this library avoids complexity and elaborated abstractions that
+ tend to hide Netlink details.
+ .
+ * Easy to use: the library simplifies the work for Netlink-wise developers.
+ It provides functions to make socket handling, message building, validating,
+ parsing and sequence tracking, easier.
+ .
+ * Easy to re-use: you can use the library to build your own abstraction layer
+ on top of this library.
+ .
+ * Decoupling: the interdependency of the main bricks that compose the library
+ is reduced, i.e. the library provides many helpers, but the programmer is not
+ forced to use them.
+
+Package: libncurses6
+Version: 6.2-1
+Depends: libc, terminfo
+Provides: libncursesw, libncurses, libncursesw6
+Source: package/libs/ncurses
+SourceName: libncurses
+License: MIT
+LicenseFiles: README
+Section: libs
+SourceDateEpoch: 1583437738
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 155131
+Filename: libncurses6_6.2-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 153256
+SHA256sum: 9208b75feb937c58d74acaba9d6eb2dbef4ab6d0ee26b8e353a99c0b3df8dc96
+Description:  Terminal handling library (Unicode)
+
+Package: libnl-tiny1
+Version: 2020-08-05-c291088f-1
+Depends: libc
+Provides: libnl-tiny
+Source: package/libs/libnl-tiny
+SourceName: libnl-tiny
+License: LGPL-2.1
+Section: libs
+SourceDateEpoch: 1605176763
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12609
+Filename: libnl-tiny1_2020-08-05-c291088f-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13397
+SHA256sum: 539b2da9f8b7d4e9a23c4a13fab4fb19338aefe767a8b48ad0f001115ef0ea5f
+Description:  This package contains a stripped down version of libnl
+
+Package: libopenssl-conf
+Version: 1.1.1j-1
+Depends: libc, libopenssl1.1
+Source: package/libs/openssl
+SourceName: libopenssl-conf
+License: OpenSSL
+LicenseFiles: LICENSE
+Section: libs
+SourceDateEpoch: 1614194658
+CPE-ID: cpe:/a:openssl:openssl
+Maintainer: Eneas U de Queiroz <cotequeiroz@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4784
+Filename: libopenssl-conf_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5803
+SHA256sum: 8db69c78948c43265af97ab6df974b65d4ae8df4d1130cb32214be9c16d011ba
+Description:  The OpenSSL Project is a collaborative effort to develop a robust,
+ commercial-grade, full-featured, and Open Source toolkit implementing the
+ Transport Layer Security (TLS) protocol as well as a full-strength
+ general-purpose cryptography library.
+ This package installs the OpenSSL configuration file /etc/ssl/openssl.cnf.
+
+Package: libopenssl-devcrypto
+Version: 1.1.1j-1
+Depends: libc, libopenssl1.1, kmod-cryptodev, libopenssl-conf
+Source: package/libs/openssl
+SourceName: libopenssl-devcrypto
+License: OpenSSL
+LicenseFiles: LICENSE
+Section: libs
+SourceDateEpoch: 1614194658
+CPE-ID: cpe:/a:openssl:openssl
+Maintainer: Eneas U de Queiroz <cotequeiroz@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7289
+Filename: libopenssl-devcrypto_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8332
+SHA256sum: 6e006672bb6dfdc6e117cfb95941558d393951599e919446a32e215f2fd0ba90
+Description:  This package adds an engine that enables hardware acceleration
+ through the /dev/crypto kernel interface.
+ To use it, you need to configure the engine in /etc/ssl/openssl.cnf
+ See https://www.openssl.org/docs/man1.1.1/man5/config.html#Engine-Configuration-Module
+ and https://openwrt.org/docs/techref/hardware/cryptographic.hardware.accelerators
+ The engine_id is "devcrypto"
+
+Package: libopenssl1.1
+Version: 1.1.1j-1
+Depends: libc
+Provides: libopenssl
+Source: package/libs/openssl
+SourceName: libopenssl
+License: OpenSSL
+LicenseFiles: LICENSE
+Section: libs
+SourceDateEpoch: 1614194658
+CPE-ID: cpe:/a:openssl:openssl
+Maintainer: Eneas U de Queiroz <cotequeiroz@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1098416
+Filename: libopenssl1.1_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1088303
+SHA256sum: 55b5828a7729169ef5a4bee93720363a63a4774a32e697682a2bedcb3fb9c3d5
+Description:  The OpenSSL Project is a collaborative effort to develop a robust,
+ commercial-grade, full-featured, and Open Source toolkit implementing the
+ Transport Layer Security (TLS) protocol as well as a full-strength
+ general-purpose cryptography library.
+ This package contains the OpenSSL shared libraries, needed by other programs.
+
+Package: libsmartcols1
+Version: 2.36.1-2
+Depends: libc, librt
+Provides: libsmartcols
+Source: package/utils/util-linux
+SourceName: libsmartcols
+License: GPL-2.0
+LicenseFiles: COPYING libblkid/COPYING libmount/COPYING Documentation/licenses/COPYING.GPLv2 Documentation/licenses/COPYING.LGPLv2.1 libuuid/COPYING Documentation/licenses/COPYING.BSD-3
+Section: libs
+SourceDateEpoch: 1613430014
+CPE-ID: cpe:/a:kernel:util-linux
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 77755
+Filename: libsmartcols1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 78557
+SHA256sum: 2df478a134d71756d9122cbd989c0cc8f36e373e0361d2446601516f2b37b8ee
+Description:  The smartcols library is used to print tables and trees in a pretty way.
+
+Package: libss2
+Version: 1.45.6-2
+Depends: libc, libcomerr0
+Provides: libss
+Source: package/utils/e2fsprogs
+SourceName: libss
+License: GPL-2.0
+LicenseFiles: NOTICE
+Section: libs
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:e2fsprogs_project:e2fsprogs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7563
+Filename: libss2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8409
+SHA256sum: 894ba39f4b63840e8953ad034677e8b2b87c35be0dc9444760c7fca5bb2ba488
+Description:  This pacakge contains libss, a command-line interface parsing library
+ bundled with e2fsprogs.
+
+Package: libubox20201212
+Version: 2020-12-12-35787769-1
+Depends: libc
+Provides: libubox
+Source: package/libs/libubox
+SourceName: libubox
+License: ISC
+Section: libs
+SourceDateEpoch: 1613411239
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 18261
+Filename: libubox20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19011
+SHA256sum: ae0f868ed3ccff3b35d73839ac1e6bf76b009fc7e7574d66da4acc5e2db880b2
+Description:  Basic utility library
+
+Package: libubus-lua
+Version: 2021-02-15-2537be01-1
+Depends: libc, libubus20210215, liblua5.1.5
+Source: package/system/ubus
+SourceName: libubus-lua
+License: LGPL-2.1
+Section: libs
+SourceDateEpoch: 1613414473
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6110
+Filename: libubus-lua_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6884
+SHA256sum: 3bb71120aaa884e12aa2a2f738860ec798627db5aa12578c08df8f959c146e0b
+Description:  Lua binding for the OpenWrt RPC client
+
+Package: libubus20210215
+Version: 2021-02-15-2537be01-1
+Depends: libc, libubox20201212
+Provides: libubus
+Source: package/system/ubus
+SourceName: libubus
+License: LGPL-2.1
+Section: libs
+SourceDateEpoch: 1613414473
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8850
+Filename: libubus20210215_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9676
+SHA256sum: 1ef02c65489f715f83d1d78c5ffc16c9c18e0ee3256043459942d2f3cfdf8b30
+Description:  OpenWrt RPC client library
+
+Package: libuci20130104
+Version: 2020-10-06-52bbc99f-4
+Depends: libc, libubox20201212
+Provides: libuci
+Source: package/system/uci
+SourceName: libuci
+License: LGPL-2.1
+Section: libs
+SourceDateEpoch: 1613474876
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 14925
+Filename: libuci20130104_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15707
+SHA256sum: 9add6afdd157075b077ec32de312ffe43e139c1ce445e4c426cd376815f8d7d6
+Description:  C library for the Unified Configuration Interface (UCI)
+
+Package: libuclient20201210
+Version: 2020-12-10-2c843b2b-1
+Depends: libc, libubox20201212
+Provides: libuclient
+Source: package/libs/uclient
+SourceName: libuclient
+License: ISC
+Section: libs
+SourceDateEpoch: 1607935299
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8803
+Filename: libuclient20201210_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9583
+SHA256sum: a4ef160f23b7d45382da11789f690f4d8cf1bc2dedb08bf5f15dad964bfa1ae4
+Description:  HTTP/1.1 client library
+
+Package: libustream-openssl20201210
+Version: 2020-12-10-68d09243-1
+Depends: libc, libubox20201212, libopenssl1.1
+Provides: libustream-openssl
+Source: package/libs/ustream-ssl
+SourceName: libustream-openssl
+License: ISC
+Section: libs
+SourceDateEpoch: 1607935299
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3830
+Filename: libustream-openssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4604
+SHA256sum: 28726cfdc00070f061fe03fb0f356f7a782b362545559741d7fe4b206a503807
+Description:  ustream SSL Library (openssl)
+
+Package: libustream-wolfssl20201210
+Version: 2020-12-10-68d09243-1
+Depends: libc, libubox20201212, libwolfssl4.7.0.66253b90
+Provides: libustream-wolfssl
+Source: package/libs/ustream-ssl
+SourceName: libustream-wolfssl
+License: ISC
+Section: libs
+SourceDateEpoch: 1607935299
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3477
+Filename: libustream-wolfssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4222
+SHA256sum: 260889c28fae55a43e397c914e2e6d5d02cfb46b704ba2e7aec1daa0f5e5a1f2
+Description:  ustream SSL Library (wolfssl)
+
+Package: libuuid1
+Version: 2.36.1-2
+Depends: libc, librt
+Provides: libuuid
+Source: package/utils/util-linux
+SourceName: libuuid
+License: GPL-2.0
+LicenseFiles: COPYING libblkid/COPYING libmount/COPYING Documentation/licenses/COPYING.GPLv2 Documentation/licenses/COPYING.LGPLv2.1 libuuid/COPYING Documentation/licenses/COPYING.BSD-3
+Section: libs
+SourceDateEpoch: 1613430014
+CPE-ID: cpe:/a:kernel:util-linux
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 11277
+Filename: libuuid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12251
+SHA256sum: 3ec3e7b6369055670fc9bba851d1aea2e5c9a4593e7c14b14eeaa50d0b5f8f3d
+Description:  The UUID library is used to generate unique identifiers for objects
+ that may be accessible beyond the local system. This library
+ generates UUIDs compatible with those created by the Open Software
+ Foundation (OSF) Distributed Computing Environment (DCE) utility.
+
+Package: libwolfssl4.7.0.66253b90
+Version: 4.7.0-stable-1
+Depends: libc
+Provides: libcyassl, libwolfssl, libcyassl4.7.0.66253b90
+Source: package/libs/wolfssl
+SourceName: libwolfssl
+License: GPL-2.0-or-later
+LicenseFiles: LICENSING COPYING
+Section: libs
+SourceDateEpoch: 1614194653
+CPE-ID: cpe:/a:wolfssl:wolfssl
+Maintainer: Eneas U de Queiroz <cotequeiroz@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 406417
+Filename: libwolfssl4.7.0.66253b90_4.7.0-stable-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 404885
+SHA256sum: 7a128f0da2452f1b60c4518c81c31f1d57399451c7b93d5d8624f5fcb58ace49
+Description:  wolfSSL (formerly CyaSSL) is an SSL library optimized for small
+ footprint, both on disk and for memory use.
+
+Package: logd
+Version: 2020-10-25-9ef88681-1
+Depends: libc, libubox20201212, libubus20210215, libblobmsg-json20201212
+Source: package/system/ubox
+SourceName: logd
+License: GPL-2.0
+Section: base
+Require-User: logd=514:logd=514
+SourceDateEpoch: 1603629382
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10143
+Filename: logd_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10907
+SHA256sum: 9f40c5299504fea60a718dad4d2dca32d32242c6321307a784e933de020c30cc
+Description:  OpenWrt system log implementation
+
+Package: losetup
+Version: 2.36.1-2
+Depends: libc, libsmartcols1
+Source: package/utils/util-linux
+SourceName: losetup
+License: GPL-2.0
+LicenseFiles: COPYING libblkid/COPYING libmount/COPYING Documentation/licenses/COPYING.GPLv2 Documentation/licenses/COPYING.LGPLv2.1 libuuid/COPYING Documentation/licenses/COPYING.BSD-3
+Section: utils
+SourceDateEpoch: 1613430014
+CPE-ID: cpe:/a:kernel:util-linux
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 36930
+Filename: losetup_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 37845
+SHA256sum: 5e4e76b4673735c0dca7e51be5cd8d06b666713bcca92b475e19630f7dcd4fb6
+Description:  losetup is used to associate loop devices with regular files or block devices,
+ to detach loop devices and to query the status of a loop device
+
+Package: lua
+Version: 5.1.5-8
+Depends: libc, liblua5.1.5
+Source: package/utils/lua
+SourceName: lua
+License: MIT
+LicenseFiles: COPYRIGHT
+Section: lang
+SourceDateEpoch: 1609983537
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4565
+Filename: lua_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5418
+SHA256sum: 702195567586d73ea6f203435145398c2dfafc2904ff59aa67c667e69df5ae32
+Description:  Lua is a powerful light-weight programming language designed for extending 
+ applications. Lua is also frequently used as a general-purpose, stand-alone 
+ language. Lua is free software.
+ This package contains the Lua language interpreter.
+
+Package: netifd
+Version: 2021-01-09-c00c8335-1
+Depends: libc, libuci20130104, libnl-tiny1, libubus20210215, ubus, ubusd, jshn, libubox20201212
+Source: package/network/config/netifd
+SourceName: netifd
+License: GPL-2.0
+Section: base
+SourceDateEpoch: 1610914959
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 77449
+Filename: netifd_2021-01-09-c00c8335-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 78193
+SHA256sum: 641e996cb1f5ae1d3ccc4a05767cbde634e663c360a2946561394d5e9a39d7ef
+Description:  OpenWrt Network Interface Configuration Daemon
+
+Package: odhcp6c
+Version: 2021-01-09-53f07e90-16
+Depends: libc, libubox20201212
+Source: package/network/ipv6/odhcp6c
+SourceName: odhcp6c
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1610914959
+Maintainer: Hans Dedecker <dedeckeh@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 25582
+Filename: odhcp6c_2021-01-09-53f07e90-16_arm_cortex-a15_neon-vfpv4.ipk
+Size: 26381
+SHA256sum: ec859942dc3ee6d6c0bc44a780c7a4c6cd51cd90b2dc8e0aff7f2487c91d30f9
+Description:  Embedded DHCPv6-client for OpenWrt
+
+Package: odhcpd-ipv6only
+Version: 2021-01-06-8d8a8cd3-2
+Depends: libc, libubox20201212, libuci20130104, libubus20210215, libnl-tiny1
+Source: package/network/services/odhcpd
+SourceName: odhcpd-ipv6only
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613349283
+Maintainer: Hans Dedecker <dedeckeh@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 35917
+Filename: odhcpd-ipv6only_2021-01-06-8d8a8cd3-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 36926
+SHA256sum: a7b15ed92a8a900628a3ff0f37ff765561c651742e9d63859a7686e1841be0b7
+Description:  odhcpd is a daemon for serving and relaying IP management protocols to
+ configure clients and downstream routers. It tries to follow the RFC 6204
+ requirements for IPv6 home routers.
+ 
+ This is a variant providing server services for RA, stateless and stateful
+ DHCPv6,  prefix delegation and can be used to relay RA, DHCPv6 and NDP between
+ routed (non-bridged) interfaces in case no delegated prefixes are available.
+
+Package: openssl-util
+Version: 1.1.1j-1
+Depends: libc, libopenssl1.1, libopenssl-conf
+Source: package/libs/openssl
+SourceName: openssl-util
+License: OpenSSL
+LicenseFiles: LICENSE
+Section: utils
+SourceDateEpoch: 1614194658
+CPE-ID: cpe:/a:openssl:openssl
+Maintainer: Eneas U de Queiroz <cotequeiroz@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 247758
+Filename: openssl-util_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 246094
+SHA256sum: 5907722d6bea600a5fb0bb6958c5f459c221785d4a2f16d90cc359f3006738d7
+Description:  The OpenSSL Project is a collaborative effort to develop a robust,
+ commercial-grade, full-featured, and Open Source toolkit implementing the
+ Transport Layer Security (TLS) protocol as well as a full-strength
+ general-purpose cryptography library.
+ This package contains the OpenSSL command-line utility.
+
+Package: openwrt-keyring
+Version: 2021-02-20-49283916-1
+Depends: libc
+Provides: lede-keyring
+Source: package/system/openwrt-keyring
+SourceName: openwrt-keyring
+License: GPL-2.0
+Section: base
+SourceDateEpoch: 1613833277
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1392
+Filename: openwrt-keyring_2021-02-20-49283916-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2202
+SHA256sum: acee633533cd81b62643919fa764b61d0b41eadce9b6307acaed79b7200e14d1
+Description:  The keyring of with the developer using and gpg public keys.
+
+Package: opkg
+Version: 2020-12-24-9bbc7eae-1
+Depends: libc, uclient-fetch, libpthread, libubox20201212
+Source: package/system/opkg
+SourceName: opkg
+License: GPL-2.0
+LicenseFiles: COPYING
+Section: base
+SourceDateEpoch: 1608808377
+Essential: yes
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 66151
+Filename: opkg_2020-12-24-9bbc7eae-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 67180
+SHA256sum: 42e945d19808882bb00108530d8616c6868ca3a30422e9fe60d419c41d17187c
+Description:  Lightweight package management system
+ opkg is the opkg Package Management System, for handling
+ installation and removal of packages on a system. It can
+ recursively follow dependencies and download all packages
+ necessary to install a particular package.
+ 
+ opkg knows how to install both .ipk and .deb packages.
+
+Package: ppp-mod-pppoe
+Version: 2.4.8.git-2020-10-03-3
+Depends: libc, kmod-pppoe
+Source: package/network/services/ppp
+SourceName: ppp-mod-pppoe
+License: BSD-4-Clause
+Section: net
+SourceDateEpoch: 1609527359
+CPE-ID: cpe:/a:samba:ppp
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10035
+Filename: ppp-mod-pppoe_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10857
+SHA256sum: 384dd82a7b5ef74bf98062c6c9d71a503a16424a4c9939ab972c06c13d27b7e0
+Description:  This package contains a PPPoE (PPP over Ethernet) plugin for ppp.
+
+Package: ppp
+Version: 2.4.8.git-2020-10-03-3
+Depends: libc, kmod-ppp
+Source: package/network/services/ppp
+SourceName: ppp
+License: BSD-4-Clause
+Section: net
+SourceDateEpoch: 1609527359
+CPE-ID: cpe:/a:samba:ppp
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 121542
+Filename: ppp_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 121713
+SHA256sum: 23b2e95464442c19257674fe9922eae99b94a5c244b72a7efcfe9b46a6710bae
+Description:  This package contains the PPP (Point-to-Point Protocol) daemon.
+
+Package: procd
+Version: 2021-02-08-08938fe1-2
+Depends: libc, ubusd, ubus, libjson-script20201212, ubox, libubox20201212, libubus20210215, libblobmsg-json20201212, libjson-c5, jshn
+Conflicts: procd-selinux
+Source: package/system/procd
+SourceName: procd
+License: GPL-2.0
+Section: base
+Require-User: :dialout=20 :audio=29
+SourceDateEpoch: 1612745834
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 49024
+Filename: procd_2021-02-08-08938fe1-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 49816
+SHA256sum: 47ae41278297d24b5e22fc35a7e5efc9049b409b1b0ab59d7bf7f68ecc3c2473
+Description:  OpenWrt system process manager
+
+Package: rpcd-mod-file
+Version: 2021-01-06-ea7f4717-1
+Depends: libc, libubus20210215, libubox20201212, rpcd
+Source: package/system/rpcd
+SourceName: rpcd-mod-file
+License: ISC
+Section: utils
+SourceDateEpoch: 1609978883
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6201
+Filename: rpcd-mod-file_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7044
+SHA256sum: 37fd1ea75a9753d6fc6b52f70a997fbc3dd1a5517a3749348f39800e7d0c79dc
+Description:  Provides ubus calls for file and directory operations.
+
+Package: rpcd-mod-iwinfo
+Version: 2021-01-06-ea7f4717-1
+Depends: libc, libubus20210215, libubox20201212, rpcd, libiwinfo20210106
+Source: package/system/rpcd
+SourceName: rpcd-mod-iwinfo
+License: ISC
+Section: utils
+SourceDateEpoch: 1609978883
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6902
+Filename: rpcd-mod-iwinfo_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7752
+SHA256sum: 9e8522c16ad0df1f712797723fc462f2b5eab2a00e593389594056e0f9d6bbb7
+Description:  Provides ubus calls for accessing iwinfo data.
+
+Package: rpcd
+Version: 2021-01-06-ea7f4717-1
+Depends: libc, libubus20210215, libubox20201212, libuci20130104, libblobmsg-json20201212, libjson-c5
+Source: package/system/rpcd
+SourceName: rpcd
+License: ISC
+Section: utils
+SourceDateEpoch: 1609978883
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 22190
+Filename: rpcd_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 22938
+SHA256sum: e4ba8318f7f218771f176c212d3e765763a4b1bc127177450535b8c6c1d2685a
+Description:  This package provides the UBUS RPC backend server to expose various
+ functionality to frontend programs via JSON-RPC.
+
+Package: swconfig
+Version: 12
+Depends: libc, libuci20130104, libnl-tiny1
+Source: package/network/config/swconfig
+SourceName: swconfig
+License: GPL-2.0
+Section: base
+SourceDateEpoch: 1573253873
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8600
+Filename: swconfig_12_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9379
+SHA256sum: 895ce7c112c6ff69908fbf7c88713a2a09ca8fb0297efaff13bdc1e1664e1689
+Description:  Switch configuration utility
+
+Package: tc
+Version: 5.10.0-1
+Depends: libc, kmod-sched-core, libxtables12, libelf1
+Source: package/network/utils/iproute2
+SourceName: tc
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1615144626
+CPE-ID: cpe:/a:iproute2_project:iproute2
+Maintainer: Russell Senior <russell@personaltelco.net>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 179431
+Filename: tc_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 180057
+SHA256sum: c9837a429a8795c0e916c6441df2bfc0979cebea47f73de1f0438ca53ee66571
+Description:  Traffic control utility
+
+Package: terminfo
+Version: 6.2-1
+Depends: libc
+Source: package/libs/ncurses
+SourceName: terminfo
+License: MIT
+LicenseFiles: README
+Section: libs
+SourceDateEpoch: 1583437738
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6292
+Filename: terminfo_6.2-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6981
+SHA256sum: f5baba6db25384582548d444c45df52d7b95a92e71877d521f946a97e897f485
+Description:  Terminal Info Database (ncurses)
+
+Package: ubox
+Version: 2020-10-25-9ef88681-1
+Depends: libc, libubox20201212, ubusd, ubus, libubus20210215, libuci20130104
+Alternatives: 100:/sbin/rmmod:/sbin/kmodloader, 100:/sbin/insmod:/sbin/kmodloader, 100:/sbin/lsmod:/sbin/kmodloader, 100:/sbin/modinfo:/sbin/kmodloader, 100:/sbin/modprobe:/sbin/kmodloader
+Source: package/system/ubox
+SourceName: ubox
+License: GPL-2.0
+Section: base
+SourceDateEpoch: 1603629382
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 13970
+Filename: ubox_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 14811
+SHA256sum: 0932483dce5a1eaf479a75abf047703abe5c8c0b39114247fd65d05b47a2eb18
+Description:  OpenWrt system helper toolbox
+
+Package: ubus
+Version: 2021-02-15-2537be01-1
+Depends: libc, libubus20210215, libblobmsg-json20201212, ubusd
+Source: package/system/ubus
+SourceName: ubus
+License: LGPL-2.1
+Section: base
+SourceDateEpoch: 1613414473
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5526
+Filename: ubus_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6302
+SHA256sum: e66eaaa548b69f2acd71d150172e316002dae88b2c863bf424b3f921f3b371a9
+Description:  OpenWrt RPC client utility
+
+Package: ubusd
+Version: 2021-02-15-2537be01-1
+Depends: libc, libubox20201212, libblobmsg-json20201212
+Source: package/system/ubus
+SourceName: ubusd
+License: LGPL-2.1
+Section: base
+Require-User: ubus=81:ubus=81
+SourceDateEpoch: 1613414473
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10525
+Filename: ubusd_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11299
+SHA256sum: 0fe3380b66e9fc6522133843c0419e4108a24f731d57f1f981d55c3a6dc1c259
+Description:  OpenWrt RPC daemon
+
+Package: uci
+Version: 2020-10-06-52bbc99f-4
+Depends: libc, libuci20130104
+Source: package/system/uci
+SourceName: uci
+License: LGPL-2.1
+Section: base
+SourceDateEpoch: 1613474876
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6796
+Filename: uci_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7616
+SHA256sum: 2500cdd6cd5fb5a8d42ba9dcb020be77f355649e2ae422267de853638fd178e6
+Description:  Utility for the Unified Configuration Interface (UCI)
+
+Package: uclient-fetch
+Version: 2020-12-10-2c843b2b-1
+Depends: libc, libuclient20201210
+Provides: wget
+Alternatives: 200:/usr/bin/wget:/bin/uclient-fetch
+Source: package/libs/uclient
+SourceName: uclient-fetch
+License: ISC
+Section: net
+SourceDateEpoch: 1607935299
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7401
+Filename: uclient-fetch_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8235
+SHA256sum: 5bf2fc49fb29c86d593d67419faa6996f5eb810c4cc3416d9c5a0ee72bc6224f
+Description:  Tiny wget replacement using libuclient
+
+Package: uhttpd-mod-ubus
+Version: 2020-11-23-f53a6399-1
+Depends: libc, uhttpd, libubus20210215, libblobmsg-json20201212
+Source: package/network/services/uhttpd
+SourceName: uhttpd-mod-ubus
+License: ISC
+Section: net
+SourceDateEpoch: 1608457011
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7348
+Filename: uhttpd-mod-ubus_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8215
+SHA256sum: b8fd0648c73908366a2ee4e4f25b0d1816f33baac0b3f71dd7ab59ebd6272069
+Description:  The ubus plugin adds a HTTP/JSON RPC proxy for ubus and publishes the
+ session.* namespace and procedures.
+
+Package: uhttpd
+Version: 2020-11-23-f53a6399-1
+Depends: libc, libubox20201212, libblobmsg-json20201212, libjson-script20201212, libjson-c5
+Source: package/network/services/uhttpd
+SourceName: uhttpd
+License: ISC
+Section: net
+SourceDateEpoch: 1608457011
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 25604
+Filename: uhttpd_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 26439
+SHA256sum: 4dddb5190238a5d5e45e7d586c62bbc3f7a1e1c529aa9730e3e0de896243b342
+Description:  uHTTPd is a tiny single threaded HTTP server with TLS, CGI and Lua
+ support. It is intended as a drop-in replacement for the Busybox
+ HTTP daemon.
+
+Package: umdns
+Version: 2021-01-26-78aa36b0-1
+Depends: libc, libubox20201212, libubus20210215, libblobmsg-json20201212
+Source: package/network/services/umdns
+SourceName: umdns
+License: LGPL-2.1
+Section: net
+SourceDateEpoch: 1611702536
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 14927
+Filename: umdns_2021-01-26-78aa36b0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15727
+SHA256sum: efdf4c46fa00eee2481c7fe476014e851958a4355f7f7dcc7342f49b192afd5c
+Description:  OpenWrt Multicast DNS Daemon
+
+Package: urandom-seed
+Version: 3
+Depends: libc, getrandom
+Source: package/system/urandom-seed
+SourceName: urandom-seed
+License: GPL-2.0-only
+Section: base
+SourceDateEpoch: 1611926981
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 836
+Filename: urandom-seed_3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1586
+SHA256sum: b4b8530bad2b3efad0f9135a50fd622a8ecfcec4ffc328767f0f0f839a34a326
+Description:  /etc/urandom.seed handling for OpenWrt
+
+Package: urngd
+Version: 2020-01-21-c7f7b6b6-1
+Depends: libc, libubox20201212
+Source: package/system/urngd
+SourceName: urngd
+License: GPL-2.0 BSD-3-Clause
+Section: utils
+SourceDateEpoch: 1582494171
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4715
+Filename: urngd_2020-01-21-c7f7b6b6-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5706
+SHA256sum: 8202db6a6a3127041f716c2b9ab5ac86726d2abef04ced030da28b2ac55f11b8
+Description:  urngd is OpenWrt's micro non-physical true random number generator based on
+ timing jitter.
+ 
+ Using the Jitter RNG core, the rngd provides an entropy source that feeds into
+ the Linux /dev/random device if its entropy runs low. It updates the
+ /dev/random entropy estimator such that the newly provided entropy unblocks
+ /dev/random.
+ 
+ The seeding of /dev/random also ensures that /dev/urandom benefits from
+ entropy. Especially during boot time, when the entropy of Linux is low, the
+ Jitter RNGd provides a source of sufficient entropy.
+
+Package: usign
+Version: 2020-05-23-f1f65026-1
+Depends: libc, libubox20201212
+Source: package/system/usign
+SourceName: usign
+License: ISC
+Section: base
+SourceDateEpoch: 1590233892
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 11173
+Filename: usign_2020-05-23-f1f65026-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11950
+SHA256sum: 7180b7798ce6dabcf2e06ab93dff38e3520b919da03b1029aed61de829c1fe89
+Description:  OpenWrt signature verification utility
+
+Package: wireguard-tools
+Version: 1.0.20200827-2
+Depends: libc
+Source: package/network/utils/wireguard-tools
+SourceName: wireguard-tools
+License: GPL-2.0
+LicenseFiles: COPYING
+Section: net
+SourceDateEpoch: 1605614596
+Maintainer: Jason A. Donenfeld <Jason@zx2c4.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 26139
+Filename: wireguard-tools_1.0.20200827-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 27245
+SHA256sum: d5ee117d7c265c9886c862bf6c2cbc20d68b56fc1815a568cbcaea1445b8ff72
+Description:  WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes
+ state-of-the-art cryptography. It aims to be faster, simpler, leaner, and
+ more useful than IPSec, while avoiding the massive headache. It intends to
+ be considerably more performant than OpenVPN.  WireGuard is designed as a
+ general purpose VPN for running on embedded interfaces and super computers
+ alike, fit for many different circumstances. It uses UDP.
+ 
+ This package provides the userspace control program for WireGuard,
+ `wg(8)`, a netifd protocol helper, and a re-resolve watchdog script.
+
+Package: wireless-regdb
+Version: 2020.11.20-1
+Depends: libc
+Source: package/firmware/wireless-regdb
+SourceName: wireless-regdb
+Section: firmware
+SourceDateEpoch: 1608153079
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: all
+Installed-Size: 1929
+Filename: wireless-regdb_2020.11.20-1_all.ipk
+Size: 2672
+SHA256sum: 16f8847ae8a3b482c664f250bd91bda582defb7b2fd3f990b7ea370ecb55f2c1
+Description:  Wireless Regulatory Database
+
+Package: wpad-basic-wolfssl
+Version: 2020-06-08-5a8b3662-32
+Depends: libc, libnl-tiny1, hostapd-common, libubus20210215, libwolfssl4.7.0.66253b90
+Conflicts: hostapd, hostapd-basic, hostapd-basic-openssl, hostapd-basic-wolfssl, hostapd-mini, hostapd-openssl, hostapd-wolfssl, wpad, wpad-mesh-openssl, wpad-mesh-wolfssl, wpad-basic, wpad-basic-openssl, wpad, wpad-mesh-openssl, wpad-mesh-wolfssl, wpad-basic, wpad-basic-openssl
+Provides: hostapd, wpa-supplicant
+Source: package/network/services/hostapd
+SourceName: wpad-basic-wolfssl
+License: BSD-3-Clause
+Section: net
+Require-User: network=101:network=101
+SourceDateEpoch: 1615144626
+CPE-ID: cpe:/a:w1.fi:hostapd
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 347536
+Filename: wpad-basic-wolfssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
+Size: 347854
+SHA256sum: 15e4f18239bba0aab521ce996be2cd390620009b6f7844dabeca4c5ca2a3d6b6
+Description:  This package contains a basic IEEE 802.1x/WPA Authenticator and Supplicant with WPA-PSK, SAE (WPA3-Personal), 802.11r and 802.11w support.
+
+Package: wpad-openssl
+Version: 2020-06-08-5a8b3662-32
+Depends: libc, libnl-tiny1, hostapd-common, libubus20210215, libopenssl1.1
+Conflicts: hostapd, hostapd-basic, hostapd-basic-openssl, hostapd-basic-wolfssl, hostapd-mini, hostapd-openssl, hostapd-wolfssl, wpad, wpad-mesh-openssl, wpad-mesh-wolfssl, wpad-basic, wpad-basic-openssl, wpad-basic-wolfssl, wpad-mini, wpad, wpad-mesh-openssl, wpad-mesh-wolfssl, wpad-basic, wpad-basic-openssl, wpad-basic-wolfssl, wpad-mini
+Provides: hostapd, wpa-supplicant
+Source: package/network/services/hostapd
+SourceName: wpad-openssl
+License: BSD-3-Clause
+Section: net
+Require-User: network=101:network=101
+SourceDateEpoch: 1615144626
+CPE-ID: cpe:/a:w1.fi:hostapd
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 567646
+Filename: wpad-openssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
+Size: 567020
+SHA256sum: f697d4eb6c8416152e8e86ebd67b88ff983ef0f1e64f553135298d0df6918732
+Description:  This package contains a full featured IEEE 802.1x/WPA/EAP/RADIUS
+ Authenticator and Supplicant
+
+Package: zlib
+Version: 1.2.11-3
+Depends: libc
+Source: package/libs/zlib
+SourceName: zlib
+License: Zlib
+LicenseFiles: README
+Section: libs
+SourceDateEpoch: 1614260500
+CPE-ID: cpe:/a:gnu:zlib
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 41028
+Filename: zlib_1.2.11-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 41860
+SHA256sum: 15f38e5d41ea018ba60034fbcd433e6fd07e7389a4c7761a9bad1d36236fa33a
+Description:  zlib is a lossless data-compression library.
+ This package includes the shared library.
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.sig b/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.sig
new file mode 100644
index 0000000000..a019f6e90f
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/base/Packages.sig
@@ -0,0 +1,2 @@
+untrusted comment: signed by key d1f1809848731cb7
+RWTR8YCYSHMct9uTvo0WEA0FWDvGGjwMWLwvSFC81fN+z64NIV1vVSuReVIL5sPigdF6iCvc1twSwQ77a5BhdW96r+yBuqx8XQU=
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca988x_20201118-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca988x_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d0c5fb68d4
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca988x_20201118-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca9984_20201118-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca9984_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..97cf2bab62
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca9984_20201118-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca99x0_20201118-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca99x0_20201118-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..22f16e1fa8
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-board-qca99x0_20201118-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca988x-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca988x-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..db14acadc0
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca988x-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca9984-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca9984-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..6c0eec4bcf
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca9984-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca99x0-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca99x0-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..5cb3e51d5e
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ath10k-firmware-qca99x0-ct_2020-11-08-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/busybox_1.33.0-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/busybox_1.33.0-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0eb27131e1
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/busybox_1.33.0-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ca-bundle_20210119-1_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ca-bundle_20210119-1_all.ipk
new file mode 100644
index 0000000000..377094b84b
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ca-bundle_20210119-1_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ca-certificates_20210119-1_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ca-certificates_20210119-1_all.ipk
new file mode 100644
index 0000000000..ff057210bf
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ca-certificates_20210119-1_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/dnsmasq_2.84-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/dnsmasq_2.84-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c8d6ef65f7
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/dnsmasq_2.84-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/e2fsprogs_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/e2fsprogs_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..cd954a6920
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/e2fsprogs_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/firewall_2020-09-05-8c2f9fad-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/firewall_2020-09-05-8c2f9fad-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..fbf47747b7
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/firewall_2020-09-05-8c2f9fad-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/getrandom_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/getrandom_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..4f6e5c464a
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/getrandom_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/hostapd-common_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/hostapd-common_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..e75f30491e
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/hostapd-common_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/hostapd-utils_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/hostapd-utils_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..89c870be70
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/hostapd-utils_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ip-tiny_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ip-tiny_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2f31bda2f8
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ip-tiny_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ipset_7.6-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ipset_7.6-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..a917839515
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ipset_7.6-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/iw_5.9-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/iw_5.9-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..b353263f01
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/iw_5.9-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/jshn_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/jshn_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8578520a75
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/jshn_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/jsonfilter_2018-02-04-c7e938d6-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/jsonfilter_2018-02-04-c7e938d6-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..57eb20d8e9
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/jsonfilter_2018-02-04-c7e938d6-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libblkid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libblkid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..52d21442ac
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libblkid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libblobmsg-json20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libblobmsg-json20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..e93375a59f
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libblobmsg-json20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libcomerr0_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libcomerr0_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d4d1b9a485
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libcomerr0_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libelf1_0.180-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libelf1_0.180-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..622fd525ef
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libelf1_0.180-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libext2fs2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libext2fs2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1a2faa85ae
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libext2fs2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libipset13_7.6-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libipset13_7.6-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d711223579
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libipset13_7.6-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libjson-c5_0.15-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libjson-c5_0.15-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2268c9f430
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libjson-c5_0.15-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libjson-script20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libjson-script20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..4d27eb2da9
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libjson-script20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libltdl7_2.4.6-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libltdl7_2.4.6-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d904435104
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libltdl7_2.4.6-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/liblua5.1.5_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/liblua5.1.5_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8e508592f4
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/liblua5.1.5_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libmnl0_1.0.4-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libmnl0_1.0.4-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8ba9461b0b
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libmnl0_1.0.4-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libncurses6_6.2-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libncurses6_6.2-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c9baf35a78
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libncurses6_6.2-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libnl-tiny1_2020-08-05-c291088f-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libnl-tiny1_2020-08-05-c291088f-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..a58ea1a427
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libnl-tiny1_2020-08-05-c291088f-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl-conf_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl-conf_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..ddd04c6c91
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl-conf_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl-devcrypto_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl-devcrypto_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..bdc7fcfa19
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl-devcrypto_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl1.1_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl1.1_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..5c81fc1287
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libopenssl1.1_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libsmartcols1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libsmartcols1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..602ab04b04
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libsmartcols1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libss2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libss2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..826e11f3d4
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libss2_1.45.6-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubox20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubox20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9ed2d54045
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubox20201212_2020-12-12-35787769-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubus-lua_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubus-lua_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..a1045dbea6
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubus-lua_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubus20210215_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubus20210215_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..ecc795af69
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libubus20210215_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuci20130104_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuci20130104_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d535ad8966
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuci20130104_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuclient20201210_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuclient20201210_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d729870cb8
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuclient20201210_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libustream-openssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libustream-openssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..5facc1813a
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libustream-openssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libustream-wolfssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libustream-wolfssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..de14f5263d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libustream-wolfssl20201210_2020-12-10-68d09243-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuuid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuuid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..e90671f8e7
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libuuid1_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/libwolfssl4.7.0.66253b90_4.7.0-stable-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libwolfssl4.7.0.66253b90_4.7.0-stable-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2171732208
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/libwolfssl4.7.0.66253b90_4.7.0-stable-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/logd_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/logd_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0a3a263eb9
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/logd_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/losetup_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/losetup_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d207ea76da
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/losetup_2.36.1-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/lua_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/lua_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..410bf4f2b9
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/lua_5.1.5-8_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/netifd_2021-01-09-c00c8335-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/netifd_2021-01-09-c00c8335-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..3b685496a7
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/netifd_2021-01-09-c00c8335-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/odhcp6c_2021-01-09-53f07e90-16_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/odhcp6c_2021-01-09-53f07e90-16_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0d16bbf524
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/odhcp6c_2021-01-09-53f07e90-16_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/odhcpd-ipv6only_2021-01-06-8d8a8cd3-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/odhcpd-ipv6only_2021-01-06-8d8a8cd3-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9833ab492d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/odhcpd-ipv6only_2021-01-06-8d8a8cd3-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/openssl-util_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/openssl-util_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..73930152c6
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/openssl-util_1.1.1j-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/openwrt-keyring_2021-02-20-49283916-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/openwrt-keyring_2021-02-20-49283916-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..bbb2af4a9d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/openwrt-keyring_2021-02-20-49283916-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/opkg_2020-12-24-9bbc7eae-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/opkg_2020-12-24-9bbc7eae-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..cbb728032b
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/opkg_2020-12-24-9bbc7eae-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ppp-mod-pppoe_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ppp-mod-pppoe_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..802a9193c6
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ppp-mod-pppoe_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ppp_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ppp_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8f17199cb6
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ppp_2.4.8.git-2020-10-03-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/procd_2021-02-08-08938fe1-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/procd_2021-02-08-08938fe1-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..793bc2ea0d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/procd_2021-02-08-08938fe1-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd-mod-file_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd-mod-file_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1bb1608b94
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd-mod-file_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd-mod-iwinfo_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd-mod-iwinfo_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..826956f168
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd-mod-iwinfo_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..ff15f33e8c
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/rpcd_2021-01-06-ea7f4717-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/swconfig_12_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/swconfig_12_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9920fd4687
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/swconfig_12_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/tc_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/tc_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..338e85a82e
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/tc_5.10.0-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/terminfo_6.2-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/terminfo_6.2-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..227053571a
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/terminfo_6.2-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubox_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubox_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..54a83e6d8e
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubox_2020-10-25-9ef88681-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubus_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubus_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..75c93e52f8
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubus_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubusd_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubusd_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..143a93d434
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/ubusd_2021-02-15-2537be01-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/uci_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/uci_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..6f374788fc
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/uci_2020-10-06-52bbc99f-4_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/uclient-fetch_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/uclient-fetch_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1dd494533e
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/uclient-fetch_2020-12-10-2c843b2b-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/uhttpd-mod-ubus_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/uhttpd-mod-ubus_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..74b628cd04
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/uhttpd-mod-ubus_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/uhttpd_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/uhttpd_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..15251c61ce
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/uhttpd_2020-11-23-f53a6399-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/umdns_2021-01-26-78aa36b0-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/umdns_2021-01-26-78aa36b0-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..07fd9fed33
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/umdns_2021-01-26-78aa36b0-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/urandom-seed_3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/urandom-seed_3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..47a2ec23f1
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/urandom-seed_3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/urngd_2020-01-21-c7f7b6b6-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/urngd_2020-01-21-c7f7b6b6-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..7bd32319b7
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/urngd_2020-01-21-c7f7b6b6-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/usign_2020-05-23-f1f65026-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/usign_2020-05-23-f1f65026-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..e3355a1823
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/usign_2020-05-23-f1f65026-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/wireguard-tools_1.0.20200827-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/wireguard-tools_1.0.20200827-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..46494f2d58
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/wireguard-tools_1.0.20200827-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/wireless-regdb_2020.11.20-1_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/wireless-regdb_2020.11.20-1_all.ipk
new file mode 100644
index 0000000000..8f32cdd655
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/wireless-regdb_2020.11.20-1_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/wpad-basic-wolfssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/wpad-basic-wolfssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..b27b8e7103
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/wpad-basic-wolfssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/wpad-openssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/wpad-openssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c611ee2ef1
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/wpad-openssl_2020-06-08-5a8b3662-32_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/base/zlib_1.2.11-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/base/zlib_1.2.11-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..111f7bf7ad
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/base/zlib_1.2.11-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages b/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages
@@ -0,0 +1 @@
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.gz b/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.gz
new file mode 100644
index 0000000000..d73d33af08
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.gz differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.manifest b/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.manifest
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.manifest
@@ -0,0 +1 @@
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.sig b/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.sig
new file mode 100644
index 0000000000..da56f4b2dc
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/freifunk/Packages.sig
@@ -0,0 +1,2 @@
+untrusted comment: signed by key d1f1809848731cb7
+RWTR8YCYSHMct3zHf2lu2WJnUYMYVc8Pgyuy1Mg2hY9jRHPStXQBpzzQvQnMNqWOIV/CQPZhfDZFVDM0osL29qhppcjgbYjlQAs=
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages
new file mode 100644
index 0000000000..a2f880494d
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages
@@ -0,0 +1,420 @@
+Package: liblucihttp-lua
+Version: 2019-07-05-a34a17d5-1
+Depends: libc, liblucihttp0, liblua5.1.5
+License: ISC
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3119
+Filename: liblucihttp-lua_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3907
+SHA256sum: e55907f9d6d49c8ed8fc94015f368d728df47125913c76334fe88762eafe68a9
+Description:  Lua binding for the LuCI HTTP utility library
+
+Package: liblucihttp0
+Version: 2019-07-05-a34a17d5-1
+Depends: libc
+Provides: liblucihttp
+License: ISC
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6757
+Filename: liblucihttp0_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7580
+SHA256sum: 1a42f3842e74fbad160fa520cf829e2c4d5bbddaf013efc93127b10c3d472848
+Description:  LuCI HTTP utility library
+
+Package: luci-app-adblock
+Version: git-21.058.23678-d551587
+Depends: libc, adblock, luci-lib-jsonc
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 9194
+Filename: luci-app-adblock_git-21.058.23678-d551587_all.ipk
+Size: 10045
+SHA256sum: 63850396b7f475ea48bcb2a9530e1f0b13be391ef1065f67ab6c3b363cedfa7f
+Description:  LuCI support for Adblock
+
+Package: luci-app-banip
+Version: git-21.062.56276-2e1f950
+Depends: libc, banip, luci-lib-jsonc
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 8886
+Filename: luci-app-banip_git-21.062.56276-2e1f950_all.ipk
+Size: 9754
+SHA256sum: 6fddfd74dc0d4b0f60d106acb9492543f25538dc05b30e17789b84aba84d0895
+Description:  LuCI support for banIP
+
+Package: luci-app-bcp38
+Version: git-21.058.23678-d551587
+Depends: libc, luci-compat, luci-mod-admin-full, bcp38
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 1729
+Filename: luci-app-bcp38_git-21.058.23678-d551587_all.ipk
+Size: 2615
+SHA256sum: fcbf39f3fc87377c78d41194ea88096359a9c827bcc74e38129509b17fdd6199
+Description:  BCP38 LuCI interface
+
+Package: luci-app-commands
+Version: git-21.058.23678-d551587
+Depends: libc, luci-compat
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 5074
+Filename: luci-app-commands_git-21.058.23678-d551587_all.ipk
+Size: 5897
+SHA256sum: 1336a46211e415ccb8dc69b0603b2fb7b8407130d4103fc9dec9c4545a60cbf7
+Description:  LuCI Shell Command Module
+
+Package: luci-app-dawn
+Version: git-21.058.23678-d551587
+Depends: libc, dawn, luci-compat, luci-lib-json
+Section: luci
+Architecture: all
+Installed-Size: 2750
+Filename: luci-app-dawn_git-21.058.23678-d551587_all.ipk
+Size: 3567
+SHA256sum: c797e17ce2f801455c090849e73441c1584938d8eef5157ae92a85fb949ede95
+Description:  LuCI support for DAWN
+
+Package: luci-app-ddns
+Version: git-21.058.23678-d551587
+Depends: libc, luci-lib-ipkg, luci-mod-admin-full, ddns-scripts
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 12441
+Filename: luci-app-ddns_git-21.058.23678-d551587_all.ipk
+Size: 13395
+SHA256sum: 6f17c26d03e4ab879ca6b5584f0b7eb196bdbfe9aa30f6c97594fc56d8586d1f
+Description:  LuCI Support for Dynamic DNS Client (ddns-scripts)
+
+Package: luci-app-firewall
+Version: git-21.060.51546-4935525
+Depends: libc, firewall
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 14142
+Filename: luci-app-firewall_git-21.060.51546-4935525_all.ipk
+Size: 14972
+SHA256sum: 7c105db16bb3e8339c74f9d80c6e3215afc742dc46a61751fe7c071164658048
+Description:  Firewall and Portforwarding application
+
+Package: luci-app-nlbwmon
+Version: git-21.060.34261-628a1b8
+Depends: libc, luci-compat, nlbwmon
+Section: luci
+Architecture: all
+Installed-Size: 20837
+Filename: luci-app-nlbwmon_git-21.060.34261-628a1b8_all.ipk
+Size: 21663
+SHA256sum: 2c67feeb17be799daf71c83ac5e0c95a7ef61e47a6229878e3d6444c0f18772b
+Description:  Netlink based bandwidth accounting
+
+Package: luci-app-openvpn
+Version: git-21.058.23678-d551587
+Depends: libc, luci-compat
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 11800
+Filename: luci-app-openvpn_git-21.058.23678-d551587_all.ipk
+Size: 12666
+SHA256sum: a24086e115a3a6a2e85a7d83c5e20c057001e747de081c9643c2b1e1fc6833a5
+Description:  LuCI Support for OpenVPN
+
+Package: luci-app-opkg
+Version: git-21.058.23678-d551587
+Depends: libc, opkg
+Section: luci
+Architecture: all
+Installed-Size: 8426
+Filename: luci-app-opkg_git-21.058.23678-d551587_all.ipk
+Size: 9278
+SHA256sum: 07b21e973a466a9eacaacdb691412142c1a952758e1743af2ae7cc6276a99bda
+Description:  OPKG package management application
+
+Package: luci-app-sqm
+Version: git-21.058.23678-d551587
+Depends: libc, sqm-scripts
+Section: luci
+Architecture: all
+Installed-Size: 3214
+Filename: luci-app-sqm_git-21.058.23678-d551587_all.ipk
+Size: 4150
+SHA256sum: 5df2c5e4adfe5e42062abaf394a365564cc11d9dd50f9c089e2cd7efc14081a2
+Description:  Luci interface for the SQM scripts queue management package
+
+Package: luci-app-statistics
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base, luci-lib-jsonc, collectd, rrdtool1, collectd-mod-rrdtool, collectd-mod-iwinfo, collectd-mod-cpu, collectd-mod-memory, collectd-mod-interface, collectd-mod-load, collectd-mod-network
+Section: luci
+Architecture: all
+Installed-Size: 30975
+Filename: luci-app-statistics_git-21.058.23678-d551587_all.ipk
+Size: 31902
+SHA256sum: c6a4c7e8b77dc7a7df5f7f6cc5d5dea4a3c0da906da84e155abb4de7cd2b004b
+Description:  LuCI Statistics Application
+
+Package: luci-app-wireguard
+Version: git-21.058.23678-d551587
+Depends: libc, wireguard-tools, kmod-wireguard, luci-proto-wireguard
+Section: luci
+Architecture: all
+Installed-Size: 3453
+Filename: luci-app-wireguard_git-21.058.23678-d551587_all.ipk
+Size: 4298
+SHA256sum: d9caac82eaa02a716355781a9b3af20f720c77728cb67f9bb1f62bfca05c186a
+Description:  WireGuard Status
+
+Package: luci-base
+Version: git-21.060.51546-bd39e6a
+Depends: libc, lua, luci-lib-nixio, luci-lib-ip, rpcd, libubus-lua, luci-lib-jsonc, liblucihttp-lua, luci-lib-base, rpcd-mod-file, rpcd-mod-luci, cgi-io
+License: MIT
+Section: luci
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 127685
+Filename: luci-base_git-21.060.51546-bd39e6a_arm_cortex-a15_neon-vfpv4.ipk
+Size: 128736
+SHA256sum: 8980194bb9a4750f6853fc7465e5421de1d8668a9068e87282e63573c71d6c17
+Description:  LuCI core libraries
+
+Package: luci-compat
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base
+Section: luci
+Architecture: all
+Installed-Size: 45364
+Filename: luci-compat_git-21.058.23678-d551587_all.ipk
+Size: 46182
+SHA256sum: 9f1f025c9969ec8a47880e01bee0d751dc28085a067155d2b7d17dbfe98f7167
+Description:  LuCI compatibility libraries
+
+Package: luci-lib-base
+Version: git-21.058.23678-d551587
+Depends: libc, lua, luci-lib-nixio, luci-lib-ip, luci-lib-jsonc, liblucihttp-lua
+Section: luci
+Architecture: all
+Installed-Size: 12497
+Filename: luci-lib-base_git-21.058.23678-d551587_all.ipk
+Size: 13335
+SHA256sum: 845d09fdadfd2cd058ae16006c821adcfc6bc16f2fe406ca87e3a12bf8afed09
+Description:  basic libraries for luci
+
+Package: luci-lib-ip
+Version: git-21.058.23678-d551587
+Depends: libc, liblua5.1.5, libnl-tiny1
+License: Apache-2.0
+Section: luci
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10388
+Filename: luci-lib-ip_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11228
+SHA256sum: 9776aaabaf025618ae5e0d37fcc256b66ed2fd773c9765be8282f7a573306399
+Description:  Lua library for IP calculation and routing information
+
+Package: luci-lib-ipkg
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base
+Section: luci
+Architecture: all
+Installed-Size: 2078
+Filename: luci-lib-ipkg_git-21.058.23678-d551587_all.ipk
+Size: 2909
+SHA256sum: 9a3f68f6579f2d53a53b0ea18730cc42ae3023f20710731f558c4d7a0cc8c999
+Description:  Legacy opkg interface class
+
+Package: luci-lib-json
+Version: git-21.058.23678-d551587
+Depends: libc
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 3138
+Filename: luci-lib-json_git-21.058.23678-d551587_all.ipk
+Size: 3959
+SHA256sum: 95d25fcf8ab6123d3a7d8ff6e2c02cd60beea5367e7776f4b249ede91f4d3535
+Description:  LuCI JSON library
+
+Package: luci-lib-jsonc
+Version: git-21.058.23678-d551587
+Depends: libc, liblua5.1.5, libjson-c5
+Section: luci
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3681
+Filename: luci-lib-jsonc_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4503
+SHA256sum: 01fb8e3aa4a871de76bc4021214d4954f75669c988f6bf7b66ac2041df5d9c04
+Description:  Lua binding for JSON-C
+
+Package: luci-lib-nixio
+Version: git-21.058.23678-d551587
+Depends: libc, liblua5.1.5
+License: Apache-2.0
+Section: luci
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 28961
+Filename: luci-lib-nixio_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
+Size: 29529
+SHA256sum: 9d0155635604932241b808d351f040c516c375599ca89816ac9230a29da3f29a
+Description:  NIXIO POSIX library
+
+Package: luci-mod-admin-full
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base, luci-mod-status, luci-mod-system, luci-mod-network
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 106
+Filename: luci-mod-admin-full_git-21.058.23678-d551587_all.ipk
+Size: 966
+SHA256sum: c8fb1e842cadc8871aa94b53b947a5a66e45434db538c5d0a1954744d15c8991
+Description:  LuCI Administration - full-featured for full control
+
+Package: luci-mod-network
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base, libiwinfo-lua, rpcd-mod-iwinfo
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 33875
+Filename: luci-mod-network_git-21.058.23678-d551587_all.ipk
+Size: 34862
+SHA256sum: da6bae8394f06a3a794634551643aeac2223cad03a71d1808e265d91856b8f49
+Description:  LuCI Network Administration
+
+Package: luci-mod-status
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base, libiwinfo20210106, libiwinfo-lua
+License: Apache-2.0
+Section: luci
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 28292
+Filename: luci-mod-status_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
+Size: 29151
+SHA256sum: 02c6d307e5e6119a4e89c3e114292c902257733a2367033c8c25c11c1df40c0c
+Description:  LuCI Status Pages
+
+Package: luci-mod-system
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 17470
+Filename: luci-mod-system_git-21.058.23678-d551587_all.ipk
+Size: 18342
+SHA256sum: 72b0efb6b1c90e5ff8a22423ca2137bf2e8cc3375e7feefd9a85f1f85b717424
+Description:  LuCI Administration - Global System Settings
+
+Package: luci-proto-ipv6
+Version: git-21.058.23678-d551587
+Depends: libc
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 2910
+Filename: luci-proto-ipv6_git-21.058.23678-d551587_all.ipk
+Size: 3746
+SHA256sum: abff73c2485ccc303994945bce1e9ca66b6c6d025a71eecf0a7339d1568f527a
+Description:  Support for DHCPv6/6in4/6to4/6rd/DS-Lite
+
+Package: luci-proto-ppp
+Version: git-21.058.23678-d551587
+Depends: libc
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 2368
+Filename: luci-proto-ppp_git-21.058.23678-d551587_all.ipk
+Size: 3179
+SHA256sum: 12fdf7a6fe466d35365d11230888cb5de5e320e395c8162acb1d7e807f764089
+Description:  Support for PPP/PPPoE/PPPoA/PPtP
+
+Package: luci-proto-wireguard
+Version: git-21.058.23678-d551587
+Depends: libc, kmod-wireguard, wireguard-tools
+Section: luci
+Architecture: all
+Installed-Size: 2628
+Filename: luci-proto-wireguard_git-21.058.23678-d551587_all.ipk
+Size: 3464
+SHA256sum: 4f1b2282021da328f44f62df47c8404388ebb00bd7dec187edc20250221d1c14
+Description:  Support for WireGuard VPN
+
+Package: luci-ssl-openssl
+Version: git-21.058.23678-d551587
+Depends: libc, luci, libustream-openssl20201210, openssl-util
+Section: luci
+Architecture: all
+Installed-Size: 106
+Filename: luci-ssl-openssl_git-21.058.23678-d551587_all.ipk
+Size: 1045
+SHA256sum: 5a0a4fc3ede96b1aff1632ac409c248fb0cbf9c022b902ff9dd0501943ae9673
+Description:  LuCI with OpenSSL as the SSL backend (libustream-openssl). OpenSSL cmd tools (openssl-util) are used by uhttpd for SSL key generation instead of the default px5g. (If px5g is installed, uhttpd will prefer that.)
+
+Package: luci-theme-bootstrap
+Version: git-21.058.23678-d551587
+Depends: libc
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 13159
+Filename: luci-theme-bootstrap_git-21.058.23678-d551587_all.ipk
+Size: 14026
+SHA256sum: 914c5fa2f97dde1bbb1354609be4894e0c542b2bb54fa0044750d05f2faf6759
+Description:  Bootstrap Theme (default)
+
+Package: luci-theme-openwrt-2020
+Version: git-21.058.23678-d551587
+Depends: libc
+Section: luci
+Architecture: all
+Installed-Size: 43080
+Filename: luci-theme-openwrt-2020_git-21.058.23678-d551587_all.ipk
+Size: 44029
+SHA256sum: 2e6f2c060472829a2520cff45fb7b9131c7339b0a9fcc2fd70cc2be488a9741a
+Description:  LuCI modern OpenWrt theme
+
+Package: luci
+Version: git-21.058.23678-d551587
+Depends: libc, uhttpd, uhttpd-mod-ubus, luci-mod-admin-full, luci-theme-bootstrap, luci-app-firewall, luci-app-opkg, luci-proto-ppp, libiwinfo-lua, luci-proto-ipv6, rpcd-mod-rrdns
+License: Apache-2.0
+Section: luci
+Architecture: all
+Installed-Size: 106
+Filename: luci_git-21.058.23678-d551587_all.ipk
+Size: 1044
+SHA256sum: ba00307612506c77350fe2641e97c03fc07851189128e0196228adc737a22a3e
+Description:  Standard OpenWrt set including full admin with ppp support and the default Bootstrap theme
+
+Package: rpcd-mod-luci
+Version: 20201107
+Depends: libc, rpcd, libubox20201212, libubus20210215, libnl-tiny1
+License: Apache-2.0
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 11819
+Filename: rpcd-mod-luci_20201107_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12683
+SHA256sum: 90153aefe86b6339edb2ba7aaa36681581f032d2c41383c6477b72392e5891f3
+Description:  Provides LuCI backend ubus RPC operations.
+
+Package: rpcd-mod-rrdns
+Version: 20170710
+Depends: libc, rpcd, libubox20201212, libubus20210215
+License: Apache-2.0
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3461
+Filename: rpcd-mod-rrdns_20170710_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4297
+SHA256sum: 23e03af9590ade95199e2fcab3d20a34d1283bed9d245a938264533d2570ec29
+Description:  Provides rapid mass reverse DNS lookup functionality.
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.gz b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.gz
new file mode 100644
index 0000000000..024e5c50a3
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.gz differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.manifest b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.manifest
new file mode 100644
index 0000000000..87b4a4f268
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.manifest
@@ -0,0 +1,537 @@
+Package: liblucihttp-lua
+Version: 2019-07-05-a34a17d5-1
+Depends: libc, liblucihttp0, liblua5.1.5
+Source: feeds/luci/contrib/package/lucihttp
+SourceName: liblucihttp-lua
+License: ISC
+LicenseFiles: LICENSE
+Section: libs
+SourceDateEpoch: 1614407678
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3119
+Filename: liblucihttp-lua_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3907
+SHA256sum: e55907f9d6d49c8ed8fc94015f368d728df47125913c76334fe88762eafe68a9
+Description:  Lua binding for the LuCI HTTP utility library
+
+Package: liblucihttp0
+Version: 2019-07-05-a34a17d5-1
+Depends: libc
+Provides: liblucihttp
+Source: feeds/luci/contrib/package/lucihttp
+SourceName: liblucihttp
+License: ISC
+LicenseFiles: LICENSE
+Section: libs
+SourceDateEpoch: 1614407678
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6757
+Filename: liblucihttp0_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7580
+SHA256sum: 1a42f3842e74fbad160fa520cf829e2c4d5bbddaf013efc93127b10c3d472848
+Description:  LuCI HTTP utility library
+
+Package: luci-app-adblock
+Version: git-21.058.23678-d551587
+Depends: libc, adblock, luci-lib-jsonc
+Source: feeds/luci/applications/luci-app-adblock
+SourceName: luci-app-adblock
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 9194
+Filename: luci-app-adblock_git-21.058.23678-d551587_all.ipk
+Size: 10045
+SHA256sum: 63850396b7f475ea48bcb2a9530e1f0b13be391ef1065f67ab6c3b363cedfa7f
+Description:  LuCI support for Adblock
+
+Package: luci-app-banip
+Version: git-21.062.56276-2e1f950
+Depends: libc, banip, luci-lib-jsonc
+Source: feeds/luci/applications/luci-app-banip
+SourceName: luci-app-banip
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614785876
+Architecture: all
+Installed-Size: 8886
+Filename: luci-app-banip_git-21.062.56276-2e1f950_all.ipk
+Size: 9754
+SHA256sum: 6fddfd74dc0d4b0f60d106acb9492543f25538dc05b30e17789b84aba84d0895
+Description:  LuCI support for banIP
+
+Package: luci-app-bcp38
+Version: git-21.058.23678-d551587
+Depends: libc, luci-compat, luci-mod-admin-full, bcp38
+Source: feeds/luci/applications/luci-app-bcp38
+SourceName: luci-app-bcp38
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Maintainer: Toke Høiland-Jørgensen <toke@toke.dk>
+Architecture: all
+Installed-Size: 1729
+Filename: luci-app-bcp38_git-21.058.23678-d551587_all.ipk
+Size: 2615
+SHA256sum: fcbf39f3fc87377c78d41194ea88096359a9c827bcc74e38129509b17fdd6199
+Description:  BCP38 LuCI interface
+
+Package: luci-app-commands
+Version: git-21.058.23678-d551587
+Depends: libc, luci-compat
+Source: feeds/luci/applications/luci-app-commands
+SourceName: luci-app-commands
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 5074
+Filename: luci-app-commands_git-21.058.23678-d551587_all.ipk
+Size: 5897
+SHA256sum: 1336a46211e415ccb8dc69b0603b2fb7b8407130d4103fc9dec9c4545a60cbf7
+Description:  LuCI Shell Command Module
+
+Package: luci-app-dawn
+Version: git-21.058.23678-d551587
+Depends: libc, dawn, luci-compat, luci-lib-json
+Source: feeds/luci/applications/luci-app-dawn
+SourceName: luci-app-dawn
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 2750
+Filename: luci-app-dawn_git-21.058.23678-d551587_all.ipk
+Size: 3567
+SHA256sum: c797e17ce2f801455c090849e73441c1584938d8eef5157ae92a85fb949ede95
+Description:  LuCI support for DAWN
+
+Package: luci-app-ddns
+Version: git-21.058.23678-d551587
+Depends: libc, luci-lib-ipkg, luci-mod-admin-full, ddns-scripts
+Source: feeds/luci/applications/luci-app-ddns
+SourceName: luci-app-ddns
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Maintainer: Ansuel Smith <ansuelsmth@gmail.com>
+Architecture: all
+Installed-Size: 12441
+Filename: luci-app-ddns_git-21.058.23678-d551587_all.ipk
+Size: 13395
+SHA256sum: 6f17c26d03e4ab879ca6b5584f0b7eb196bdbfe9aa30f6c97594fc56d8586d1f
+Description:  LuCI Support for Dynamic DNS Client (ddns-scripts)
+
+Package: luci-app-firewall
+Version: git-21.060.51546-4935525
+Depends: libc, firewall
+Source: feeds/luci/applications/luci-app-firewall
+SourceName: luci-app-firewall
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614608346
+Architecture: all
+Installed-Size: 14142
+Filename: luci-app-firewall_git-21.060.51546-4935525_all.ipk
+Size: 14972
+SHA256sum: 7c105db16bb3e8339c74f9d80c6e3215afc742dc46a61751fe7c071164658048
+Description:  Firewall and Portforwarding application
+
+Package: luci-app-nlbwmon
+Version: git-21.060.34261-628a1b8
+Depends: libc, luci-compat, nlbwmon
+Source: feeds/luci/applications/luci-app-nlbwmon
+SourceName: luci-app-nlbwmon
+Section: luci
+SourceDateEpoch: 1614591061
+Architecture: all
+Installed-Size: 20837
+Filename: luci-app-nlbwmon_git-21.060.34261-628a1b8_all.ipk
+Size: 21663
+SHA256sum: 2c67feeb17be799daf71c83ac5e0c95a7ef61e47a6229878e3d6444c0f18772b
+Description:  Netlink based bandwidth accounting
+
+Package: luci-app-openvpn
+Version: git-21.058.23678-d551587
+Depends: libc, luci-compat
+Source: feeds/luci/applications/luci-app-openvpn
+SourceName: luci-app-openvpn
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 11800
+Filename: luci-app-openvpn_git-21.058.23678-d551587_all.ipk
+Size: 12666
+SHA256sum: a24086e115a3a6a2e85a7d83c5e20c057001e747de081c9643c2b1e1fc6833a5
+Description:  LuCI Support for OpenVPN
+
+Package: luci-app-opkg
+Version: git-21.058.23678-d551587
+Depends: libc, opkg
+Source: feeds/luci/applications/luci-app-opkg
+SourceName: luci-app-opkg
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 8426
+Filename: luci-app-opkg_git-21.058.23678-d551587_all.ipk
+Size: 9278
+SHA256sum: 07b21e973a466a9eacaacdb691412142c1a952758e1743af2ae7cc6276a99bda
+Description:  OPKG package management application
+
+Package: luci-app-sqm
+Version: git-21.058.23678-d551587
+Depends: libc, sqm-scripts
+Source: feeds/luci/applications/luci-app-sqm
+SourceName: luci-app-sqm
+Section: luci
+SourceDateEpoch: 1614407678
+Maintainer: Toke Høiland-Jørgensen <toke@toke.dk>
+Architecture: all
+Installed-Size: 3214
+Filename: luci-app-sqm_git-21.058.23678-d551587_all.ipk
+Size: 4150
+SHA256sum: 5df2c5e4adfe5e42062abaf394a365564cc11d9dd50f9c089e2cd7efc14081a2
+Description:  Luci interface for the SQM scripts queue management package
+
+Package: luci-app-statistics
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base, luci-lib-jsonc, collectd, rrdtool1, collectd-mod-rrdtool, collectd-mod-iwinfo, collectd-mod-cpu, collectd-mod-memory, collectd-mod-interface, collectd-mod-load, collectd-mod-network
+Source: feeds/luci/applications/luci-app-statistics
+SourceName: luci-app-statistics
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 30975
+Filename: luci-app-statistics_git-21.058.23678-d551587_all.ipk
+Size: 31902
+SHA256sum: c6a4c7e8b77dc7a7df5f7f6cc5d5dea4a3c0da906da84e155abb4de7cd2b004b
+Description:  LuCI Statistics Application
+
+Package: luci-app-wireguard
+Version: git-21.058.23678-d551587
+Depends: libc, wireguard-tools, kmod-wireguard, luci-proto-wireguard
+Source: feeds/luci/applications/luci-app-wireguard
+SourceName: luci-app-wireguard
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 3453
+Filename: luci-app-wireguard_git-21.058.23678-d551587_all.ipk
+Size: 4298
+SHA256sum: d9caac82eaa02a716355781a9b3af20f720c77728cb67f9bb1f62bfca05c186a
+Description:  WireGuard Status
+
+Package: luci-base
+Version: git-21.060.51546-bd39e6a
+Depends: libc, lua, luci-lib-nixio, luci-lib-ip, rpcd, libubus-lua, luci-lib-jsonc, liblucihttp-lua, luci-lib-base, rpcd-mod-file, rpcd-mod-luci, cgi-io
+Source: feeds/luci/modules/luci-base
+SourceName: luci-base
+License: MIT
+Section: luci
+SourceDateEpoch: 1614608346
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 127685
+Filename: luci-base_git-21.060.51546-bd39e6a_arm_cortex-a15_neon-vfpv4.ipk
+Size: 128736
+SHA256sum: 8980194bb9a4750f6853fc7465e5421de1d8668a9068e87282e63573c71d6c17
+Description:  LuCI core libraries
+
+Package: luci-compat
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base
+Source: feeds/luci/modules/luci-compat
+SourceName: luci-compat
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 45364
+Filename: luci-compat_git-21.058.23678-d551587_all.ipk
+Size: 46182
+SHA256sum: 9f1f025c9969ec8a47880e01bee0d751dc28085a067155d2b7d17dbfe98f7167
+Description:  LuCI compatibility libraries
+
+Package: luci-lib-base
+Version: git-21.058.23678-d551587
+Depends: libc, lua, luci-lib-nixio, luci-lib-ip, luci-lib-jsonc, liblucihttp-lua
+Source: feeds/luci/libs/luci-lib-base
+SourceName: luci-lib-base
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 12497
+Filename: luci-lib-base_git-21.058.23678-d551587_all.ipk
+Size: 13335
+SHA256sum: 845d09fdadfd2cd058ae16006c821adcfc6bc16f2fe406ca87e3a12bf8afed09
+Description:  basic libraries for luci
+
+Package: luci-lib-ip
+Version: git-21.058.23678-d551587
+Depends: libc, liblua5.1.5, libnl-tiny1
+Source: feeds/luci/libs/luci-lib-ip
+SourceName: luci-lib-ip
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10388
+Filename: luci-lib-ip_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11228
+SHA256sum: 9776aaabaf025618ae5e0d37fcc256b66ed2fd773c9765be8282f7a573306399
+Description:  Lua library for IP calculation and routing information
+
+Package: luci-lib-ipkg
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base
+Source: feeds/luci/libs/luci-lib-ipkg
+SourceName: luci-lib-ipkg
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 2078
+Filename: luci-lib-ipkg_git-21.058.23678-d551587_all.ipk
+Size: 2909
+SHA256sum: 9a3f68f6579f2d53a53b0ea18730cc42ae3023f20710731f558c4d7a0cc8c999
+Description:  Legacy opkg interface class
+
+Package: luci-lib-json
+Version: git-21.058.23678-d551587
+Depends: libc
+Source: feeds/luci/libs/luci-lib-json
+SourceName: luci-lib-json
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 3138
+Filename: luci-lib-json_git-21.058.23678-d551587_all.ipk
+Size: 3959
+SHA256sum: 95d25fcf8ab6123d3a7d8ff6e2c02cd60beea5367e7776f4b249ede91f4d3535
+Description:  LuCI JSON library
+
+Package: luci-lib-jsonc
+Version: git-21.058.23678-d551587
+Depends: libc, liblua5.1.5, libjson-c5
+Source: feeds/luci/libs/luci-lib-jsonc
+SourceName: luci-lib-jsonc
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3681
+Filename: luci-lib-jsonc_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4503
+SHA256sum: 01fb8e3aa4a871de76bc4021214d4954f75669c988f6bf7b66ac2041df5d9c04
+Description:  Lua binding for JSON-C
+
+Package: luci-lib-nixio
+Version: git-21.058.23678-d551587
+Depends: libc, liblua5.1.5
+Source: feeds/luci/libs/luci-lib-nixio
+SourceName: luci-lib-nixio
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 28961
+Filename: luci-lib-nixio_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
+Size: 29529
+SHA256sum: 9d0155635604932241b808d351f040c516c375599ca89816ac9230a29da3f29a
+Description:  NIXIO POSIX library
+
+Package: luci-mod-admin-full
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base, luci-mod-status, luci-mod-system, luci-mod-network
+Source: feeds/luci/modules/luci-mod-admin-full
+SourceName: luci-mod-admin-full
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 106
+Filename: luci-mod-admin-full_git-21.058.23678-d551587_all.ipk
+Size: 966
+SHA256sum: c8fb1e842cadc8871aa94b53b947a5a66e45434db538c5d0a1954744d15c8991
+Description:  LuCI Administration - full-featured for full control
+
+Package: luci-mod-network
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base, libiwinfo-lua, rpcd-mod-iwinfo
+Source: feeds/luci/modules/luci-mod-network
+SourceName: luci-mod-network
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 33875
+Filename: luci-mod-network_git-21.058.23678-d551587_all.ipk
+Size: 34862
+SHA256sum: da6bae8394f06a3a794634551643aeac2223cad03a71d1808e265d91856b8f49
+Description:  LuCI Network Administration
+
+Package: luci-mod-status
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base, libiwinfo20210106, libiwinfo-lua
+Source: feeds/luci/modules/luci-mod-status
+SourceName: luci-mod-status
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 28292
+Filename: luci-mod-status_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
+Size: 29151
+SHA256sum: 02c6d307e5e6119a4e89c3e114292c902257733a2367033c8c25c11c1df40c0c
+Description:  LuCI Status Pages
+
+Package: luci-mod-system
+Version: git-21.058.23678-d551587
+Depends: libc, luci-base
+Source: feeds/luci/modules/luci-mod-system
+SourceName: luci-mod-system
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 17470
+Filename: luci-mod-system_git-21.058.23678-d551587_all.ipk
+Size: 18342
+SHA256sum: 72b0efb6b1c90e5ff8a22423ca2137bf2e8cc3375e7feefd9a85f1f85b717424
+Description:  LuCI Administration - Global System Settings
+
+Package: luci-proto-ipv6
+Version: git-21.058.23678-d551587
+Depends: libc
+Source: feeds/luci/protocols/luci-proto-ipv6
+SourceName: luci-proto-ipv6
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 2910
+Filename: luci-proto-ipv6_git-21.058.23678-d551587_all.ipk
+Size: 3746
+SHA256sum: abff73c2485ccc303994945bce1e9ca66b6c6d025a71eecf0a7339d1568f527a
+Description:  Support for DHCPv6/6in4/6to4/6rd/DS-Lite
+
+Package: luci-proto-ppp
+Version: git-21.058.23678-d551587
+Depends: libc
+Source: feeds/luci/protocols/luci-proto-ppp
+SourceName: luci-proto-ppp
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 2368
+Filename: luci-proto-ppp_git-21.058.23678-d551587_all.ipk
+Size: 3179
+SHA256sum: 12fdf7a6fe466d35365d11230888cb5de5e320e395c8162acb1d7e807f764089
+Description:  Support for PPP/PPPoE/PPPoA/PPtP
+
+Package: luci-proto-wireguard
+Version: git-21.058.23678-d551587
+Depends: libc, kmod-wireguard, wireguard-tools
+Source: feeds/luci/protocols/luci-proto-wireguard
+SourceName: luci-proto-wireguard
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 2628
+Filename: luci-proto-wireguard_git-21.058.23678-d551587_all.ipk
+Size: 3464
+SHA256sum: 4f1b2282021da328f44f62df47c8404388ebb00bd7dec187edc20250221d1c14
+Description:  Support for WireGuard VPN
+
+Package: luci-ssl-openssl
+Version: git-21.058.23678-d551587
+Depends: libc, luci, libustream-openssl20201210, openssl-util
+Source: feeds/luci/collections/luci-ssl-openssl
+SourceName: luci-ssl-openssl
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 106
+Filename: luci-ssl-openssl_git-21.058.23678-d551587_all.ipk
+Size: 1045
+SHA256sum: 5a0a4fc3ede96b1aff1632ac409c248fb0cbf9c022b902ff9dd0501943ae9673
+Description:  LuCI with OpenSSL as the SSL backend (libustream-openssl). OpenSSL cmd tools (openssl-util) are used by uhttpd for SSL key generation instead of the default px5g. (If px5g is installed, uhttpd will prefer that.)
+
+Package: luci-theme-bootstrap
+Version: git-21.058.23678-d551587
+Depends: libc
+Source: feeds/luci/themes/luci-theme-bootstrap
+SourceName: luci-theme-bootstrap
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 13159
+Filename: luci-theme-bootstrap_git-21.058.23678-d551587_all.ipk
+Size: 14026
+SHA256sum: 914c5fa2f97dde1bbb1354609be4894e0c542b2bb54fa0044750d05f2faf6759
+Description:  Bootstrap Theme (default)
+
+Package: luci-theme-openwrt-2020
+Version: git-21.058.23678-d551587
+Depends: libc
+Source: feeds/luci/themes/luci-theme-openwrt-2020
+SourceName: luci-theme-openwrt-2020
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 43080
+Filename: luci-theme-openwrt-2020_git-21.058.23678-d551587_all.ipk
+Size: 44029
+SHA256sum: 2e6f2c060472829a2520cff45fb7b9131c7339b0a9fcc2fd70cc2be488a9741a
+Description:  LuCI modern OpenWrt theme
+
+Package: luci
+Version: git-21.058.23678-d551587
+Depends: libc, uhttpd, uhttpd-mod-ubus, luci-mod-admin-full, luci-theme-bootstrap, luci-app-firewall, luci-app-opkg, luci-proto-ppp, libiwinfo-lua, luci-proto-ipv6, rpcd-mod-rrdns
+Source: feeds/luci/collections/luci
+SourceName: luci
+License: Apache-2.0
+Section: luci
+SourceDateEpoch: 1614407678
+Architecture: all
+Installed-Size: 106
+Filename: luci_git-21.058.23678-d551587_all.ipk
+Size: 1044
+SHA256sum: ba00307612506c77350fe2641e97c03fc07851189128e0196228adc737a22a3e
+Description:  Standard OpenWrt set including full admin with ppp support and the default Bootstrap theme
+
+Package: rpcd-mod-luci
+Version: 20201107
+Depends: libc, rpcd, libubox20201212, libubus20210215, libnl-tiny1
+Source: feeds/luci/libs/rpcd-mod-luci
+SourceName: rpcd-mod-luci
+License: Apache-2.0
+Section: libs
+SourceDateEpoch: 1614585346
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 11819
+Filename: rpcd-mod-luci_20201107_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12683
+SHA256sum: 90153aefe86b6339edb2ba7aaa36681581f032d2c41383c6477b72392e5891f3
+Description:  Provides LuCI backend ubus RPC operations.
+
+Package: rpcd-mod-rrdns
+Version: 20170710
+Depends: libc, rpcd, libubox20201212, libubus20210215
+Source: feeds/luci/libs/rpcd-mod-rrdns
+SourceName: rpcd-mod-rrdns
+License: Apache-2.0
+Section: libs
+SourceDateEpoch: 1614407678
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3461
+Filename: rpcd-mod-rrdns_20170710_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4297
+SHA256sum: 23e03af9590ade95199e2fcab3d20a34d1283bed9d245a938264533d2570ec29
+Description:  Provides rapid mass reverse DNS lookup functionality.
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.sig b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.sig
new file mode 100644
index 0000000000..e91546978a
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/Packages.sig
@@ -0,0 +1,2 @@
+untrusted comment: signed by key d1f1809848731cb7
+RWTR8YCYSHMctyibJr+4MLjfYef+z+I+p0KLi9VjqPL0WcU0hMyPdJ/WG9LK1n2BDr0sxMkJxF/pq+JwyX2zCxS+i0L/tqAQcgY=
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/liblucihttp-lua_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/liblucihttp-lua_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d619a10090
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/liblucihttp-lua_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/liblucihttp0_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/liblucihttp0_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..86432dd13f
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/liblucihttp0_2019-07-05-a34a17d5-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-adblock_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-adblock_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..20da3a0cef
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-adblock_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-banip_git-21.062.56276-2e1f950_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-banip_git-21.062.56276-2e1f950_all.ipk
new file mode 100644
index 0000000000..6c9d638d77
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-banip_git-21.062.56276-2e1f950_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-bcp38_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-bcp38_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..e90b9a4edd
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-bcp38_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-commands_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-commands_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..d2c277e90d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-commands_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-dawn_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-dawn_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..8d22c82d06
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-dawn_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-ddns_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-ddns_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..5a26dd9c95
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-ddns_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-firewall_git-21.060.51546-4935525_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-firewall_git-21.060.51546-4935525_all.ipk
new file mode 100644
index 0000000000..6dccad5138
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-firewall_git-21.060.51546-4935525_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-nlbwmon_git-21.060.34261-628a1b8_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-nlbwmon_git-21.060.34261-628a1b8_all.ipk
new file mode 100644
index 0000000000..dbb2ddd2f1
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-nlbwmon_git-21.060.34261-628a1b8_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-openvpn_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-openvpn_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..722e063e08
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-openvpn_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-opkg_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-opkg_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..375a5a7ff1
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-opkg_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-sqm_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-sqm_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..13b30cca05
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-sqm_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-statistics_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-statistics_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..38662ce3eb
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-statistics_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-wireguard_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-wireguard_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..c48bed6242
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-app-wireguard_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-base_git-21.060.51546-bd39e6a_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-base_git-21.060.51546-bd39e6a_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..f9d88bafcf
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-base_git-21.060.51546-bd39e6a_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-compat_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-compat_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..f2c6592df8
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-compat_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-base_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-base_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..d59e9906df
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-base_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-ip_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-ip_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..a54039b4b3
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-ip_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-ipkg_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-ipkg_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..3e259b5a96
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-ipkg_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-json_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-json_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..5eb311aeea
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-json_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-jsonc_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-jsonc_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..abe0f9c189
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-jsonc_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-nixio_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-nixio_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..7218e4c8e6
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-lib-nixio_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-admin-full_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-admin-full_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..9eed6c44b7
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-admin-full_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-network_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-network_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..0eab7ba601
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-network_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-status_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-status_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2ce4c378ef
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-status_git-21.058.23678-d551587_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-system_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-system_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..a916564706
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-mod-system_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-ipv6_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-ipv6_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..04eb0b2379
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-ipv6_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-ppp_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-ppp_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..33b875d578
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-ppp_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-wireguard_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-wireguard_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..8998b0d41a
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-proto-wireguard_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-ssl-openssl_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-ssl-openssl_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..b6a1b0ab44
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-ssl-openssl_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-theme-bootstrap_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-theme-bootstrap_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..2eece8fede
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-theme-bootstrap_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-theme-openwrt-2020_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-theme-openwrt-2020_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..bca4bb8803
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci-theme-openwrt-2020_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci_git-21.058.23678-d551587_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci_git-21.058.23678-d551587_all.ipk
new file mode 100644
index 0000000000..3463861c4c
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/luci_git-21.058.23678-d551587_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/rpcd-mod-luci_20201107_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/rpcd-mod-luci_20201107_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c07c744679
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/rpcd-mod-luci_20201107_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/luci/rpcd-mod-rrdns_20170710_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/rpcd-mod-rrdns_20170710_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8b87506aab
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/luci/rpcd-mod-rrdns_20170710_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages
new file mode 100644
index 0000000000..0db8121f89
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages
@@ -0,0 +1,531 @@
+Package: adblock
+Version: 4.1.0-1
+Depends: libc, jshn, jsonfilter, coreutils, coreutils-sort, ca-bundle, opkg
+License: GPL-3.0-or-later
+Section: net
+Architecture: all
+Installed-Size: 19427
+Filename: adblock_4.1.0-1_all.ipk
+Size: 20408
+SHA256sum: 8abe5e98eaa32d6a7824af4932834ce2bf56ef131cd568ca008f79d15433c548
+Description:  Powerful adblock script to block ad/abuse domains via dnsmasq, unbound, named or kresd.
+ The script supports many domain blacklist sites plus manual black- and whitelist overrides.
+ Please see https://github.com/openwrt/packages/blob/master/net/adblock/files/README.md for further information.
+ 
+
+Package: banip
+Version: 0.7.3-1
+Depends: libc, jshn, jsonfilter, ip, ipset, iptables, ca-bundle
+License: GPL-3.0-or-later
+Section: net
+Architecture: all
+Installed-Size: 19786
+Filename: banip_0.7.3-1_all.ipk
+Size: 20788
+SHA256sum: ea11f1e1bf0094d3a4ccd97106b3940b2069f96fb4c290dc11dea3aa5173ffc2
+Description:  Powerful banIP script to block ip addresses via ipsets.
+ The script supports many ip blacklist sites plus manual black- and whitelist overrides.
+ Please see https://github.com/openwrt/packages/blob/master/net/banip/files/README.md for further information.
+ 
+
+Package: bcp38
+Version: 5-6
+Depends: libc, ipset
+Section: net
+Architecture: all
+Installed-Size: 2068
+Filename: bcp38_5-6_all.ipk
+Size: 3032
+SHA256sum: b2765ac376fa759074e4c3dc178d7f917087ec57e0487d41ea7d5677111769f6
+Description:  bcp38 implements IETF BCP38 for home routers.
+ See https://tools.ietf.org/html/bcp38.
+ 
+ This package provides BCP38 for IPv4 only - IPv6 uses source 
+ specific default routes, so no firewall configuration is needed.
+
+Package: cgi-io
+Version: 2020-10-27-ab4c3471-19
+Depends: libc, libubox20201212, libubus20210215
+License: GPL-2.0-or-later
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8437
+Filename: cgi-io_2020-10-27-ab4c3471-19_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9251
+SHA256sum: 506ca5dea5b450d2d426d29ada231a0ee5dac7604063e50fb8816c046da4e9bb
+Description:  This package contains an cgi utility that is useful for up/downloading files
+
+Package: collectd-mod-conntrack
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1742
+Filename: collectd-mod-conntrack_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2521
+SHA256sum: e8d5c4c4d694be09d404bcc4651289c6332eade6bb774a8d24b6758dbb72e806
+Description:  connection tracking table size input plugin
+
+Package: collectd-mod-cpu
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3919
+Filename: collectd-mod-cpu_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4682
+SHA256sum: fdb3b7e6ab60aa41a1612974a46da4744b35c4f85556fc660e8b2ad6e8d37854
+Description:  CPU input plugin
+
+Package: collectd-mod-cpufreq
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2761
+Filename: collectd-mod-cpufreq_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3542
+SHA256sum: 7c3c2e99a0c262a4b03b47d759ca42f9a7bd05bdf1f4f13dc82855ec04b087fe
+Description:  CPU Freq input plugin
+
+Package: collectd-mod-dhcpleases
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1698
+Filename: collectd-mod-dhcpleases_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2499
+SHA256sum: 9ddfebcd731c2ea1bf3f22742715d1042901c8fe08f4ebe92339c9669128f723
+Description:  show dhcpleases plugin
+
+Package: collectd-mod-entropy
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1401
+Filename: collectd-mod-entropy_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2185
+SHA256sum: 2059ff9bdfe13495e41f3e1f370b6f072754de6ba45ac0293ba72274a356745e
+Description:  Entropy amount input plugin
+
+Package: collectd-mod-exec
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 23190
+Filename: collectd-mod-exec_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 23952
+SHA256sum: 310131f222054fe0a09bf62573f329311dcd22e5a3f317e0e52384e2bf8508dc
+Description:  process exec input plugin
+
+Package: collectd-mod-interface
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3387
+Filename: collectd-mod-interface_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4176
+SHA256sum: 0bdcc530e916b49d40d55873f4dd04fd503e55166f093fc35fcc8455e67309c8
+Description:  network interfaces input plugin
+
+Package: collectd-mod-iwinfo
+Version: 5.12.0-7
+Depends: libc, collectd, libiwinfo20210106
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3473
+Filename: collectd-mod-iwinfo_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4277
+SHA256sum: b80c3d187efc5a71ff5de3e6f74c58fe5c57ecf1266f3c5d09ebf73eb92d76dd
+Description:  libiwinfo wireless statistics plugin
+
+Package: collectd-mod-load
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1839
+Filename: collectd-mod-load_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2608
+SHA256sum: 1f77c0b09f57739555a2f08e847f4e0730d818059d35db6ba5aeb8cd6ac436c5
+Description:  system load input plugin
+
+Package: collectd-mod-memory
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2654
+Filename: collectd-mod-memory_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3440
+SHA256sum: 0a3a90723f973c9c9780b78f666132c13b15b83080859261d346714bf72b76ef
+Description:  physical memory usage input plugin
+
+Package: collectd-mod-network
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 14983
+Filename: collectd-mod-network_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15767
+SHA256sum: b724e20bc023f7adab067c0a59395c47a7939004fe8731d016c6c13d3bd344f7
+Description:  network input/output plugin
+
+Package: collectd-mod-ping
+Version: 5.12.0-7
+Depends: libc, collectd, liboping
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5207
+Filename: collectd-mod-ping_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6000
+SHA256sum: ca0973ec9d27f666d36b277fb187af045525fc5b6058dc65fcdbc31590b99062
+Description:  ping status input plugin
+
+Package: collectd-mod-rrdtool
+Version: 5.12.0-7
+Depends: libc, collectd, librrd1
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 11256
+Filename: collectd-mod-rrdtool_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12064
+SHA256sum: 039169cc4585c9c99463ec7e2933d3b0505b5dc3765680f89b04dd7eb1e42dd8
+Description:  RRDtool output plugin
+
+Package: collectd-mod-sqm
+Version: 5.12.0-7
+Depends: libc, collectd-mod-exec
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1302
+Filename: collectd-mod-sqm_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2108
+SHA256sum: fd5fc7041e93c682897357508654774907a1cad4054fe84ed170edafb4fb52bb
+Description:  SQM/qdisc collection plugin
+
+Package: collectd-mod-thermal
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3898
+Filename: collectd-mod-thermal_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4687
+SHA256sum: 742d92a300b15b1098072f567706306eb44ce39a19b8e4e16996b88620e855d2
+Description:  system temperatures input plugin
+
+Package: collectd-mod-uptime
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1488
+Filename: collectd-mod-uptime_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2266
+SHA256sum: aaefe243e5be88f1d5f6f8be478bf7983b91456ab5e7567ed92ea4e4dc6c0c2d
+Description:  uptime status input plugin
+
+Package: collectd-mod-wireless
+Version: 5.12.0-7
+Depends: libc, collectd
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2175
+Filename: collectd-mod-wireless_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2977
+SHA256sum: 2306accde6240f814e61c95b7a95f9af497095aceecc6bf46f3ad6dbcc8712fb
+Description:  wireless status input plugin
+
+Package: collectd
+Version: 5.12.0-7
+Depends: libc, libpthread, zlib, libltdl7, libip4tc2, jshn
+Section: utils
+CPE-ID: cpe:/a:collectd:collectd
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 87190
+Filename: collectd_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 88061
+SHA256sum: 19aecec0dda862e0be8aaf00ee9a840488c59abbe1f708234209cfcf45be7d96
+Description:  collectd is a small daemon which collects system information periodically
+ and provides mechanismns to store the values in a variety of ways.
+
+Package: coreutils-sort
+Version: 8.32-6
+Depends: libc, coreutils, libpthread
+Alternatives: 300:/usr/bin/sort:/usr/libexec/sort-coreutils
+License: GPL-3.0-or-later
+Section: utils
+CPE-ID: cpe:/a:gnu:coreutils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 46695
+Filename: coreutils-sort_8.32-6_arm_cortex-a15_neon-vfpv4.ipk
+Size: 47450
+SHA256sum: 22eaa6ea6fcce7b374ef404610b27ef180e3df2abe78180f16abc46a5416f2c1
+Description:  Full version of standard GNU sort utility.
+
+Package: coreutils
+Version: 8.32-6
+Depends: libc
+License: GPL-3.0-or-later
+Section: utils
+CPE-ID: cpe:/a:gnu:coreutils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 103
+Filename: coreutils_8.32-6_arm_cortex-a15_neon-vfpv4.ipk
+Size: 997
+SHA256sum: 16f80460f75e6c95bc4d4d421053d3d5ffa1aca77dca800cf57e8b89ee8ae46c
+Description:  Full versions of standard GNU utilities. If an equivalent Busybox applet is
+ available, you should consider compiling that instead as Busybox applets are
+ usually smaller, at the expense of reduced functionality.
+
+Package: dawn
+Version: 2020-12-31-8ce09d64-1
+Depends: libc, libubus20210215, libubox20201212, libblobmsg-json20201212, libuci20130104, libgcrypt, libiwinfo20210106, umdns
+License: GPL-2.0-only
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 30990
+Filename: dawn_2020-12-31-8ce09d64-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 31821
+SHA256sum: 3e13166d86f45930999eb301ac535fc61ff26f8ab17b6c144bf6e4835f61eb67
+Description:  This package implements a decentralized wireless daemon.
+
+Package: ddns-scripts-services
+Version: 2.8.2-7
+Depends: libc
+License: GPL-2.0
+Section: net
+Architecture: all
+Installed-Size: 3981
+Filename: ddns-scripts-services_2.8.2-7_all.ipk
+Size: 4612
+SHA256sum: f40d5b0f937879edfbf35dd173c13e58fdc2af06282b9f3f2ecc3420427cf961
+Description:  Dynamic DNS Client definitions for supported services
+
+Package: ddns-scripts
+Version: 2.8.2-7
+Depends: libc, ddns-scripts-services
+License: GPL-2.0
+Section: net
+Architecture: all
+Installed-Size: 23723
+Filename: ddns-scripts_2.8.2-7_all.ipk
+Size: 24738
+SHA256sum: 85aa7f4d03b3e44810fca9686da8cd73ed2238d094da7445533feebbd2668707
+Description:  Dynamic DNS Client scripts (with IPv6 support)
+ A highly configurable set of scripts for doing dynamic dns updates.
+ - IPv6 support
+ - DNS server support
+ - Glue Record support (require BIND host or KNOT host)
+ - DNS requests via TCP
+ - Proxy server support
+ - log file support
+ - support to run once
+ Version: 2.8.2-7
+ Info   : https://openwrt.org/docs/guide-user/services/ddns/client
+
+Package: htop
+Version: 3.0.5-1
+Depends: libc, libncurses6
+License: GPL-2.0-or-later
+Section: admin
+CPE-ID: cpe:/a:htop:htop
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 75914
+Filename: htop_3.0.5-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 76809
+SHA256sum: 94e5775e145a53dac7f202ff20e55cb98caa72d4cbf2bf7ebf181c1323f59642
+Description:  Htop is an ncursed-based process viewer similar to top, but
+ it allows to scroll the list vertically and horizontally to
+ see all processes and their full command lines.
+
+Package: irqbalance
+Version: 1.7.0-1
+Depends: libc
+License: GPLv2
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 47363
+Filename: irqbalance_1.7.0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 48243
+SHA256sum: 9bcb154db0f98febc7dbc4d1e8d71d8845b8222352a5472e7aeea474d850b881
+Description:  The purpose of irqbalance is to distribute hardware interrupts across
+ processors/cores on a multiprocessor/multicore system in order to
+ increase performance.
+
+Package: libgcrypt
+Version: 1.8.7-2
+Depends: libc, libgpg-error
+License: LGPL-2.1-or-later
+Section: libs
+CPE-ID: cpe:/a:gnupg:libgcrypt
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 362732
+Filename: libgcrypt_1.8.7-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 361565
+SHA256sum: 7cd0d821cbf2b6ec2ea51a21a79db9f59d5b47509a28416363e3ff373e437399
+Description:  This is a general purpose cryptographic library based on the code from
+ GnuPG. It provides functions for all cryptograhic building blocks:
+ symmetric ciphers (AES, DES, Arcfour, CAST5), hash algorithms (MD5, SHA-1,
+ RIPE-MD160, SHA-224/256, SHA-384/512), MACs (HMAC for all hash
+ algorithms), public key algorithms (RSA, DSA), large integer functions,
+ random numbers and a lot of supporting functions. Some algorithms have
+ been disabled to reduce size (Blowfish, Twofish, Serpent,
+ RC2, SEED, Camellia, CRC, MD4, TIGER-192, Whirlpool, ElGamal, ECC).
+
+Package: libgpg-error
+Version: 1.39-2
+Depends: libc
+License: LGPL-2.1-or-later
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 48255
+Filename: libgpg-error_1.39-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 49248
+SHA256sum: 384e39bec39d15c2bc58a2dc14f1fbaf29c183d77e80341f57248e4eaf7ca688
+Description:  An helper library for common error codes and descriptions.
+ This is a library that defines common error values for all GnuPG
+ components. Among these are GPG, GPGSM, GPGME, GPG-Agent, libgcrypt,
+ Libksba, DirMngr, Pinentry, SmartCard Daemon and possibly more in the
+ future.
+
+Package: liboping
+Version: 1.10.0-2
+Depends: libc
+License: LGPL-2.1-or-later
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6869
+Filename: liboping_1.10.0-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7681
+SHA256sum: bd64eafc107eb03bd1ca531714a8f61a173b2133fbb5578a07dfe75f08f2d0ac
+Description:  C library to generate ICMP echo requests.
+
+Package: librrd1
+Version: 1.0.50-3
+Depends: libc, zlib
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 130787
+Filename: librrd1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 131282
+SHA256sum: 40a947fe7bb0bd355445345b6159d8b2a9a167456ba46f6b9255fd967eab57d1
+Description:  RRD is the Acronym for Round Robin Database. RRD is a system to store and
+ display time-series data (i.e. network bandwidth, machine-room temperature,
+ server load average). It stores the data in a very compact way that will
+ not expand over time, and it presents useful graphs by processing the data
+ to enforce a certain data density. It can be used either via simple wrapper
+ scripts (from shell or Perl) or via frontends that poll network devices and
+ put friendly user interface on it.
+ 
+ This is version 1.0.x with cgilib-0.4, gd1.3 and libpng-1.0.9 linked into
+ librrd.so. The library is much smaller compared to the 1.2.x version with
+ separate dynamic linked libraries.
+ This package contains a shared library, used by other programs.
+
+Package: nlbwmon
+Version: 2020-04-11.1-34a18876-3
+Depends: libc, libubox20201212, libnl-tiny1, zlib, kmod-nf-conntrack-netlink
+License: ISC
+Section: net
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19086
+Filename: nlbwmon_2020-04-11.1-34a18876-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19974
+SHA256sum: 6f7e724afb8599762536389c5db367382e75859cdd8d3e29787b3ed952640d92
+Description:  OpenWrt Traffic Usage Monitor
+
+Package: ntfs-3g
+Version: 2017.3.23-4-fuseint
+Depends: libc, kmod-fuse, libpthread
+License: GPL-2.0-only LGPL-2.1-or-later
+Section: utils
+CPE-ID: cpe:/a:ntfs-3g:ntfs-3g
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 184946
+Filename: ntfs-3g_2017.3.23-4-fuseint_arm_cortex-a15_neon-vfpv4.ipk
+Size: 185620
+SHA256sum: 8f589211138fa2c6021ead9d8ebb7dc280174b9d7712579d35cebef79b0cc5c7
+Description:  Ntfs-3g is a NTFS driver, which can create, remove, rename,
+ move files, directories, hard links, and streams. It can read
+ and write files, including streams and sparse files. It can
+ handle special files like symbolic links, devices, and FIFOs.
+ Moreover it can also read transparently compressed files.
+ 
+ Contains:
+ - ntfs-3g
+ - ntfs-3g.probe
+ - mount.ntfs-3g (symlink to ntfs-3g)
+ 
+
+Package: openvpn-openssl
+Version: 2.5.0-2
+Depends: libc, kmod-tun, libopenssl1.1
+Provides: openvpn, openvpn-crypto
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:openvpn:openvpn
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 203019
+Filename: openvpn-openssl_2.5.0-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 203572
+SHA256sum: f95575be2658e2e28b8ef1f187f9695bf751514eb7f39b81fdaa9a8ba935d047
+Description:  Open source VPN solution using OpenSSL
+
+Package: rrdtool1
+Version: 1.0.50-3
+Depends: libc, librrd1
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10331
+Filename: rrdtool1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11477
+SHA256sum: fafd77436a3ffc56d4f453f2d4dd1f7f24357f057e62103068e0ec17847ae959
+Description:  RRD is the Acronym for Round Robin Database. RRD is a system to store and
+ display time-series data (i.e. network bandwidth, machine-room temperature,
+ server load average). It stores the data in a very compact way that will
+ not expand over time, and it presents useful graphs by processing the data
+ to enforce a certain data density. It can be used either via simple wrapper
+ scripts (from shell or Perl) or via frontends that poll network devices and
+ put friendly user interface on it.
+ 
+ This is version 1.0.x with cgilib-0.4, gd1.3 and libpng-1.0.9 linked into
+ librrd.so. The library is much smaller compared to the 1.2.x version with
+ separate dynamic linked libraries.
+ This package contains command line tools used to manage RRDs.
+
+Package: sqm-scripts
+Version: 1.5.0-2
+Depends: libc, tc, kmod-sched-core, kmod-ifb, iptables, iptables-mod-ipopt, iptables-mod-conntrack-extra, kmod-sched-cake
+License: GPL-2.0-only
+Section: net
+Architecture: all
+Installed-Size: 17890
+Filename: sqm-scripts_1.5.0-2_all.ipk
+Size: 18787
+SHA256sum: 6f6e38aa4b6ce5567e0cacdf0b97a92c25c624ea8b81cb224d379097884a7d4c
+Description:  A set of scripts that does simple SQM configuration.
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.gz b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.gz
new file mode 100644
index 0000000000..6a6bfdd023
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.gz differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.manifest b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.manifest
new file mode 100644
index 0000000000..128a6ad89e
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.manifest
@@ -0,0 +1,689 @@
+Package: adblock
+Version: 4.1.0-1
+Depends: libc, jshn, jsonfilter, coreutils, coreutils-sort, ca-bundle, opkg
+Source: feeds/packages/net/adblock
+SourceName: adblock
+License: GPL-3.0-or-later
+Section: net
+SourceDateEpoch: 1614418506
+Maintainer: Dirk Brenken <dev@brenken.org>
+Architecture: all
+Installed-Size: 19427
+Filename: adblock_4.1.0-1_all.ipk
+Size: 20408
+SHA256sum: 8abe5e98eaa32d6a7824af4932834ce2bf56ef131cd568ca008f79d15433c548
+Description:  Powerful adblock script to block ad/abuse domains via dnsmasq, unbound, named or kresd.
+ The script supports many domain blacklist sites plus manual black- and whitelist overrides.
+ Please see https://github.com/openwrt/packages/blob/master/net/adblock/files/README.md for further information.
+ 
+
+Package: banip
+Version: 0.7.3-1
+Depends: libc, jshn, jsonfilter, ip, ipset, iptables, ca-bundle
+Source: feeds/packages/net/banip
+SourceName: banip
+License: GPL-3.0-or-later
+Section: net
+SourceDateEpoch: 1614418506
+Maintainer: Dirk Brenken <dev@brenken.org>
+Architecture: all
+Installed-Size: 19786
+Filename: banip_0.7.3-1_all.ipk
+Size: 20788
+SHA256sum: ea11f1e1bf0094d3a4ccd97106b3940b2069f96fb4c290dc11dea3aa5173ffc2
+Description:  Powerful banIP script to block ip addresses via ipsets.
+ The script supports many ip blacklist sites plus manual black- and whitelist overrides.
+ Please see https://github.com/openwrt/packages/blob/master/net/banip/files/README.md for further information.
+ 
+
+Package: bcp38
+Version: 5-6
+Depends: libc, ipset
+Source: feeds/packages/net/bcp38
+SourceName: bcp38
+Section: net
+SourceDateEpoch: 1614418506
+Maintainer: Toke Høiland-Jørgensen <toke@toke.dk>
+Architecture: all
+Installed-Size: 2068
+Filename: bcp38_5-6_all.ipk
+Size: 3032
+SHA256sum: b2765ac376fa759074e4c3dc178d7f917087ec57e0487d41ea7d5677111769f6
+Description:  bcp38 implements IETF BCP38 for home routers.
+ See https://tools.ietf.org/html/bcp38.
+ 
+ This package provides BCP38 for IPv4 only - IPv6 uses source 
+ specific default routes, so no firewall configuration is needed.
+
+Package: cgi-io
+Version: 2020-10-27-ab4c3471-19
+Depends: libc, libubox20201212, libubus20210215
+Source: feeds/packages/net/cgi-io
+SourceName: cgi-io
+License: GPL-2.0-or-later
+Section: net
+SourceDateEpoch: 1614418506
+Maintainer: John Crispin <blogic@openwrt.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8437
+Filename: cgi-io_2020-10-27-ab4c3471-19_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9251
+SHA256sum: 506ca5dea5b450d2d426d29ada231a0ee5dac7604063e50fb8816c046da4e9bb
+Description:  This package contains an cgi utility that is useful for up/downloading files
+
+Package: collectd-mod-conntrack
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-conntrack
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1742
+Filename: collectd-mod-conntrack_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2521
+SHA256sum: e8d5c4c4d694be09d404bcc4651289c6332eade6bb774a8d24b6758dbb72e806
+Description:  connection tracking table size input plugin
+
+Package: collectd-mod-cpu
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-cpu
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3919
+Filename: collectd-mod-cpu_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4682
+SHA256sum: fdb3b7e6ab60aa41a1612974a46da4744b35c4f85556fc660e8b2ad6e8d37854
+Description:  CPU input plugin
+
+Package: collectd-mod-cpufreq
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-cpufreq
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2761
+Filename: collectd-mod-cpufreq_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3542
+SHA256sum: 7c3c2e99a0c262a4b03b47d759ca42f9a7bd05bdf1f4f13dc82855ec04b087fe
+Description:  CPU Freq input plugin
+
+Package: collectd-mod-dhcpleases
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-dhcpleases
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1698
+Filename: collectd-mod-dhcpleases_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2499
+SHA256sum: 9ddfebcd731c2ea1bf3f22742715d1042901c8fe08f4ebe92339c9669128f723
+Description:  show dhcpleases plugin
+
+Package: collectd-mod-entropy
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-entropy
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1401
+Filename: collectd-mod-entropy_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2185
+SHA256sum: 2059ff9bdfe13495e41f3e1f370b6f072754de6ba45ac0293ba72274a356745e
+Description:  Entropy amount input plugin
+
+Package: collectd-mod-exec
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-exec
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 23190
+Filename: collectd-mod-exec_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 23952
+SHA256sum: 310131f222054fe0a09bf62573f329311dcd22e5a3f317e0e52384e2bf8508dc
+Description:  process exec input plugin
+
+Package: collectd-mod-interface
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-interface
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3387
+Filename: collectd-mod-interface_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4176
+SHA256sum: 0bdcc530e916b49d40d55873f4dd04fd503e55166f093fc35fcc8455e67309c8
+Description:  network interfaces input plugin
+
+Package: collectd-mod-iwinfo
+Version: 5.12.0-7
+Depends: libc, collectd, libiwinfo20210106
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-iwinfo
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3473
+Filename: collectd-mod-iwinfo_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4277
+SHA256sum: b80c3d187efc5a71ff5de3e6f74c58fe5c57ecf1266f3c5d09ebf73eb92d76dd
+Description:  libiwinfo wireless statistics plugin
+
+Package: collectd-mod-load
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-load
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1839
+Filename: collectd-mod-load_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2608
+SHA256sum: 1f77c0b09f57739555a2f08e847f4e0730d818059d35db6ba5aeb8cd6ac436c5
+Description:  system load input plugin
+
+Package: collectd-mod-memory
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-memory
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2654
+Filename: collectd-mod-memory_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3440
+SHA256sum: 0a3a90723f973c9c9780b78f666132c13b15b83080859261d346714bf72b76ef
+Description:  physical memory usage input plugin
+
+Package: collectd-mod-network
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-network
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 14983
+Filename: collectd-mod-network_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15767
+SHA256sum: b724e20bc023f7adab067c0a59395c47a7939004fe8731d016c6c13d3bd344f7
+Description:  network input/output plugin
+
+Package: collectd-mod-ping
+Version: 5.12.0-7
+Depends: libc, collectd, liboping
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-ping
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5207
+Filename: collectd-mod-ping_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6000
+SHA256sum: ca0973ec9d27f666d36b277fb187af045525fc5b6058dc65fcdbc31590b99062
+Description:  ping status input plugin
+
+Package: collectd-mod-rrdtool
+Version: 5.12.0-7
+Depends: libc, collectd, librrd1
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-rrdtool
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 11256
+Filename: collectd-mod-rrdtool_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12064
+SHA256sum: 039169cc4585c9c99463ec7e2933d3b0505b5dc3765680f89b04dd7eb1e42dd8
+Description:  RRDtool output plugin
+
+Package: collectd-mod-sqm
+Version: 5.12.0-7
+Depends: libc, collectd-mod-exec
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-sqm
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1302
+Filename: collectd-mod-sqm_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2108
+SHA256sum: fd5fc7041e93c682897357508654774907a1cad4054fe84ed170edafb4fb52bb
+Description:  SQM/qdisc collection plugin
+
+Package: collectd-mod-thermal
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-thermal
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3898
+Filename: collectd-mod-thermal_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4687
+SHA256sum: 742d92a300b15b1098072f567706306eb44ce39a19b8e4e16996b88620e855d2
+Description:  system temperatures input plugin
+
+Package: collectd-mod-uptime
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-uptime
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1488
+Filename: collectd-mod-uptime_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2266
+SHA256sum: aaefe243e5be88f1d5f6f8be478bf7983b91456ab5e7567ed92ea4e4dc6c0c2d
+Description:  uptime status input plugin
+
+Package: collectd-mod-wireless
+Version: 5.12.0-7
+Depends: libc, collectd
+Source: feeds/packages/utils/collectd
+SourceName: collectd-mod-wireless
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2175
+Filename: collectd-mod-wireless_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2977
+SHA256sum: 2306accde6240f814e61c95b7a95f9af497095aceecc6bf46f3ad6dbcc8712fb
+Description:  wireless status input plugin
+
+Package: collectd
+Version: 5.12.0-7
+Depends: libc, libpthread, zlib, libltdl7, libip4tc2, jshn
+Source: feeds/packages/utils/collectd
+SourceName: collectd
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:collectd:collectd
+Maintainer: Jo-Philipp Wich <jo@mein.io>, Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 87190
+Filename: collectd_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
+Size: 88061
+SHA256sum: 19aecec0dda862e0be8aaf00ee9a840488c59abbe1f708234209cfcf45be7d96
+Description:  collectd is a small daemon which collects system information periodically
+ and provides mechanismns to store the values in a variety of ways.
+
+Package: coreutils-sort
+Version: 8.32-6
+Depends: libc, coreutils, libpthread
+Alternatives: 300:/usr/bin/sort:/usr/libexec/sort-coreutils
+Source: feeds/packages/utils/coreutils
+SourceName: coreutils-sort
+License: GPL-3.0-or-later
+LicenseFiles: COPYING
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:gnu:coreutils
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 46695
+Filename: coreutils-sort_8.32-6_arm_cortex-a15_neon-vfpv4.ipk
+Size: 47450
+SHA256sum: 22eaa6ea6fcce7b374ef404610b27ef180e3df2abe78180f16abc46a5416f2c1
+Description:  Full version of standard GNU sort utility.
+
+Package: coreutils
+Version: 8.32-6
+Depends: libc
+Source: feeds/packages/utils/coreutils
+SourceName: coreutils
+License: GPL-3.0-or-later
+LicenseFiles: COPYING
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:gnu:coreutils
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 103
+Filename: coreutils_8.32-6_arm_cortex-a15_neon-vfpv4.ipk
+Size: 997
+SHA256sum: 16f80460f75e6c95bc4d4d421053d3d5ffa1aca77dca800cf57e8b89ee8ae46c
+Description:  Full versions of standard GNU utilities. If an equivalent Busybox applet is
+ available, you should consider compiling that instead as Busybox applets are
+ usually smaller, at the expense of reduced functionality.
+
+Package: dawn
+Version: 2020-12-31-8ce09d64-1
+Depends: libc, libubus20210215, libubox20201212, libblobmsg-json20201212, libuci20130104, libgcrypt, libiwinfo20210106, umdns
+Source: feeds/packages/net/dawn
+SourceName: dawn
+License: GPL-2.0-only
+LicenseFiles: LICENSE
+Section: net
+SourceDateEpoch: 1614418506
+Maintainer: Nick Hainke <vincent@systemli.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 30990
+Filename: dawn_2020-12-31-8ce09d64-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 31821
+SHA256sum: 3e13166d86f45930999eb301ac535fc61ff26f8ab17b6c144bf6e4835f61eb67
+Description:  This package implements a decentralized wireless daemon.
+
+Package: ddns-scripts-services
+Version: 2.8.2-7
+Depends: libc
+Source: feeds/packages/net/ddns-scripts
+SourceName: ddns-scripts-services
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1614418506
+Architecture: all
+Installed-Size: 3981
+Filename: ddns-scripts-services_2.8.2-7_all.ipk
+Size: 4612
+SHA256sum: f40d5b0f937879edfbf35dd173c13e58fdc2af06282b9f3f2ecc3420427cf961
+Description:  Dynamic DNS Client definitions for supported services
+
+Package: ddns-scripts
+Version: 2.8.2-7
+Depends: libc, ddns-scripts-services
+Source: feeds/packages/net/ddns-scripts
+SourceName: ddns-scripts
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1614418506
+Architecture: all
+Installed-Size: 23723
+Filename: ddns-scripts_2.8.2-7_all.ipk
+Size: 24738
+SHA256sum: 85aa7f4d03b3e44810fca9686da8cd73ed2238d094da7445533feebbd2668707
+Description:  Dynamic DNS Client scripts (with IPv6 support)
+ A highly configurable set of scripts for doing dynamic dns updates.
+ - IPv6 support
+ - DNS server support
+ - Glue Record support (require BIND host or KNOT host)
+ - DNS requests via TCP
+ - Proxy server support
+ - log file support
+ - support to run once
+ Version: 2.8.2-7
+ Info   : https://openwrt.org/docs/guide-user/services/ddns/client
+
+Package: htop
+Version: 3.0.5-1
+Depends: libc, libncurses6
+Source: feeds/packages/admin/htop
+SourceName: htop
+License: GPL-2.0-or-later
+LicenseFiles: COPYING
+Section: admin
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:htop:htop
+Maintainer: Etienne CHAMPETIER <champetier.etienne@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 75914
+Filename: htop_3.0.5-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 76809
+SHA256sum: 94e5775e145a53dac7f202ff20e55cb98caa72d4cbf2bf7ebf181c1323f59642
+Description:  Htop is an ncursed-based process viewer similar to top, but
+ it allows to scroll the list vertically and horizontally to
+ see all processes and their full command lines.
+
+Package: irqbalance
+Version: 1.7.0-1
+Depends: libc
+Source: feeds/packages/utils/irqbalance
+SourceName: irqbalance
+License: GPLv2
+Section: utils
+SourceDateEpoch: 1614418506
+Maintainer: Hannu Nyman <hannu.nyman@iki.fi>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 47363
+Filename: irqbalance_1.7.0-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 48243
+SHA256sum: 9bcb154db0f98febc7dbc4d1e8d71d8845b8222352a5472e7aeea474d850b881
+Description:  The purpose of irqbalance is to distribute hardware interrupts across
+ processors/cores on a multiprocessor/multicore system in order to
+ increase performance.
+
+Package: libgcrypt
+Version: 1.8.7-2
+Depends: libc, libgpg-error
+Source: feeds/packages/libs/libgcrypt
+SourceName: libgcrypt
+License: LGPL-2.1-or-later
+LicenseFiles: COPYING.LIB
+Section: libs
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:gnupg:libgcrypt
+Maintainer: W. Michael Petullo <mike@flyn.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 362732
+Filename: libgcrypt_1.8.7-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 361565
+SHA256sum: 7cd0d821cbf2b6ec2ea51a21a79db9f59d5b47509a28416363e3ff373e437399
+Description:  This is a general purpose cryptographic library based on the code from
+ GnuPG. It provides functions for all cryptograhic building blocks:
+ symmetric ciphers (AES, DES, Arcfour, CAST5), hash algorithms (MD5, SHA-1,
+ RIPE-MD160, SHA-224/256, SHA-384/512), MACs (HMAC for all hash
+ algorithms), public key algorithms (RSA, DSA), large integer functions,
+ random numbers and a lot of supporting functions. Some algorithms have
+ been disabled to reduce size (Blowfish, Twofish, Serpent,
+ RC2, SEED, Camellia, CRC, MD4, TIGER-192, Whirlpool, ElGamal, ECC).
+
+Package: libgpg-error
+Version: 1.39-2
+Depends: libc
+Source: feeds/packages/libs/libgpg-error
+SourceName: libgpg-error
+License: LGPL-2.1-or-later
+LicenseFiles: COPYING
+Section: libs
+SourceDateEpoch: 1614418506
+Maintainer: W. Michael Petullo <mike@flyn.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 48255
+Filename: libgpg-error_1.39-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 49248
+SHA256sum: 384e39bec39d15c2bc58a2dc14f1fbaf29c183d77e80341f57248e4eaf7ca688
+Description:  An helper library for common error codes and descriptions.
+ This is a library that defines common error values for all GnuPG
+ components. Among these are GPG, GPGSM, GPGME, GPG-Agent, libgcrypt,
+ Libksba, DirMngr, Pinentry, SmartCard Daemon and possibly more in the
+ future.
+
+Package: liboping
+Version: 1.10.0-2
+Depends: libc
+Source: feeds/packages/libs/liboping
+SourceName: liboping
+License: LGPL-2.1-or-later
+Section: libs
+SourceDateEpoch: 1614418506
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6869
+Filename: liboping_1.10.0-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7681
+SHA256sum: bd64eafc107eb03bd1ca531714a8f61a173b2133fbb5578a07dfe75f08f2d0ac
+Description:  C library to generate ICMP echo requests.
+
+Package: librrd1
+Version: 1.0.50-3
+Depends: libc, zlib
+Source: feeds/packages/utils/rrdtool1
+SourceName: librrd1
+Section: libs
+SourceDateEpoch: 1614418506
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 130787
+Filename: librrd1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 131282
+SHA256sum: 40a947fe7bb0bd355445345b6159d8b2a9a167456ba46f6b9255fd967eab57d1
+Description:  RRD is the Acronym for Round Robin Database. RRD is a system to store and
+ display time-series data (i.e. network bandwidth, machine-room temperature,
+ server load average). It stores the data in a very compact way that will
+ not expand over time, and it presents useful graphs by processing the data
+ to enforce a certain data density. It can be used either via simple wrapper
+ scripts (from shell or Perl) or via frontends that poll network devices and
+ put friendly user interface on it.
+ 
+ This is version 1.0.x with cgilib-0.4, gd1.3 and libpng-1.0.9 linked into
+ librrd.so. The library is much smaller compared to the 1.2.x version with
+ separate dynamic linked libraries.
+ This package contains a shared library, used by other programs.
+
+Package: nlbwmon
+Version: 2020-04-11.1-34a18876-3
+Depends: libc, libubox20201212, libnl-tiny1, zlib, kmod-nf-conntrack-netlink
+Source: feeds/packages/net/nlbwmon
+SourceName: nlbwmon
+License: ISC
+LicenseFiles: COPYING
+Section: net
+SourceDateEpoch: 1614418506
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19086
+Filename: nlbwmon_2020-04-11.1-34a18876-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19974
+SHA256sum: 6f7e724afb8599762536389c5db367382e75859cdd8d3e29787b3ed952640d92
+Description:  OpenWrt Traffic Usage Monitor
+
+Package: ntfs-3g
+Version: 2017.3.23-4-fuseint
+Depends: libc, kmod-fuse, libpthread
+Source: feeds/packages/utils/ntfs-3g
+SourceName: ntfs-3g
+License: GPL-2.0-only LGPL-2.1-or-later
+LicenseFiles: COPYING COPYING.LIB
+Section: utils
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:ntfs-3g:ntfs-3g
+Maintainer: Ted Hess <thess@kitschensync.net>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 184946
+Filename: ntfs-3g_2017.3.23-4-fuseint_arm_cortex-a15_neon-vfpv4.ipk
+Size: 185620
+SHA256sum: 8f589211138fa2c6021ead9d8ebb7dc280174b9d7712579d35cebef79b0cc5c7
+Description:  Ntfs-3g is a NTFS driver, which can create, remove, rename,
+ move files, directories, hard links, and streams. It can read
+ and write files, including streams and sparse files. It can
+ handle special files like symbolic links, devices, and FIFOs.
+ Moreover it can also read transparently compressed files.
+ 
+ Contains:
+ - ntfs-3g
+ - ntfs-3g.probe
+ - mount.ntfs-3g (symlink to ntfs-3g)
+ 
+
+Package: openvpn-openssl
+Version: 2.5.0-2
+Depends: libc, kmod-tun, libopenssl1.1
+Provides: openvpn, openvpn-crypto
+Source: feeds/packages/net/openvpn
+SourceName: openvpn-openssl
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1614418506
+CPE-ID: cpe:/a:openvpn:openvpn
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 203019
+Filename: openvpn-openssl_2.5.0-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 203572
+SHA256sum: f95575be2658e2e28b8ef1f187f9695bf751514eb7f39b81fdaa9a8ba935d047
+Description:  Open source VPN solution using OpenSSL
+
+Package: rrdtool1
+Version: 1.0.50-3
+Depends: libc, librrd1
+Source: feeds/packages/utils/rrdtool1
+SourceName: rrdtool1
+Section: utils
+SourceDateEpoch: 1614418506
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10331
+Filename: rrdtool1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11477
+SHA256sum: fafd77436a3ffc56d4f453f2d4dd1f7f24357f057e62103068e0ec17847ae959
+Description:  RRD is the Acronym for Round Robin Database. RRD is a system to store and
+ display time-series data (i.e. network bandwidth, machine-room temperature,
+ server load average). It stores the data in a very compact way that will
+ not expand over time, and it presents useful graphs by processing the data
+ to enforce a certain data density. It can be used either via simple wrapper
+ scripts (from shell or Perl) or via frontends that poll network devices and
+ put friendly user interface on it.
+ 
+ This is version 1.0.x with cgilib-0.4, gd1.3 and libpng-1.0.9 linked into
+ librrd.so. The library is much smaller compared to the 1.2.x version with
+ separate dynamic linked libraries.
+ This package contains command line tools used to manage RRDs.
+
+Package: sqm-scripts
+Version: 1.5.0-2
+Depends: libc, tc, kmod-sched-core, kmod-ifb, iptables, iptables-mod-ipopt, iptables-mod-conntrack-extra, kmod-sched-cake
+Source: feeds/packages/net/sqm-scripts
+SourceName: sqm-scripts
+License: GPL-2.0-only
+Section: net
+SourceDateEpoch: 1614418506
+Maintainer: Toke Høiland-Jørgensen <toke@toke.dk>
+Architecture: all
+Installed-Size: 17890
+Filename: sqm-scripts_1.5.0-2_all.ipk
+Size: 18787
+SHA256sum: 6f6e38aa4b6ce5567e0cacdf0b97a92c25c624ea8b81cb224d379097884a7d4c
+Description:  A set of scripts that does simple SQM configuration.
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.sig b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.sig
new file mode 100644
index 0000000000..30e5454347
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/Packages.sig
@@ -0,0 +1,2 @@
+untrusted comment: signed by key d1f1809848731cb7
+RWTR8YCYSHMctwODZ/iuEXAKA0c6I3UMk3xPun3WbNoapaPutlKdoMaEvhglqy6s8HGpJnUZ8pbIVnh8U9L1Q0goBJzzqlMbQQI=
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/adblock_4.1.0-1_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/adblock_4.1.0-1_all.ipk
new file mode 100644
index 0000000000..b0f49d1b0b
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/adblock_4.1.0-1_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/banip_0.7.3-1_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/banip_0.7.3-1_all.ipk
new file mode 100644
index 0000000000..41d49f1718
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/banip_0.7.3-1_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/bcp38_5-6_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/bcp38_5-6_all.ipk
new file mode 100644
index 0000000000..2bf4c85123
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/bcp38_5-6_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/cgi-io_2020-10-27-ab4c3471-19_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/cgi-io_2020-10-27-ab4c3471-19_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0e778902f3
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/cgi-io_2020-10-27-ab4c3471-19_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-conntrack_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-conntrack_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2b6bc5b9b3
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-conntrack_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-cpu_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-cpu_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..81c9442ee4
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-cpu_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-cpufreq_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-cpufreq_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..81a072f810
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-cpufreq_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-dhcpleases_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-dhcpleases_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..52d6ac7d7b
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-dhcpleases_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-entropy_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-entropy_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..ed14fea7e8
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-entropy_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-exec_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-exec_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..47ed86ea0d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-exec_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-interface_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-interface_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d53b3463d0
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-interface_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-iwinfo_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-iwinfo_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..797b1b536d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-iwinfo_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-load_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-load_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9c7ae7a8d5
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-load_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-memory_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-memory_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..677d19f1c5
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-memory_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-network_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-network_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..f3c2f0aefc
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-network_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-ping_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-ping_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c33815059e
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-ping_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-rrdtool_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-rrdtool_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..4e672a0798
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-rrdtool_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-sqm_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-sqm_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9ad2b3e2e2
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-sqm_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-thermal_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-thermal_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..bf16c8583d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-thermal_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-uptime_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-uptime_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..59c09c32f2
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-uptime_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-wireless_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-wireless_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8a1074a85f
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd-mod-wireless_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..7478696b3a
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/collectd_5.12.0-7_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/coreutils-sort_8.32-6_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/coreutils-sort_8.32-6_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1518aabd7e
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/coreutils-sort_8.32-6_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/coreutils_8.32-6_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/coreutils_8.32-6_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..17839a9217
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/coreutils_8.32-6_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/dawn_2020-12-31-8ce09d64-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/dawn_2020-12-31-8ce09d64-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..a354b41c39
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/dawn_2020-12-31-8ce09d64-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ddns-scripts-services_2.8.2-7_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ddns-scripts-services_2.8.2-7_all.ipk
new file mode 100644
index 0000000000..5a46d32d5a
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ddns-scripts-services_2.8.2-7_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ddns-scripts_2.8.2-7_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ddns-scripts_2.8.2-7_all.ipk
new file mode 100644
index 0000000000..a4e1514778
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ddns-scripts_2.8.2-7_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/htop_3.0.5-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/htop_3.0.5-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..4e0562912d
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/htop_3.0.5-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/irqbalance_1.7.0-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/irqbalance_1.7.0-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..5e22039969
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/irqbalance_1.7.0-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/libgcrypt_1.8.7-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/libgcrypt_1.8.7-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..762488c32c
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/libgcrypt_1.8.7-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/libgpg-error_1.39-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/libgpg-error_1.39-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..de4a746190
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/libgpg-error_1.39-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/liboping_1.10.0-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/liboping_1.10.0-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2761a20f8b
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/liboping_1.10.0-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/librrd1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/librrd1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8442bcd871
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/librrd1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/nlbwmon_2020-04-11.1-34a18876-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/nlbwmon_2020-04-11.1-34a18876-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..77f145bbf1
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/nlbwmon_2020-04-11.1-34a18876-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ntfs-3g_2017.3.23-4-fuseint_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ntfs-3g_2017.3.23-4-fuseint_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..dd34c64867
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/ntfs-3g_2017.3.23-4-fuseint_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/openvpn-openssl_2.5.0-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/openvpn-openssl_2.5.0-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..bb60795d03
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/openvpn-openssl_2.5.0-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/rrdtool1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/rrdtool1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..855f82e1dc
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/rrdtool1_1.0.50-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/packages/sqm-scripts_1.5.0-2_all.ipk b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/sqm-scripts_1.5.0-2_all.ipk
new file mode 100644
index 0000000000..6c0c89168f
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/packages/sqm-scripts_1.5.0-2_all.ipk differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages b/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages
@@ -0,0 +1 @@
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.gz b/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.gz
new file mode 100644
index 0000000000..d73d33af08
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.gz differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.manifest b/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.manifest
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.manifest
@@ -0,0 +1 @@
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.sig b/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.sig
new file mode 100644
index 0000000000..da56f4b2dc
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/routing/Packages.sig
@@ -0,0 +1,2 @@
+untrusted comment: signed by key d1f1809848731cb7
+RWTR8YCYSHMct3zHf2lu2WJnUYMYVc8Pgyuy1Mg2hY9jRHPStXQBpzzQvQnMNqWOIV/CQPZhfDZFVDM0osL29qhppcjgbYjlQAs=
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages b/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages
@@ -0,0 +1 @@
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.gz b/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.gz
new file mode 100644
index 0000000000..d73d33af08
Binary files /dev/null and b/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.gz differ
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.manifest b/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.manifest
new file mode 100644
index 0000000000..8b13789179
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.manifest
@@ -0,0 +1 @@
+
diff --git a/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.sig b/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.sig
new file mode 100644
index 0000000000..da56f4b2dc
--- /dev/null
+++ b/bin/packages/arm_cortex-a15_neon-vfpv4/telephony/Packages.sig
@@ -0,0 +1,2 @@
+untrusted comment: signed by key d1f1809848731cb7
+RWTR8YCYSHMct3zHf2lu2WJnUYMYVc8Pgyuy1Mg2hY9jRHPStXQBpzzQvQnMNqWOIV/CQPZhfDZFVDM0osL29qhppcjgbYjlQAs=
diff --git a/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-factory.bin b/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-factory.bin
new file mode 100644
index 0000000000..47d6cccfd1
Binary files /dev/null and b/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-factory.bin differ
diff --git a/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-initramfs-uImage b/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-initramfs-uImage
new file mode 100644
index 0000000000..22254ecb3e
Binary files /dev/null and b/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-initramfs-uImage differ
diff --git a/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-sysupgrade.bin b/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-sysupgrade.bin
new file mode 100644
index 0000000000..fe78babe59
Binary files /dev/null and b/bin/targets/ipq806x/generic/C2600-20210307-Stable2102NSS-sysupgrade.bin differ
diff --git a/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-factory.bin b/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-factory.bin
new file mode 100644
index 0000000000..8830929727
Binary files /dev/null and b/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-factory.bin differ
diff --git a/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-initramfs-uImage b/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-initramfs-uImage
new file mode 100644
index 0000000000..8d9f484f5e
Binary files /dev/null and b/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-initramfs-uImage differ
diff --git a/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-sysupgrade.bin b/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-sysupgrade.bin
new file mode 100644
index 0000000000..64f3e8885a
Binary files /dev/null and b/bin/targets/ipq806x/generic/EA7500V1-20210307-Stable2102NSS-sysupgrade.bin differ
diff --git a/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-factory.bin b/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-factory.bin
new file mode 100644
index 0000000000..71227d74a9
Binary files /dev/null and b/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-factory.bin differ
diff --git a/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-initramfs-uImage b/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-initramfs-uImage
new file mode 100644
index 0000000000..d086c09850
Binary files /dev/null and b/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-initramfs-uImage differ
diff --git a/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-sysupgrade.bin b/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-sysupgrade.bin
new file mode 100644
index 0000000000..dbcca78ba8
Binary files /dev/null and b/bin/targets/ipq806x/generic/EA8500-20210307-Stable2102NSS-sysupgrade.bin differ
diff --git a/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-factory.bin b/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-factory.bin
new file mode 100644
index 0000000000..2b932ce14f
Binary files /dev/null and b/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-factory.bin differ
diff --git a/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-initramfs-uImage.itb b/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-initramfs-uImage.itb
new file mode 100644
index 0000000000..5a9bc54a4b
Binary files /dev/null and b/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-initramfs-uImage.itb differ
diff --git a/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-sysupgrade.bin b/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-sysupgrade.bin
new file mode 100644
index 0000000000..7b5fba8eaa
Binary files /dev/null and b/bin/targets/ipq806x/generic/G10-20210307-Stable2102NSS-sysupgrade.bin differ
diff --git a/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-factory.bin b/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-factory.bin
new file mode 100644
index 0000000000..c7690e80bb
Binary files /dev/null and b/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-factory.bin differ
diff --git a/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-initramfs-uImage b/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-initramfs-uImage
new file mode 100644
index 0000000000..79237fe30d
Binary files /dev/null and b/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-initramfs-uImage differ
diff --git a/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-sysupgrade.bin b/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-sysupgrade.bin
new file mode 100644
index 0000000000..2e07b15c0e
Binary files /dev/null and b/bin/targets/ipq806x/generic/NBG6817-20210307-Stable2102NSS-sysupgrade.bin differ
diff --git a/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-factory.img b/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-factory.img
new file mode 100644
index 0000000000..c9db66ba7d
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-factory.img differ
diff --git a/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-initramfs-uImage b/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-initramfs-uImage
new file mode 100644
index 0000000000..266535bc61
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-initramfs-uImage differ
diff --git a/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-sysupgrade.bin b/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-sysupgrade.bin
new file mode 100644
index 0000000000..324ee59dcf
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7500V1-20210307-Stable2102NSS-sysupgrade.bin differ
diff --git a/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-factory.img b/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-factory.img
new file mode 100644
index 0000000000..46eec9f84e
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-factory.img differ
diff --git a/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-initramfs-uImage b/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-initramfs-uImage
new file mode 100644
index 0000000000..a0fd183f89
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-initramfs-uImage differ
diff --git a/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-sysupgrade.bin b/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-sysupgrade.bin
new file mode 100644
index 0000000000..a86f15aed1
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7500V2-20210307-Stable2102NSS-sysupgrade.bin differ
diff --git a/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-factory.img b/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-factory.img
new file mode 100644
index 0000000000..becdea70ae
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-factory.img differ
diff --git a/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-initramfs-uImage b/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-initramfs-uImage
new file mode 100644
index 0000000000..e4db60cb8b
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-initramfs-uImage differ
diff --git a/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-sysupgrade.bin b/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-sysupgrade.bin
new file mode 100644
index 0000000000..e7b2a43d8c
Binary files /dev/null and b/bin/targets/ipq806x/generic/R7800-20210307-Stable2102NSS-sysupgrade.bin differ
diff --git a/bin/targets/ipq806x/generic/config.buildinfo b/bin/targets/ipq806x/generic/config.buildinfo
new file mode 100644
index 0000000000..fe10d18722
--- /dev/null
+++ b/bin/targets/ipq806x/generic/config.buildinfo
@@ -0,0 +1,241 @@
+CONFIG_TARGET_ipq806x=y
+CONFIG_TARGET_ipq806x_generic=y
+CONFIG_TARGET_MULTI_PROFILE=y
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_asrock_g10=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_asrock_g10=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_linksys_ea7500-v1=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_linksys_ea7500-v1=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_linksys_ea8500=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_linksys_ea8500=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_netgear_r7500=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_netgear_r7500=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_netgear_r7500v2=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_netgear_r7500v2=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_netgear_r7800=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_netgear_r7800=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_tplink_c2600=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_tplink_c2600=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_zyxel_nbg6817=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_zyxel_nbg6817=""
+CONFIG_BUSYBOX_CUSTOM=y
+CONFIG_TARGET_PER_DEVICE_ROOTFS=y
+CONFIG_BUILD_PATENTED=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_EDITING_SAVEHISTORY=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_EDITING_SAVE_ON_EXIT=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_LESS_FLAGS=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_LESS_REGEXP=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_LESS_WINCH=y
+CONFIG_DROPBEAR_ECC=y
+CONFIG_IMAGEOPT=y
+CONFIG_OPENSSL_ENGINE=y
+CONFIG_OPENSSL_PREFER_CHACHA_OVER_GCM=y
+CONFIG_OPENSSL_WITH_ASM=y
+CONFIG_OPENSSL_WITH_CHACHA_POLY1305=y
+CONFIG_OPENSSL_WITH_CMS=y
+CONFIG_OPENSSL_WITH_DEPRECATED=y
+CONFIG_OPENSSL_WITH_ERROR_MESSAGES=y
+CONFIG_OPENSSL_WITH_PSK=y
+CONFIG_OPENSSL_WITH_SRP=y
+CONFIG_OPENSSL_WITH_TLS13=y
+CONFIG_OPENVPN_openssl_ENABLE_DEF_AUTH=y
+CONFIG_OPENVPN_openssl_ENABLE_FRAGMENT=y
+CONFIG_OPENVPN_openssl_ENABLE_LZ4=y
+CONFIG_OPENVPN_openssl_ENABLE_MULTIHOME=y
+CONFIG_OPENVPN_openssl_ENABLE_PF=y
+CONFIG_OPENVPN_openssl_ENABLE_PORT_SHARE=y
+CONFIG_OPENVPN_openssl_ENABLE_SMALL=y
+CONFIG_PACKAGE_6in4=y
+CONFIG_PACKAGE_6rd=y
+CONFIG_PACKAGE_6to4=y
+CONFIG_PACKAGE_MAC80211_NSS_SUPPORT=y
+CONFIG_PACKAGE_NTFS-3G_HAS_PROBE=y
+CONFIG_PACKAGE_adblock=y
+CONFIG_PACKAGE_banip=y
+CONFIG_PACKAGE_bcp38=y
+CONFIG_PACKAGE_block-mount=y
+CONFIG_PACKAGE_ca-certificates=y
+CONFIG_PACKAGE_cgi-io=y
+CONFIG_PACKAGE_collectd=y
+CONFIG_PACKAGE_collectd-mod-conntrack=y
+CONFIG_PACKAGE_collectd-mod-cpu=y
+CONFIG_PACKAGE_collectd-mod-cpufreq=y
+CONFIG_PACKAGE_collectd-mod-dhcpleases=y
+CONFIG_PACKAGE_collectd-mod-entropy=y
+CONFIG_PACKAGE_collectd-mod-exec=y
+CONFIG_PACKAGE_collectd-mod-interface=y
+CONFIG_PACKAGE_collectd-mod-iwinfo=y
+CONFIG_PACKAGE_collectd-mod-load=y
+CONFIG_PACKAGE_collectd-mod-memory=y
+CONFIG_PACKAGE_collectd-mod-network=y
+CONFIG_PACKAGE_collectd-mod-ping=y
+CONFIG_PACKAGE_collectd-mod-rrdtool=y
+CONFIG_PACKAGE_collectd-mod-sqm=y
+CONFIG_PACKAGE_collectd-mod-thermal=y
+CONFIG_PACKAGE_collectd-mod-uptime=y
+CONFIG_PACKAGE_collectd-mod-wireless=y
+CONFIG_PACKAGE_coreutils=y
+CONFIG_PACKAGE_coreutils-sort=y
+CONFIG_PACKAGE_dawn=y
+CONFIG_PACKAGE_ddns-scripts=y
+CONFIG_PACKAGE_ddns-scripts-services=y
+CONFIG_PACKAGE_hostapd-utils=y
+CONFIG_PACKAGE_htop=y
+CONFIG_PACKAGE_ip-tiny=y
+CONFIG_PACKAGE_ip6tables-mod-nat=y
+CONFIG_PACKAGE_ipset=y
+CONFIG_PACKAGE_iptables-mod-conntrack-extra=y
+CONFIG_PACKAGE_iptables-mod-extra=y
+CONFIG_PACKAGE_iptables-mod-ipopt=y
+CONFIG_PACKAGE_iptables-mod-physdev=y
+CONFIG_PACKAGE_irqbalance=y
+CONFIG_PACKAGE_kmod-bonding=y
+CONFIG_PACKAGE_kmod-br-netfilter=y
+CONFIG_PACKAGE_kmod-crypto-acompress=y
+CONFIG_PACKAGE_kmod-crypto-aead=y
+CONFIG_PACKAGE_kmod-crypto-arc4=y
+CONFIG_PACKAGE_kmod-crypto-authenc=y
+CONFIG_PACKAGE_kmod-crypto-cbc=y
+CONFIG_PACKAGE_kmod-crypto-ccm=y
+CONFIG_PACKAGE_kmod-crypto-cmac=y
+CONFIG_PACKAGE_kmod-crypto-crc32c=y
+CONFIG_PACKAGE_kmod-crypto-ctr=y
+CONFIG_PACKAGE_kmod-crypto-deflate=y
+CONFIG_PACKAGE_kmod-crypto-des=y
+CONFIG_PACKAGE_kmod-crypto-ecb=y
+CONFIG_PACKAGE_kmod-crypto-echainiv=y
+CONFIG_PACKAGE_kmod-crypto-hash=y
+CONFIG_PACKAGE_kmod-crypto-hmac=y
+CONFIG_PACKAGE_kmod-crypto-manager=y
+CONFIG_PACKAGE_kmod-crypto-md4=y
+CONFIG_PACKAGE_kmod-crypto-md5=y
+CONFIG_PACKAGE_kmod-crypto-null=y
+CONFIG_PACKAGE_kmod-crypto-pcompress=y
+CONFIG_PACKAGE_kmod-crypto-rng=y
+CONFIG_PACKAGE_kmod-crypto-seqiv=y
+CONFIG_PACKAGE_kmod-crypto-sha1=y
+CONFIG_PACKAGE_kmod-crypto-sha256=y
+CONFIG_PACKAGE_kmod-crypto-sha512=y
+CONFIG_PACKAGE_kmod-cryptodev=y
+CONFIG_PACKAGE_kmod-fs-cifs=y
+CONFIG_PACKAGE_kmod-fs-exfat=y
+CONFIG_PACKAGE_kmod-fs-ext4=y
+CONFIG_PACKAGE_kmod-fs-hfsplus=y
+CONFIG_PACKAGE_kmod-fs-msdos=y
+CONFIG_PACKAGE_kmod-fs-vfat=y
+CONFIG_PACKAGE_kmod-fuse=y
+CONFIG_PACKAGE_kmod-ifb=y
+CONFIG_PACKAGE_kmod-ipsec=y
+CONFIG_PACKAGE_kmod-ipt-conntrack-extra=y
+CONFIG_PACKAGE_kmod-ipt-extra=y
+CONFIG_PACKAGE_kmod-ipt-ipopt=y
+CONFIG_PACKAGE_kmod-ipt-ipset=y
+CONFIG_PACKAGE_kmod-ipt-nat6=y
+CONFIG_PACKAGE_kmod-ipt-physdev=y
+CONFIG_PACKAGE_kmod-ipt-raw=y
+CONFIG_PACKAGE_kmod-iptunnel=y
+CONFIG_PACKAGE_kmod-iptunnel4=y
+CONFIG_PACKAGE_kmod-lib-crc16=y
+CONFIG_PACKAGE_kmod-lib-zlib-deflate=y
+CONFIG_PACKAGE_kmod-lib-zlib-inflate=y
+CONFIG_PACKAGE_kmod-nf-conntrack-netlink=y
+CONFIG_PACKAGE_kmod-nf-nat6=y
+CONFIG_PACKAGE_kmod-nfnetlink=y
+CONFIG_PACKAGE_kmod-nls-cp1250=y
+CONFIG_PACKAGE_kmod-nls-cp437=y
+CONFIG_PACKAGE_kmod-nls-cp850=y
+CONFIG_PACKAGE_kmod-nls-iso8859-1=y
+CONFIG_PACKAGE_kmod-nls-iso8859-15=y
+CONFIG_PACKAGE_kmod-nls-utf8=y
+CONFIG_PACKAGE_kmod-nss-ifb=y
+CONFIG_PACKAGE_kmod-qca-nss-drv=y
+CONFIG_PACKAGE_kmod-qca-nss-drv-pppoe=y
+CONFIG_PACKAGE_kmod-qca-nss-drv-qdisc=y
+CONFIG_PACKAGE_kmod-qca-nss-ecm-standard=y
+CONFIG_PACKAGE_kmod-qca-nss-gmac=y
+CONFIG_PACKAGE_kmod-sched-cake=y
+CONFIG_PACKAGE_kmod-sched-core=y
+CONFIG_PACKAGE_kmod-sit=y
+CONFIG_PACKAGE_kmod-tun=y
+CONFIG_PACKAGE_kmod-udptunnel4=y
+CONFIG_PACKAGE_kmod-udptunnel6=y
+CONFIG_PACKAGE_kmod-usb-storage=y
+CONFIG_PACKAGE_kmod-wireguard=y
+CONFIG_PACKAGE_libblkid=y
+CONFIG_PACKAGE_libelf=y
+CONFIG_PACKAGE_libgcrypt=y
+CONFIG_PACKAGE_libgpg-error=y
+CONFIG_PACKAGE_libipset=y
+CONFIG_PACKAGE_libiwinfo-lua=y
+CONFIG_PACKAGE_libltdl=y
+CONFIG_PACKAGE_liblua=y
+CONFIG_PACKAGE_liblucihttp=y
+CONFIG_PACKAGE_liblucihttp-lua=y
+CONFIG_PACKAGE_libmnl=y
+CONFIG_PACKAGE_libncurses=y
+CONFIG_PACKAGE_libopenssl=y
+CONFIG_PACKAGE_libopenssl-conf=y
+CONFIG_PACKAGE_libopenssl-devcrypto=y
+CONFIG_PACKAGE_liboping=y
+CONFIG_PACKAGE_librrd1=y
+CONFIG_PACKAGE_librt=y
+CONFIG_PACKAGE_libubus-lua=y
+CONFIG_PACKAGE_libustream-openssl=y
+CONFIG_PACKAGE_libustream-wolfssl=m
+CONFIG_PACKAGE_libuuid=y
+CONFIG_PACKAGE_libwolfssl=m
+CONFIG_PACKAGE_lua=y
+CONFIG_PACKAGE_luci=y
+CONFIG_PACKAGE_luci-app-adblock=y
+CONFIG_PACKAGE_luci-app-banip=y
+CONFIG_PACKAGE_luci-app-bcp38=y
+CONFIG_PACKAGE_luci-app-commands=y
+CONFIG_PACKAGE_luci-app-dawn=y
+CONFIG_PACKAGE_luci-app-ddns=y
+CONFIG_PACKAGE_luci-app-firewall=y
+CONFIG_PACKAGE_luci-app-nlbwmon=y
+CONFIG_PACKAGE_luci-app-openvpn=y
+CONFIG_PACKAGE_luci-app-opkg=y
+CONFIG_PACKAGE_luci-app-sqm=y
+CONFIG_PACKAGE_luci-app-statistics=y
+CONFIG_PACKAGE_luci-app-wireguard=y
+CONFIG_PACKAGE_luci-base=y
+CONFIG_PACKAGE_luci-compat=y
+CONFIG_PACKAGE_luci-lib-base=y
+CONFIG_PACKAGE_luci-lib-ip=y
+CONFIG_PACKAGE_luci-lib-ipkg=y
+CONFIG_PACKAGE_luci-lib-json=y
+CONFIG_PACKAGE_luci-lib-jsonc=y
+CONFIG_PACKAGE_luci-lib-nixio=y
+CONFIG_PACKAGE_luci-mod-admin-full=y
+CONFIG_PACKAGE_luci-mod-network=y
+CONFIG_PACKAGE_luci-mod-status=y
+CONFIG_PACKAGE_luci-mod-system=y
+CONFIG_PACKAGE_luci-proto-ipv6=y
+CONFIG_PACKAGE_luci-proto-ppp=y
+CONFIG_PACKAGE_luci-proto-wireguard=y
+CONFIG_PACKAGE_luci-ssl-openssl=y
+CONFIG_PACKAGE_luci-theme-bootstrap=y
+CONFIG_PACKAGE_luci-theme-openwrt-2020=y
+CONFIG_PACKAGE_nlbwmon=y
+CONFIG_PACKAGE_ntfs-3g=y
+CONFIG_PACKAGE_openssl-util=y
+CONFIG_PACKAGE_openvpn-openssl=y
+CONFIG_PACKAGE_rpcd=y
+CONFIG_PACKAGE_rpcd-mod-file=y
+CONFIG_PACKAGE_rpcd-mod-iwinfo=y
+CONFIG_PACKAGE_rpcd-mod-luci=y
+CONFIG_PACKAGE_rpcd-mod-rrdns=y
+CONFIG_PACKAGE_rrdtool1=y
+CONFIG_PACKAGE_sqm-scripts=y
+CONFIG_PACKAGE_tc=y
+CONFIG_PACKAGE_terminfo=y
+CONFIG_PACKAGE_uhttpd=y
+CONFIG_PACKAGE_uhttpd-mod-ubus=y
+CONFIG_PACKAGE_umdns=y
+CONFIG_PACKAGE_wireguard-tools=y
+CONFIG_PACKAGE_wpad-basic-wolfssl=m
+CONFIG_PACKAGE_wpad-openssl=y
+CONFIG_PACKAGE_zlib=y
+CONFIG_PREINITOPT=y
+CONFIG_TARGET_PREINIT_TIMEOUT=5
+CONFIG_WPA_MSG_MIN_PRIORITY=4
diff --git a/bin/targets/ipq806x/generic/feeds.buildinfo b/bin/targets/ipq806x/generic/feeds.buildinfo
new file mode 100644
index 0000000000..6e19db01d2
--- /dev/null
+++ b/bin/targets/ipq806x/generic/feeds.buildinfo
@@ -0,0 +1,4 @@
+src-git packages https://git.openwrt.org/feed/packages.git^1831941e7
+src-git luci https://git.openwrt.org/project/luci.git^988a896
+src-git routing https://git.openwrt.org/feed/routing.git^6f29856
+src-git telephony https://git.openwrt.org/feed/telephony.git^a419384
diff --git a/bin/targets/ipq806x/generic/openwrt-ipq806x-generic.manifest b/bin/targets/ipq806x/generic/openwrt-ipq806x-generic.manifest
new file mode 100644
index 0000000000..758fa04313
--- /dev/null
+++ b/bin/targets/ipq806x/generic/openwrt-ipq806x-generic.manifest
@@ -0,0 +1,280 @@
+6in4 - 26
+6rd - 10
+6to4 - 13
+adblock - 4.1.0-1
+banip - 0.7.3-1
+base-files - 1405-r15878+18-8b3d879861
+bcp38 - 5-6
+block-mount - 2021-01-04-c53b1882-1
+busybox - 1.33.0-1
+ca-bundle - 20210119-1
+ca-certificates - 20210119-1
+cgi-io - 2020-10-27-ab4c3471-19
+collectd - 5.12.0-7
+collectd-mod-conntrack - 5.12.0-7
+collectd-mod-cpu - 5.12.0-7
+collectd-mod-cpufreq - 5.12.0-7
+collectd-mod-dhcpleases - 5.12.0-7
+collectd-mod-entropy - 5.12.0-7
+collectd-mod-exec - 5.12.0-7
+collectd-mod-interface - 5.12.0-7
+collectd-mod-iwinfo - 5.12.0-7
+collectd-mod-load - 5.12.0-7
+collectd-mod-memory - 5.12.0-7
+collectd-mod-network - 5.12.0-7
+collectd-mod-ping - 5.12.0-7
+collectd-mod-rrdtool - 5.12.0-7
+collectd-mod-sqm - 5.12.0-7
+collectd-mod-thermal - 5.12.0-7
+collectd-mod-uptime - 5.12.0-7
+collectd-mod-wireless - 5.12.0-7
+coreutils - 8.32-6
+coreutils-sort - 8.32-6
+dawn - 2020-12-31-8ce09d64-1
+ddns-scripts - 2.8.2-7
+ddns-scripts-services - 2.8.2-7
+dnsmasq - 2.84-1
+dropbear - 2020.81-2
+firewall - 2020-09-05-8c2f9fad-1
+fstools - 2021-01-04-c53b1882-1
+fwtool - 2019-11-12-8f7fe925-1
+getrandom - 2020-10-25-9ef88681-1
+hostapd-common - 2020-06-08-5a8b3662-32
+hostapd-utils - 2020-06-08-5a8b3662-32
+htop - 3.0.5-1
+ip-tiny - 5.10.0-1
+ip6tables - 1.8.7-1
+ip6tables-mod-nat - 1.8.7-1
+ipset - 7.6-1
+iptables - 1.8.7-1
+iptables-mod-conntrack-extra - 1.8.7-1
+iptables-mod-extra - 1.8.7-1
+iptables-mod-ipopt - 1.8.7-1
+iptables-mod-physdev - 1.8.7-1
+irqbalance - 1.7.0-1
+iw - 5.9-1
+iwinfo - 2021-01-31-4a32b33e-1
+jshn - 2020-12-12-35787769-1
+jsonfilter - 2018-02-04-c7e938d6-1
+kernel - 5.4.102-1-c237bfa391adbb461d5b734fb701a4ea
+kmod-ata-ahci - 5.4.102-1
+kmod-ata-ahci-platform - 5.4.102-1
+kmod-ata-core - 5.4.102-1
+kmod-ath - 5.4.102+5.10.16-1-1
+kmod-ath10k-ct - 5.4.102+2021-01-11-9fe1df7d-2
+kmod-bonding - 5.4.102-1
+kmod-br-netfilter - 5.4.102-1
+kmod-cfg80211 - 5.4.102+5.10.16-1-1
+kmod-crypto-acompress - 5.4.102-1
+kmod-crypto-aead - 5.4.102-1
+kmod-crypto-arc4 - 5.4.102-1
+kmod-crypto-authenc - 5.4.102-1
+kmod-crypto-cbc - 5.4.102-1
+kmod-crypto-ccm - 5.4.102-1
+kmod-crypto-cmac - 5.4.102-1
+kmod-crypto-crc32c - 5.4.102-1
+kmod-crypto-ctr - 5.4.102-1
+kmod-crypto-deflate - 5.4.102-1
+kmod-crypto-des - 5.4.102-1
+kmod-crypto-ecb - 5.4.102-1
+kmod-crypto-echainiv - 5.4.102-1
+kmod-crypto-hash - 5.4.102-1
+kmod-crypto-hmac - 5.4.102-1
+kmod-crypto-manager - 5.4.102-1
+kmod-crypto-md4 - 5.4.102-1
+kmod-crypto-md5 - 5.4.102-1
+kmod-crypto-null - 5.4.102-1
+kmod-crypto-pcompress - 5.4.102-1
+kmod-crypto-rng - 5.4.102-1
+kmod-crypto-seqiv - 5.4.102-1
+kmod-crypto-sha1 - 5.4.102-1
+kmod-crypto-sha256 - 5.4.102-1
+kmod-crypto-sha512 - 5.4.102-1
+kmod-cryptodev - 5.4.102+1.11-ipq806x-1
+kmod-fs-cifs - 5.4.102-1
+kmod-fs-exfat - 5.4.102+5.10.1-1
+kmod-fs-ext4 - 5.4.102-1
+kmod-fs-hfsplus - 5.4.102-1
+kmod-fs-msdos - 5.4.102-1
+kmod-fs-vfat - 5.4.102-1
+kmod-fuse - 5.4.102-1
+kmod-gpio-button-hotplug - 5.4.102-3
+kmod-hwmon-core - 5.4.102-1
+kmod-ifb - 5.4.102-1
+kmod-ip6tables - 5.4.102-1
+kmod-ipsec - 5.4.102-1
+kmod-ipt-conntrack - 5.4.102-1
+kmod-ipt-conntrack-extra - 5.4.102-1
+kmod-ipt-core - 5.4.102-1
+kmod-ipt-extra - 5.4.102-1
+kmod-ipt-ipopt - 5.4.102-1
+kmod-ipt-ipset - 5.4.102-1
+kmod-ipt-nat - 5.4.102-1
+kmod-ipt-nat6 - 5.4.102-1
+kmod-ipt-offload - 5.4.102-1
+kmod-ipt-physdev - 5.4.102-1
+kmod-ipt-raw - 5.4.102-1
+kmod-iptunnel - 5.4.102-1
+kmod-iptunnel4 - 5.4.102-1
+kmod-leds-gpio - 5.4.102-1
+kmod-lib-crc-ccitt - 5.4.102-1
+kmod-lib-crc16 - 5.4.102-1
+kmod-lib-zlib-deflate - 5.4.102-1
+kmod-lib-zlib-inflate - 5.4.102-1
+kmod-mac80211 - 5.4.102+5.10.16-1-1
+kmod-nf-conntrack - 5.4.102-1
+kmod-nf-conntrack-netlink - 5.4.102-1
+kmod-nf-conntrack6 - 5.4.102-1
+kmod-nf-flow - 5.4.102-1
+kmod-nf-ipt - 5.4.102-1
+kmod-nf-ipt6 - 5.4.102-1
+kmod-nf-nat - 5.4.102-1
+kmod-nf-nat6 - 5.4.102-1
+kmod-nf-reject - 5.4.102-1
+kmod-nf-reject6 - 5.4.102-1
+kmod-nfnetlink - 5.4.102-1
+kmod-nls-base - 5.4.102-1
+kmod-nls-cp1250 - 5.4.102-1
+kmod-nls-cp437 - 5.4.102-1
+kmod-nls-cp850 - 5.4.102-1
+kmod-nls-iso8859-1 - 5.4.102-1
+kmod-nls-iso8859-15 - 5.4.102-1
+kmod-nls-utf8 - 5.4.102-1
+kmod-nss-ifb - 5.4.102-1
+kmod-phy-qcom-ipq806x-usb - 5.4.102-1
+kmod-ppp - 5.4.102-1
+kmod-pppoe - 5.4.102-1
+kmod-pppox - 5.4.102-1
+kmod-qca-nss-drv - 5.4.102+809a00de-2
+kmod-qca-nss-drv-pppoe - 5.4.102+740d0102-2
+kmod-qca-nss-drv-qdisc - 5.4.102+740d0102-2
+kmod-qca-nss-ecm-standard - 5.4.102+9228212b-1
+kmod-qca-nss-gmac - 5.4.102+9b74deef-1
+kmod-sched-cake - 5.4.102-1
+kmod-sched-core - 5.4.102-1
+kmod-scsi-core - 5.4.102-1
+kmod-sit - 5.4.102-1
+kmod-slhc - 5.4.102-1
+kmod-tun - 5.4.102-1
+kmod-udptunnel4 - 5.4.102-1
+kmod-udptunnel6 - 5.4.102-1
+kmod-usb-core - 5.4.102-1
+kmod-usb-dwc3 - 5.4.102-1
+kmod-usb-dwc3-qcom - 5.4.102-1
+kmod-usb-ehci - 5.4.102-1
+kmod-usb-ledtrig-usbport - 5.4.102-1
+kmod-usb-ohci - 5.4.102-1
+kmod-usb-storage - 5.4.102-1
+kmod-usb2 - 5.4.102-1
+kmod-usb3 - 5.4.102-1
+kmod-wireguard - 5.4.102+1.0.20201112-1
+libblkid1 - 2.36.1-2
+libblobmsg-json20201212 - 2020-12-12-35787769-1
+libc - 1.1.24-3
+libelf1 - 0.180-1
+libgcc1 - 8.4.0-3
+libgcrypt - 1.8.7-2
+libgpg-error - 1.39-2
+libip4tc2 - 1.8.7-1
+libip6tc2 - 1.8.7-1
+libipset13 - 7.6-1
+libiwinfo-lua - 2021-01-31-4a32b33e-1
+libiwinfo20210106 - 2021-01-31-4a32b33e-1
+libjson-c5 - 0.15-1
+libjson-script20201212 - 2020-12-12-35787769-1
+libltdl7 - 2.4.6-2
+liblua5.1.5 - 5.1.5-8
+liblucihttp-lua - 2019-07-05-a34a17d5-1
+liblucihttp0 - 2019-07-05-a34a17d5-1
+libmnl0 - 1.0.4-2
+libncurses6 - 6.2-1
+libnl-tiny1 - 2020-08-05-c291088f-1
+libopenssl-conf - 1.1.1j-1
+libopenssl-devcrypto - 1.1.1j-1
+libopenssl1.1 - 1.1.1j-1
+liboping - 1.10.0-2
+libpthread - 1.1.24-3
+librrd1 - 1.0.50-3
+librt - 1.1.24-3
+libubox20201212 - 2020-12-12-35787769-1
+libubus-lua - 2021-02-15-2537be01-1
+libubus20210215 - 2021-02-15-2537be01-1
+libuci20130104 - 2020-10-06-52bbc99f-4
+libuclient20201210 - 2020-12-10-2c843b2b-1
+libustream-openssl20201210 - 2020-12-10-68d09243-1
+libuuid1 - 2.36.1-2
+libxtables12 - 1.8.7-1
+logd - 2020-10-25-9ef88681-1
+lua - 5.1.5-8
+luci - git-21.058.23678-d551587
+luci-app-adblock - git-21.058.23678-d551587
+luci-app-banip - git-21.062.56276-2e1f950
+luci-app-bcp38 - git-21.058.23678-d551587
+luci-app-commands - git-21.058.23678-d551587
+luci-app-dawn - git-21.058.23678-d551587
+luci-app-ddns - git-21.058.23678-d551587
+luci-app-firewall - git-21.060.51546-4935525
+luci-app-nlbwmon - git-21.060.34261-628a1b8
+luci-app-openvpn - git-21.058.23678-d551587
+luci-app-opkg - git-21.058.23678-d551587
+luci-app-sqm - git-21.058.23678-d551587
+luci-app-statistics - git-21.058.23678-d551587
+luci-app-wireguard - git-21.058.23678-d551587
+luci-base - git-21.060.51546-bd39e6a
+luci-compat - git-21.058.23678-d551587
+luci-lib-base - git-21.058.23678-d551587
+luci-lib-ip - git-21.058.23678-d551587
+luci-lib-ipkg - git-21.058.23678-d551587
+luci-lib-json - git-21.058.23678-d551587
+luci-lib-jsonc - git-21.058.23678-d551587
+luci-lib-nixio - git-21.058.23678-d551587
+luci-mod-admin-full - git-21.058.23678-d551587
+luci-mod-network - git-21.058.23678-d551587
+luci-mod-status - git-21.058.23678-d551587
+luci-mod-system - git-21.058.23678-d551587
+luci-proto-ipv6 - git-21.058.23678-d551587
+luci-proto-ppp - git-21.058.23678-d551587
+luci-proto-wireguard - git-21.058.23678-d551587
+luci-ssl-openssl - git-21.058.23678-d551587
+luci-theme-bootstrap - git-21.058.23678-d551587
+luci-theme-openwrt-2020 - git-21.058.23678-d551587
+mtd - 26
+netifd - 2021-01-09-c00c8335-1
+nlbwmon - 2020-04-11.1-34a18876-3
+ntfs-3g - 2017.3.23-4-fuseint
+odhcp6c - 2021-01-09-53f07e90-16
+odhcpd-ipv6only - 2021-01-06-8d8a8cd3-2
+openssl-util - 1.1.1j-1
+openvpn-openssl - 2.5.0-2
+openwrt-keyring - 2021-02-20-49283916-1
+opkg - 2020-12-24-9bbc7eae-1
+ppp - 2.4.8.git-2020-10-03-3
+ppp-mod-pppoe - 2.4.8.git-2020-10-03-3
+procd - 2021-02-08-08938fe1-2
+rpcd - 2021-01-06-ea7f4717-1
+rpcd-mod-file - 2021-01-06-ea7f4717-1
+rpcd-mod-iwinfo - 2021-01-06-ea7f4717-1
+rpcd-mod-luci - 20201107
+rpcd-mod-rrdns - 20170710
+rrdtool1 - 1.0.50-3
+sqm-scripts - 1.5.0-2
+swconfig - 12
+tc - 5.10.0-1
+terminfo - 6.2-1
+ubi-utils - 2.1.2-1
+uboot-envtools - 2021.01-2
+ubox - 2020-10-25-9ef88681-1
+ubus - 2021-02-15-2537be01-1
+ubusd - 2021-02-15-2537be01-1
+uci - 2020-10-06-52bbc99f-4
+uclient-fetch - 2020-12-10-2c843b2b-1
+uhttpd - 2020-11-23-f53a6399-1
+uhttpd-mod-ubus - 2020-11-23-f53a6399-1
+umdns - 2021-01-26-78aa36b0-1
+urandom-seed - 3
+urngd - 2020-01-21-c7f7b6b6-1
+usign - 2020-05-23-f1f65026-1
+wireguard-tools - 1.0.20200827-2
+wireless-regdb - 2020.11.20-1
+wpad-openssl - 2020-06-08-5a8b3662-32
+zlib - 1.2.11-3
diff --git a/bin/targets/ipq806x/generic/packages/Packages b/bin/targets/ipq806x/generic/packages/Packages
new file mode 100644
index 0000000000..77450ed087
--- /dev/null
+++ b/bin/targets/ipq806x/generic/packages/Packages
@@ -0,0 +1,1812 @@
+Package: base-files
+Version: 1405-r15878+18-8b3d879861
+Depends: libc, netifd, jsonfilter, usign, openwrt-keyring, ubi-utils, fstools, fwtool
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 49173
+Filename: base-files_1405-r15878+18-8b3d879861_arm_cortex-a15_neon-vfpv4.ipk
+Size: 50206
+SHA256sum: 83977cecfd8af5bf44864c0942033375b592b38f0afe884c33a1fdf4788754d9
+Description:  This package contains a base filesystem and system scripts for OpenWrt.
+
+Package: block-mount
+Version: 2021-01-04-c53b1882-1
+Depends: libc, ubox, libubox20201212, libuci20130104, libblobmsg-json20201212, libjson-c5
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 26272
+Filename: block-mount_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 27035
+SHA256sum: b8d4a1a5d5ea21c59ee6fcc087eba26a38236589af9a25f1e79e4bb2370b1499
+Description:  Block device mounting and checking
+
+Package: dropbear
+Version: 2020.81-2
+Depends: libc
+Alternatives: 100:/usr/bin/scp:/usr/sbin/dropbear, 100:/usr/bin/ssh:/usr/sbin/dropbear
+License: MIT
+Section: net
+CPE-ID: cpe:/a:matt_johnston:dropbear_ssh_server
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 108027
+Filename: dropbear_2020.81-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 108814
+SHA256sum: 2db973b80009065898eb40ce6f90f4f41198da790aed96bc4603c387a75c4680
+Description:  A small SSH2 server/client designed for small memory environments.
+
+Package: fstools
+Version: 2021-01-04-c53b1882-1
+Depends: libc, ubox, ubi-utils
+License: GPL-2.0
+Section: base
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 15271
+Filename: fstools_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15974
+SHA256sum: c2860c1175d920104dc4b3af10b804181b0265cd95e24c941130204e525c8686
+Description:  OpenWrt filesystem tools
+
+Package: fwtool
+Version: 2019-11-12-8f7fe925-1
+Depends: libc
+License: GPL-2.0
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3767
+Filename: fwtool_2019-11-12-8f7fe925-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4538
+SHA256sum: cc081ccf30967ee35986cf9ee85572fc68590fdbe1cd743ad9e805897b27b081
+Description:  Utility for appending and extracting firmware metadata and signatures
+
+Package: ip6tables-mod-nat
+Version: 1.8.7-1
+Depends: libc, ip6tables, kmod-ipt-nat6
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1473
+Filename: ip6tables-mod-nat_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2260
+SHA256sum: 373f4ae586f583d26782fe153d84c04b879180cc05cec9b59a56d5386b04bced
+Description:  iptables extensions for IPv6-NAT targets.
+
+Package: ip6tables
+Version: 1.8.7-1
+Depends: libc, kmod-ip6tables, iptables
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 218
+Filename: ip6tables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 978
+SHA256sum: 88e8966ba0406a7546286d7bfac25a03ddc7dcca734ddd763c3406dbfb5a9c3b
+Description:  IPv6 firewall administration tool
+
+Package: iptables-mod-conntrack-extra
+Version: 1.8.7-1
+Depends: libc, iptables, kmod-ipt-conntrack-extra, kmod-ipt-raw
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10546
+Filename: iptables-mod-conntrack-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11403
+SHA256sum: 8ab695e7f93c1ef53ed3830dd478cdf02f10ef53589bab730f53a41d1983e845
+Description:  Extra iptables extensions for connection tracking.
+ 
+ Matches:
+ - connbytes
+ - connlimit
+ - connmark
+ - recent
+ - helper
+ 
+ Targets:
+ - CONNMARK
+ 
+
+Package: iptables-mod-extra
+Version: 1.8.7-1
+Depends: libc, iptables, kmod-ipt-extra
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7197
+Filename: iptables-mod-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8016
+SHA256sum: c4b2dba00c4fb499d656ec7759db8e2f40d292350992569eb05e4d949df75485
+Description:  Other extra iptables extensions.
+ 
+ Matches:
+ - addrtype
+ - condition
+ - owner
+ - pkttype
+ - quota
+ 
+
+Package: iptables-mod-ipopt
+Version: 1.8.7-1
+Depends: libc, iptables, kmod-ipt-ipopt
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12162
+Filename: iptables-mod-ipopt_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12952
+SHA256sum: ff1d6fcd733e1387114ff80299b78493ebe2efd4ef1f59f00c74adba4fa76523
+Description:  iptables extensions for matching/changing IP packet options.
+ 
+ Matches:
+ - dscp
+ - ecn
+ - length
+ - statistic
+ - tcpmss
+ - unclean
+ - hl
+ 
+ Targets:
+ - DSCP
+ - CLASSIFY
+ - ECN
+ - HL
+ 
+
+Package: iptables-mod-physdev
+Version: 1.8.7-1
+Depends: libc, iptables, kmod-ipt-physdev
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1772
+Filename: iptables-mod-physdev_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2552
+SHA256sum: 16e3f076794ddc6af9333d7e2824ac49b96a45013beaf4a2213c993bdf0acf59
+Description:  The iptables physdev match.
+
+Package: iptables
+Version: 1.8.7-1
+Depends: libc, kmod-ipt-core, libip4tc2, libip6tc2, libxtables12
+License: GPL-2.0
+Section: net
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 24415
+Filename: iptables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 25225
+SHA256sum: f5781b9a7cb783806f90fd67710dc0e7d2a43a476dffed87c281259a7d61440e
+Description:  IP firewall administration tool.
+ 
+ Matches:
+ - icmp
+ - tcp
+ - udp
+ - comment
+ - conntrack
+ - limit
+ - mac
+ - mark
+ - multiport
+ - set
+ - state
+ - time
+ 
+ Targets:
+ - ACCEPT
+ - CT
+ - DNAT
+ - DROP
+ - REJECT
+ - FLOWOFFLOAD
+ - LOG
+ - MARK
+ - MASQUERADE
+ - REDIRECT
+ - SET
+ - SNAT
+ - TCPMSS
+ 
+ Tables:
+ - filter
+ - mangle
+ - nat
+ - raw
+ 
+
+Package: iwinfo
+Version: 2021-01-31-4a32b33e-1
+Depends: libc, libiwinfo20210106
+License: GPL-2.0
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7017
+Filename: iwinfo_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7849
+SHA256sum: f807c42b566ac6e3caacd653ca25015c0b14ef3e8ca700eb31057df2f47a39c7
+Description:  Command line frontend for the wireless information library.
+
+Package: kmod-ata-ahci-platform
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ata-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6280
+Filename: kmod-ata-ahci-platform_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7109
+SHA256sum: 2d037f74594c94a991052d2ce337a39226de1214ba714625452e253ecc04f474
+Description:  Platform support for AHCI Serial ATA controllers
+
+Package: kmod-ata-ahci
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ata-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6719
+Filename: kmod-ata-ahci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7526
+SHA256sum: 80fb0633603a17d30f986c114af707f215d9c50b1a184cda1a20982964430328
+Description:  Support for AHCI Serial ATA controllers
+
+Package: kmod-ata-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-scsi-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104068
+Filename: kmod-ata-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 103995
+SHA256sum: 68547fcea0aa5d89f8b1bae23e2bcf1ab171bd7ea8eed5c1d0016f9979a9907e
+Description:  Serial and Parallel ATA support
+
+Package: kmod-ath10k-ct
+Version: 5.4.102+2021-01-11-9fe1df7d-2
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-mac80211, kmod-ath, kmod-hwmon-core
+Provides: kmod-ath10k
+License: GPLv2
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 246390
+Filename: kmod-ath10k-ct_5.4.102+2021-01-11-9fe1df7d-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 244655
+SHA256sum: 85defa6143e3864c5248e75873e82633db0c35bcf16e02bb306f66520f9f17a3
+Description:  ath10k-ct driver optimized for CT ath10k firmware
+
+Package: kmod-ath
+Version: 5.4.102+5.10.16-1-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-mac80211
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12420
+Filename: kmod-ath_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13128
+SHA256sum: 196608a52b9b2a41c54df4196bae63f4fd452999dd0be9caafcca6e1ddd5dbe8
+Description:  This module contains some common parts needed by Atheros Wireless drivers.
+
+Package: kmod-bonding
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 63358
+Filename: kmod-bonding_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 63909
+SHA256sum: 38daa93bf4ad181e20d90e0f1a367409ee8189055f7d4207440037d9fecc4d8c
+Description:  Kernel module for NIC bonding.
+
+Package: kmod-br-netfilter
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 385
+Filename: kmod-br-netfilter_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1157
+SHA256sum: ac014d6c92e452132efebb379fefcacdc77e912c4dc357ce52abc671cc6d10df
+Description:  Bridge netfilter support modules
+
+Package: kmod-cfg80211
+Version: 5.4.102+5.10.16-1-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), iw, wireless-regdb
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 164313
+Filename: kmod-cfg80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 164438
+SHA256sum: a5557225f7c5fc9337c7c30b840e8f201ab9f6c655ac1f54a0619cd01155b4f0
+Description:  cfg80211 is the Linux wireless LAN (802.11) configuration API.
+
+Package: kmod-crypto-acompress
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 199
+Filename: kmod-crypto-acompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 953
+SHA256sum: 3f2c102ce5b8cee93d02eea3814c65a7ee2533ba8f22990c969ce9fe923b7bc5
+Description:  Asynchronous Compression operations
+
+Package: kmod-crypto-aead
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-null
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 233
+Filename: kmod-crypto-aead_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 983
+SHA256sum: 163f36c59520646ee148d0c25fbb0bdefd8e4b18d25bc41de74264fbe66303ea
+Description:  CryptoAPI AEAD support
+
+Package: kmod-crypto-arc4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1354
+Filename: kmod-crypto-arc4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2138
+SHA256sum: bf21bc1e39877e18c122c1b92ecf275d05f1d472a1d04e017144bcf38bb4fb18
+Description:  ARC4 cipher CryptoAPI module
+
+Package: kmod-crypto-authenc
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-manager, kmod-crypto-null
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3933
+Filename: kmod-crypto-authenc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4700
+SHA256sum: 0673264226228fb73b1e9c8604a24d9f7e0815f060189caf51183fae9b874b92
+Description:  Combined mode wrapper for IPsec
+
+Package: kmod-crypto-cbc
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-manager
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2073
+Filename: kmod-crypto-cbc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2828
+SHA256sum: 8bb97732790895aaf4dde15842f5632ed1e6f16f1bc281aee0847f01cbd81cf7
+Description:  Cipher Block Chaining CryptoAPI module
+
+Package: kmod-crypto-ccm
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-ctr, kmod-crypto-aead
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6554
+Filename: kmod-crypto-ccm_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7380
+SHA256sum: c58f81748d4aa60a7af324ba3265c0da6b6f36412c591e55dc7dc1a1686d39f6
+Description:  Support for Counter with CBC MAC (CCM)
+
+Package: kmod-crypto-cmac
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2681
+Filename: kmod-crypto-cmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3462
+SHA256sum: d69e0c5f42a458878e92014ce02818e527eecfb5e4fe3461ea42b9e2bfc80502
+Description:  Support for Cipher-based Message Authentication Code (CMAC)
+
+Package: kmod-crypto-crc32c
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1553
+Filename: kmod-crypto-crc32c_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2301
+SHA256sum: b36ea82891618f0e6df0d30f02aaded19d8fb53edf93b179eb9fed4fddd0db3b
+Description:  CRC32c CRC module
+
+Package: kmod-crypto-ctr
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-manager, kmod-crypto-seqiv
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2981
+Filename: kmod-crypto-ctr_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3739
+SHA256sum: 2d59b9c50776253df0b5415f20159853a0475c47c67962c43e9255818398019f
+Description:  Counter Mode CryptoAPI module
+
+Package: kmod-crypto-deflate
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-lib-zlib-inflate, kmod-lib-zlib-deflate, kmod-crypto-acompress
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 193
+Filename: kmod-crypto-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 970
+SHA256sum: 8d800bea0a2b9d82a59212cc54fbcfe45dab98b025bdd59d1f35dd26ba4292da
+Description:  Deflate compression CryptoAPI module
+
+Package: kmod-crypto-des
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 9540
+Filename: kmod-crypto-des_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10132
+SHA256sum: 7b5b1d9af7d2cc3f601695d441276f9f277215968f0219375c2bd3a1cbd94663
+Description:  DES/3DES cipher CryptoAPI module
+
+Package: kmod-crypto-ecb
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-manager
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1577
+Filename: kmod-crypto-ecb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2369
+SHA256sum: dd36280c7f3e4f9eabec34f96dc84eaf889301c1d27bd1c16c0347d841b3bc59
+Description:  Electronic CodeBook CryptoAPI module
+
+Package: kmod-crypto-echainiv
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-aead
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2205
+Filename: kmod-crypto-echainiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2960
+SHA256sum: 4dad303173a67e677a91097388646db75ac4d6bac86832d7cb3f95d140699151
+Description:  Encrypted Chain IV Generator
+
+Package: kmod-crypto-hash
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 242
+Filename: kmod-crypto-hash_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 994
+SHA256sum: e65ddfb03e5e72ed64d1f6607f0dc6e1612ff693630f03c4c1c8f94e011f3a6b
+Description:  CryptoAPI hash support
+
+Package: kmod-crypto-hmac
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash, kmod-crypto-manager
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 191
+Filename: kmod-crypto-hmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 954
+SHA256sum: a908a7480e0a96cc240c24d66006f5ee459255aa2093a70cd24f9eb82383faf9
+Description:  HMAC digest CryptoAPI module
+
+Package: kmod-crypto-manager
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-aead, kmod-crypto-hash, kmod-crypto-pcompress
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 241
+Filename: kmod-crypto-manager_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1008
+SHA256sum: 48b581c7ee4afd19cdee2be6dd36a5f3b0a81e212e08a8a90b55e7b41803ea90
+Description:  CryptoAPI algorithm manager
+
+Package: kmod-crypto-md4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2986
+Filename: kmod-crypto-md4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3743
+SHA256sum: 95d7afdada0504a72d0cdb62f0047906c6964fb89b81c6038e6a83d1a2276ff6
+Description:  MD4 digest CryptoAPI module
+
+Package: kmod-crypto-md5
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3898
+Filename: kmod-crypto-md5_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4653
+SHA256sum: 5998b84d2fd1d145701f13bef34bafa4882d5a9e1e5a55b9691ff34ad2a7061e
+Description:  MD5 digest CryptoAPI module
+
+Package: kmod-crypto-null
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 196
+Filename: kmod-crypto-null_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 949
+SHA256sum: 10a7835f513fec61327b68f4821c1b0af89507385704450bc3586bec81e45992
+Description:  Null CryptoAPI module
+
+Package: kmod-crypto-pcompress
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-crypto-pcompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 858
+SHA256sum: 83f3e0b69faf350f3f512aa696d43474a17075f32e3c8eca71aa9652fff4364a
+Description:  CryptoAPI Partial (de)compression operations
+
+Package: kmod-crypto-rng
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash, kmod-crypto-hmac, kmod-crypto-sha256
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 208
+Filename: kmod-crypto-rng_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 979
+SHA256sum: 4266b796178facd1a938547df652a882677173f926a421c5b7913417640a9911
+Description:  CryptoAPI random number generation
+
+Package: kmod-crypto-seqiv
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-aead, kmod-crypto-rng
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2356
+Filename: kmod-crypto-seqiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3128
+SHA256sum: abb8776c38ff6e8a4cc072a5b34fb942e28142df715359a146e44c1657d41285
+Description:  CryptoAPI Sequence Number IV Generator
+
+Package: kmod-crypto-sha1
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2277
+Filename: kmod-crypto-sha1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3030
+SHA256sum: b904f11bfde4feea58fdcf1897b5d9030a87730548729f6919bd3e7b3e9e060e
+Description:  SHA1 digest CryptoAPI module
+
+Package: kmod-crypto-sha256
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 202
+Filename: kmod-crypto-sha256_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 966
+SHA256sum: 257ee25d4931cead4d620e24a8c1513f6495116bbf3f374ef471747af5695e78
+Description:  SHA224 SHA256 digest CryptoAPI module
+
+Package: kmod-crypto-sha512
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6894
+Filename: kmod-crypto-sha512_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7719
+SHA256sum: 788e59c535d2a56110ffaa2e2f4b90cc772f1095ea6506c32ed29145f6450752
+Description:  SHA512 digest CryptoAPI module
+
+Package: kmod-cryptodev
+Version: 5.4.102+1.11-ipq806x-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-authenc, kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 21704
+Filename: kmod-cryptodev_5.4.102+1.11-ipq806x-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 22454
+SHA256sum: 4877f2b699345470b949ba57074ddf5d63864986be0400d8b06b571a3e66c971
+Description:  This is a driver for that allows to use the Linux kernel supported
+ hardware ciphers by user-space applications.
+
+Package: kmod-fs-cifs
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base, kmod-crypto-md4, kmod-crypto-md5, kmod-crypto-sha256, kmod-crypto-sha512, kmod-crypto-cmac, kmod-crypto-hmac, kmod-crypto-arc4, kmod-crypto-aead, kmod-crypto-ccm, kmod-crypto-ecb, kmod-crypto-des
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 221682
+Filename: kmod-fs-cifs_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 218835
+SHA256sum: ae5d9c62de306d81b68a4e137e7d3c7dfee61eafb85788790087aa2d4870c945
+Description:  Kernel module for CIFS support
+
+Package: kmod-fs-exfat
+Version: 5.4.102+5.10.1-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+License: GPL-2.0-only
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 40663
+Filename: kmod-fs-exfat_5.4.102+5.10.1-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 41360
+SHA256sum: 6fb3dbe6ea9f5648d974a8d61c6ec8408604d0514caad5d48129468a3f3fee09
+Description:  exFAT kernel module
+
+Package: kmod-fs-ext4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-lib-crc16, kmod-crypto-hash, kmod-crypto-crc32c
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 278619
+Filename: kmod-fs-ext4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 277398
+SHA256sum: 1f6abd1bcc96d82a7e4b76417e7248e899f12b0d44f695f07f243afefbc30859
+Description:  Kernel module for EXT4 filesystem support
+
+Package: kmod-fs-hfsplus
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base, kmod-nls-utf8
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 57711
+Filename: kmod-fs-hfsplus_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 58328
+SHA256sum: 1791a40f323613ebd2fabb5ec100bb5928ab7eaa97c8ceb9ddd9bb366cb0403d
+Description:  Kernel module for HFS+ filesystem support
+
+Package: kmod-fs-msdos
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-fs-vfat, kmod-nls-base
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5494
+Filename: kmod-fs-msdos_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6284
+SHA256sum: 955d41f0ccb62c70b56a57af6ca33caa5c2300ff4b3588ef47a9fc8f8726a610
+Description:  Kernel module for MSDOS filesystem support
+
+Package: kmod-fs-vfat
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base, kmod-nls-cp437, kmod-nls-iso8859-1, kmod-nls-utf8
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 45214
+Filename: kmod-fs-vfat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 45876
+SHA256sum: 6c6fd94cfc1c8fbb562b0443be70beccf4c5eb6172e9616004b6756feb1f6ee1
+Description:  Kernel module for VFAT filesystem support
+
+Package: kmod-fuse
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 55713
+Filename: kmod-fuse_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 56249
+SHA256sum: 3b3efc296415a5fac1da1c1a373a493b1c88d53f0ff4034aa3203f0f18c03388
+Description:  Kernel module for userspace filesystem support
+
+Package: kmod-gpio-button-hotplug
+Version: 5.4.102-3
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6354
+Filename: kmod-gpio-button-hotplug_5.4.102-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7316
+SHA256sum: 3454ec40ee252d1c18b135d9b293a9a14e1eec3628f2786839af8034f3d2cee3
+Description:  This is a replacement for the following in-kernel drivers:
+ 1) gpio_keys (KEYBOARD_GPIO)
+ 2) gpio_keys_polled (KEYBOARD_GPIO_POLLED)
+ 
+ Instead of generating input events (like in-kernel drivers do) it generates
+ uevent-s and broadcasts them. This allows disabling input subsystem which is
+ an overkill for OpenWrt simple needs.
+
+Package: kmod-hwmon-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-hwmon-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 854
+SHA256sum: b3980a2d060c18007e0942bb0f988d5dd625ccf67a60c9470da70c06b5530714
+Description:  Kernel modules for hardware monitoring
+
+Package: kmod-i2c-algo-bit
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-i2c-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4060
+Filename: kmod-i2c-algo-bit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4829
+SHA256sum: 4eeaf5a05c70ba0ce9c4b190e0d84d837cdc2c16300f2f0b33b06c7017d95ea3
+Description:  Kernel modules for I2C bit-banging interfaces
+
+Package: kmod-i2c-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 194
+Filename: kmod-i2c-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 939
+SHA256sum: 9efd996ea6c309df0814410edf35e267a5a398881a86fce6ebcb32c83694fcc9
+Description:  Kernel modules for I2C support
+
+Package: kmod-i2c-gpio
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-i2c-algo-bit
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2895
+Filename: kmod-i2c-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3711
+SHA256sum: 16a5f0fd7948f6ff8d06327ca162902a632fa6df8377cabd888075dd321ff4f5
+Description:  Kernel modules for a very simple bitbanging I2C driver utilizing the
+ arch-neutral GPIO API to control the SCL and SDA lines.
+
+Package: kmod-ifb
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3893
+Filename: kmod-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4640
+SHA256sum: d1fb584bbcd365d42b1022061d896f8c206e370a5e90e62071d644b4d4e763fb
+Description:  The Intermediate Functional Block
+
+Package: kmod-ip6tables
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-reject6, kmod-nf-ipt6, kmod-ipt-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7811
+Filename: kmod-ip6tables_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8579
+SHA256sum: 23910a0ae9f1d0c6a08ccf407218e3b13e95430fb608ac1a08b08f871b3a4df7
+Description:  Netfilter IPv6 firewalling support
+
+Package: kmod-ipsec
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-authenc, kmod-crypto-cbc, kmod-crypto-deflate, kmod-crypto-des, kmod-crypto-echainiv, kmod-crypto-hmac, kmod-crypto-md5, kmod-crypto-sha1
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 36675
+Filename: kmod-ipsec_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 37576
+SHA256sum: 8a658080c9bd7cbd45bbb02937594ccf4b08ddcee31b41c37c4f2d5ffbc51b84
+Description:  Kernel modules for IPsec support in both IPv4 and IPv6.
+ Includes:
+ - af_key
+ - xfrm_algo
+ - xfrm_ipcomp
+ - xfrm_user
+
+Package: kmod-ipt-conntrack-extra
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-ipt-conntrack
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 15883
+Filename: kmod-ipt-conntrack-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 16687
+SHA256sum: 537466b8e846548416c708332afbc3d51dd265a4a6667048a05c4a1ffc00a679
+Description:  Netfilter (IPv4) extra kernel modules for connection tracking
+ Includes:
+ - connbytes
+ - connmark/CONNMARK
+ - conntrack
+ - helper
+ - recent
+
+Package: kmod-ipt-conntrack
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nf-conntrack
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5683
+Filename: kmod-ipt-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6511
+SHA256sum: decb42de6a8e98741caf5e56c1b76feb79d808e1822d1a12b440b133fa1ec2d0
+Description:  Netfilter (IPv4) kernel modules for connection tracking
+ Includes:
+ - conntrack
+ - defrag
+ - iptables_raw
+ - NOTRACK
+ - state
+
+Package: kmod-ipt-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-reject, kmod-nf-ipt
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19087
+Filename: kmod-ipt-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19914
+SHA256sum: 499d2f2d7535e8a9c2fd166b0d7ff402eb1785c192f7b90d32e33e3bcb8dde82
+Description:  Netfilter core kernel modules
+ Includes:
+ - comment
+ - limit
+ - LOG
+ - mac
+ - multiport
+ - REJECT
+ - TCPMSS
+
+Package: kmod-ipt-extra
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4949
+Filename: kmod-ipt-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5735
+SHA256sum: 38c1efef70579d036bb29f86b7789d9e7bdee1aab477a0d1a6aa52b6f38b2c07
+Description:  Other Netfilter (IPv4) kernel modules
+ Includes:
+ - addrtype
+ - owner
+ - pkttype
+ - quota
+
+Package: kmod-ipt-ipopt
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8420
+Filename: kmod-ipt-ipopt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9270
+SHA256sum: 71d3990c99783a35b8e8ccea830d8775c236253aa1d1217cf919d6ea9d814963
+Description:  Netfilter (IPv4) modules for matching/changing IP packet options
+ Includes:
+ - CLASSIFY
+ - dscp/DSCP
+ - ecn/ECN
+ - hl/HL
+ - length
+ - mark/MARK
+ - statistic
+ - tcpmss
+ - time
+ - ttl/TTL
+ - unclean
+
+Package: kmod-ipt-ipset
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nfnetlink
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 190089
+Filename: kmod-ipt-ipset_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 190471
+SHA256sum: 7d6e90709a3415a661e249d454bad296492478fff2e5a8f63cf6e0a3859111ae
+Description:  IPset netfilter modules
+
+Package: kmod-ipt-nat6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nf-nat6, kmod-ipt-core, kmod-ipt-conntrack, kmod-ipt-core, kmod-ipt-nat, kmod-ipt-core, kmod-ip6tables
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3200
+Filename: kmod-ipt-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4009
+SHA256sum: dddd9df85d36c8dd4b5a533f205ef85dc18616d2e61609103e3b0eef4d2711e7
+Description:  Netfilter (IPv6) kernel modules for NAT targets
+
+Package: kmod-ipt-nat
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nf-nat
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4897
+Filename: kmod-ipt-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5697
+SHA256sum: 23662a9b9f863228f487dea0e27b03df1438b5e0bd1bf715b9c6c54ec87f2e51
+Description:  Netfilter (IPv4) kernel modules for basic NAT targets
+ Includes:
+ - MASQUERADE
+
+Package: kmod-ipt-offload
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nf-flow
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3681
+Filename: kmod-ipt-offload_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4444
+SHA256sum: 60d11bc909d19b3ad22d11da1e0d16b6a111107d7fef4b43c83d1244ac46946b
+Description:  Netfilter routing/NAT offload support
+
+Package: kmod-ipt-physdev
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-br-netfilter
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2116
+Filename: kmod-ipt-physdev_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2876
+SHA256sum: e3c107bdce6809dfa6e135a7e6dd90bf8a9f3a5c7633de150322adf35ec1c464
+Description:  The iptables physdev kernel module
+
+Package: kmod-ipt-raw
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1990
+Filename: kmod-ipt-raw_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2738
+SHA256sum: 7fef18cb8523b45ae631f1f4567c75ce85ad6421cabbdf7fcf8c00a9ee7ea33d
+Description:  Netfilter IPv4 raw table support
+
+Package: kmod-iptunnel4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2378
+Filename: kmod-iptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3129
+SHA256sum: 6d2eb052d8c163cc7c42c45e9c3ca5233b95134e06b1b08690e4b15a01b43609
+Description:  Kernel modules for IPv4 tunneling
+
+Package: kmod-iptunnel
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10050
+Filename: kmod-iptunnel_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10814
+SHA256sum: b19e970c8b804f5f151015d95bedcd5ba123db8fe00c9fc7b507dd38f94397c9
+Description:  Kernel module for generic IP tunnel support
+
+Package: kmod-leds-gpio
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3205
+Filename: kmod-leds-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3961
+SHA256sum: 2e49775b993fad850ab2d40a3f1fba6d45f02c9079de42cc34d2c3efbd1ec0fa
+Description:  Kernel module for LEDs on GPIO lines
+
+Package: kmod-lib-crc-ccitt
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2255
+Filename: kmod-lib-crc-ccitt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3042
+SHA256sum: beb15e1318b4bbd573e2839022e7028124791f5f2f61f0cfde834f0b6085d1f1
+Description:  Kernel module for CRC-CCITT support
+
+Package: kmod-lib-crc16
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 231
+Filename: kmod-lib-crc16_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 977
+SHA256sum: d4309a20346c1510d9a5d7396f570ec747b8413f0074bb5209d73103f9669ed9
+Description:  Kernel module for CRC16 support
+
+Package: kmod-lib-zlib-deflate
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 195
+Filename: kmod-lib-zlib-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 936
+SHA256sum: 234bb1b07b7d5be70906939d333616586f5a90256eebff69555d5d765ee12e2d
+Description:  Zlib support
+
+Package: kmod-lib-zlib-inflate
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 196
+Filename: kmod-lib-zlib-inflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 933
+SHA256sum: 0df1bfd338aeebaa4efccccad46800f4743bc76f70f17a9808992fbe49757ad9
+Description:  Zlib support
+
+Package: kmod-mac80211
+Version: 5.4.102+5.10.16-1-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-cfg80211, hostapd-common, kmod-qca-nss-drv
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 303688
+Filename: kmod-mac80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 301434
+SHA256sum: 2b176c5862fd0877a40f738a38428477f66e45d844db9c13faceefacc4802183
+Description:  Generic IEEE 802.11 Networking Stack (mac80211)
+
+Package: kmod-nf-conntrack-netlink
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nfnetlink, kmod-ipt-conntrack
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 15796
+Filename: kmod-nf-conntrack-netlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 16559
+SHA256sum: a09b80ff737f35cb6e5d618ffbd85ba4a9b15802e30e201e5f5a38d09fa3d8c3
+Description:  Kernel modules support for a netlink-based connection tracking
+ userspace interface
+
+Package: kmod-nf-conntrack6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-conntrack
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-nf-conntrack6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 858
+SHA256sum: 24f886b48edeb73cc1abcb8477816914ba188c58cfd13ff8623485d005da8657
+Description:  Netfilter IPv6 connection tracking
+
+Package: kmod-nf-conntrack
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 53095
+Filename: kmod-nf-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 53631
+SHA256sum: a7b9d0e890b7e564fb808da2461c6772d1f178f93ed4a7a7f8b900fc253824e9
+Description:  Netfilter connection tracking
+
+Package: kmod-nf-flow
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-conntrack
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12123
+Filename: kmod-nf-flow_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12898
+SHA256sum: ecb476fc0c8f59c0ce722d5f7635a15a029349463a0ec926b431118692cfb17f
+Description:  Netfilter flowtable support
+
+Package: kmod-nf-ipt6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-ipt
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 9054
+Filename: kmod-nf-ipt6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9819
+SHA256sum: 9860c42fb5a3eb38a4fc683d8316a048c1adf870acc4100ef29f51bc81e56590
+Description:  Ip6tables core
+
+Package: kmod-nf-ipt
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 18634
+Filename: kmod-nf-ipt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19362
+SHA256sum: 085a2726ef99b6926909d2ed102544db5431c9668f4614ee072bc8dc90a205e3
+Description:  Iptables core
+
+Package: kmod-nf-nat6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-conntrack6, kmod-nf-nat
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-nf-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 857
+SHA256sum: 32b4d5313f95ad89beeb82cdc8a3c446397c0e9bfa3c307aca67d41efe18caaf
+Description:  Netfilter IPV6-NAT
+
+Package: kmod-nf-nat
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-conntrack
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 14567
+Filename: kmod-nf-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15303
+SHA256sum: 5fba5ee716b7a1be21bae6347a30484169db70ed3ac8d477ef2199e32af27a5b
+Description:  Netfilter NAT
+
+Package: kmod-nf-reject6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2804
+Filename: kmod-nf-reject6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3557
+SHA256sum: fa0c4414489660e01daf420756c81c5fb37505e17ed241c11751ae338c5c2c85
+Description:  Netfilter IPv6 reject support
+
+Package: kmod-nf-reject
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2436
+Filename: kmod-nf-reject_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3175
+SHA256sum: 1e4bcbb0a57c20431f5a0450ed5d5f4b9d08d418eb96070d80f20b262338ac60
+Description:  Netfilter IPv4 reject support
+
+Package: kmod-nfnetlink
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4753
+Filename: kmod-nfnetlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5511
+SHA256sum: 23c903195dfba2a30c71b8271289665a4b28e23f92782b2646fdd3d53d278ef6
+Description:  Kernel modules support for a netlink-based userspace interface
+
+Package: kmod-nls-base
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-nls-base_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 862
+SHA256sum: 41b25f2afda297291d4ba24adcc7ad62e9a40e8938e89e65cab083a98271dee9
+Description:  Kernel module for NLS (Native Language Support)
+
+Package: kmod-nls-cp1250
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2433
+Filename: kmod-nls-cp1250_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3214
+SHA256sum: de7a660d46582ee2e9b334d5db30429ccae4a130a2d30e865c36d8c08d4a9d7f
+Description:  Kernel module for NLS Codepage 1250 (Eastern Europe)
+
+Package: kmod-nls-cp437
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2497
+Filename: kmod-nls-cp437_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3290
+SHA256sum: 78485440a70f2abb7df5853f0d3b1fe2a6e535a908a927a7db2dea34df261d48
+Description:  Kernel module for NLS Codepage 437 (United States, Canada)
+
+Package: kmod-nls-cp850
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2454
+Filename: kmod-nls-cp850_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3226
+SHA256sum: 12323e2715082f383b6eaa706b438e58114a73ce00f455f314f4aa071527512c
+Description:  Kernel module for NLS Codepage 850 (Europe)
+
+Package: kmod-nls-iso8859-15
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2250
+Filename: kmod-nls-iso8859-15_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3014
+SHA256sum: 7c63b73ad51d241bffafc93ea7b4ae39477a23e84d70e9128c1ab4a8afe88998
+Description:  Kernel module for NLS ISO 8859-15 (Latin 9)
+
+Package: kmod-nls-iso8859-1
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2178
+Filename: kmod-nls-iso8859-1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2945
+SHA256sum: 46e0f3d3db733697385f1ba3b1473e571f9ca47f40c107f3a365648fc918096d
+Description:  Kernel module for NLS ISO 8859-1 (Latin 1)
+
+Package: kmod-nls-utf8
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1424
+Filename: kmod-nls-utf8_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2203
+SHA256sum: e3363e1dbb37be11ae843e7b7bc02e3dcc909ba7ad1ab1f6cdcb25a6c7f34a1b
+Description:  Kernel module for NLS UTF-8
+
+Package: kmod-nss-ifb
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-drv
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3626
+Filename: kmod-nss-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4390
+SHA256sum: 4e3a5e8ec9241a3af992899f90648ba10e439f64001035db336031f273ada091
+Description:  Kernel module to register a NSS aware IFB interface.
+
+Package: kmod-phy-qcom-ipq806x-usb
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3160
+Filename: kmod-phy-qcom-ipq806x-usb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3981
+SHA256sum: 48fb22daa9c93b0e421b5c8566d2cc504ea8f4dcba6504fc99cc97c2ddb389ef
+Description:  This driver provides support for the integrated DesignWare
+ USB3 IP Core within the QCOM SoCs.
+
+Package: kmod-ppp
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-lib-crc-ccitt, kmod-slhc
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 25100
+Filename: kmod-ppp_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 25832
+SHA256sum: f49c11762500f66275fab78cd779d5e032dbc197db82264633e07361c7437eac
+Description:  Kernel modules for PPP support
+
+Package: kmod-pppoe
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ppp, kmod-pppox
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7839
+Filename: kmod-pppoe_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8627
+SHA256sum: b825ea9ec31d8960715f9b2451122fd346fc2b3e97c89727f0fe1a169ed64daf
+Description:  Kernel module for PPPoE (PPP over Ethernet) support
+
+Package: kmod-pppox
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ppp
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1986
+Filename: kmod-pppox_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2780
+SHA256sum: f197112792a8d95654a2253e659520c4b67165fbfd95fecf060bb1faf68409b3
+Description:  Kernel helper module for PPPoE and PPTP support
+
+Package: kmod-qca-nss-drv-pppoe
+Version: 5.4.102+740d0102-2
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-drv, kmod-pppoe, kmod-bonding
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2688
+Filename: kmod-qca-nss-drv-pppoe_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3464
+SHA256sum: b755992f5b7fc71b3e41fd2a1692d323901149cb81fe5e1a8093b4a577388a66
+Description:  Kernel driver for NSS (connection manager) - PPPoE
+
+Package: kmod-qca-nss-drv-qdisc
+Version: 5.4.102+740d0102-2
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-drv
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 29444
+Filename: kmod-qca-nss-drv-qdisc_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 30090
+SHA256sum: aa084496c6f3ac15a2c6af6f01c72d49c4318b592919201289b773abaae8b800
+Description:  Qdisc for configuring shapers in NSS
+
+Package: kmod-qca-nss-drv
+Version: 5.4.102+809a00de-2
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-gmac
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 392481
+Filename: kmod-qca-nss-drv_5.4.102+809a00de-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 390240
+SHA256sum: d447226c0b3917256a2b6624957245403cda870923b351bbc423b3538500b900
+Description:  Kernel driver for NSS (core driver)
+
+Package: kmod-qca-nss-ecm-standard
+Version: 5.4.102+9228212b-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-drv, iptables-mod-extra, kmod-ipt-conntrack, kmod-pppoe, kmod-ipsec
+Provides: kmod-qca-nss-ecm
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 148892
+Filename: kmod-qca-nss-ecm-standard_5.4.102+9228212b-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 146899
+SHA256sum: 1682297eb7055dc93993322279071eb32b38543b1e0192bc43be4b88018efd21
+Description:  QCA NSS Enhanced Connection Manager (ECM)
+
+Package: kmod-qca-nss-gmac
+Version: 5.4.102+9b74deef-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 24622
+Filename: kmod-qca-nss-gmac_5.4.102+9b74deef-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 25229
+SHA256sum: e68d342bb8f8769127899c99590707e4f22a74158bf8232f7ce1cf18401b7b29
+Description:  Kernel driver for NSS gmac
+
+Package: kmod-sched-cake
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-sched-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19366
+Filename: kmod-sched-cake_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 20121
+SHA256sum: 40d8c1b06b137c76a6866d9d4d8e40e0d7f5476b53292981d5095c0897710c73
+Description:  Common Applications Kept Enhanced fq_codel/blue derived shaper
+
+Package: kmod-sched-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 61459
+Filename: kmod-sched-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 62236
+SHA256sum: 34acc0662734430fda7330ac91fbeb88eefd57e2c543f213ab1420b7f1a36c32
+Description:  Core kernel scheduler support for IP traffic
+
+Package: kmod-scsi-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 82273
+Filename: kmod-scsi-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 82675
+SHA256sum: 6d7419bab3a57a98ed678a50d37e3e8858fffd39c32de9ecdd29ec8cd546601a
+Description:  SCSI device support
+
+Package: kmod-sit
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-iptunnel, kmod-iptunnel4
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12696
+Filename: kmod-sit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13453
+SHA256sum: 1c76fb8713dfba14674d12d4fbf22a93aae974c6119d11ff114bb60392418f69
+Description:  Kernel modules for IPv6-in-IPv4 tunnelling
+
+Package: kmod-slhc
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-lib-crc-ccitt
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3972
+Filename: kmod-slhc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4721
+SHA256sum: a9d8bef4105955c6774619f3c567b3d6eefa4e2b8f3e6821fd928db9f4dd11ce
+Description:  Serial Line Header Compression
+
+Package: kmod-tun
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 23435
+Filename: kmod-tun_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 24137
+SHA256sum: 617235132c52385b33ae44ba2ca2c9d92c9641fdebd52ae4dee89a6a1febb156
+Description:  Kernel support for the TUN/TAP tunneling device
+
+Package: kmod-udptunnel4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2637
+Filename: kmod-udptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3385
+SHA256sum: ae79ebf67cef758e6055aba7be40bfb97358bb70d8b9b3cb3297a75713355939
+Description:  IPv4 UDP tunneling support
+
+Package: kmod-udptunnel6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2026
+Filename: kmod-udptunnel6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2806
+SHA256sum: 5c03b4688fc39f63d3024458c8a15a7975fe83d2bd00a324b49d93d1700dcc28
+Description:  IPv6 UDP tunneling support
+
+Package: kmod-usb-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 237
+Filename: kmod-usb-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 988
+SHA256sum: 08bf5e50bf393b73067695af071abdd489d969c143bf30b9ee97d338f7e898ca
+Description:  Kernel support for USB
+
+Package: kmod-usb-dwc3-qcom
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-dwc3, kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4311
+Filename: kmod-usb-dwc3-qcom_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5159
+SHA256sum: 1957f4b6ec4426f5c4058ec04f778e9a62c5190b19ce22d5d0286a2a66b08d55
+Description:  Some Qualcomm SoCs use DesignWare Core IP for USB2/3 functionality.
+ This driver also handles Qscratch wrapper which is needed for
+ peripheral mode support.
+
+Package: kmod-usb-dwc3
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 13036
+Filename: kmod-usb-dwc3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13438
+SHA256sum: e6319c58edfe01a8e49d26353c44d37dec681db6c5cc898e98ab133531d523a1
+Description:  This driver provides support for the Dual Role SuperSpeed
+ USB Controller based on the Synopsys DesignWare USB3 IP Core
+
+Package: kmod-usb-ehci
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 24905
+Filename: kmod-usb-ehci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 25600
+SHA256sum: 9a1d80225d41c89ba70af5b93b1b49855a3e4b6e97525333aeffdcd1f0ac20e4
+Description:  EHCI controller support
+
+Package: kmod-usb-ledtrig-usbport
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3376
+Filename: kmod-usb-ledtrig-usbport_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4255
+SHA256sum: 44deed4de51be939b65947267e9974efec8d6ed8db2b998196d6d2913c8df248
+Description:  This driver allows LEDs to be controlled by USB events. Enabling this
+ trigger allows specifying list of USB ports that should turn on LED
+ when some USB device gets connected.
+ If possible it should be prefered over similar ledtrig-usbdev.
+
+Package: kmod-usb-ohci
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 20938
+Filename: kmod-usb-ohci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 21664
+SHA256sum: 7b4e5f170049575315d39edec44026699361eef5b6c114ccb497d03095de69fe
+Description:  Kernel support for USB OHCI controllers
+
+Package: kmod-usb-storage
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-scsi-core, kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 23920
+Filename: kmod-usb-storage_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 24159
+SHA256sum: 27bcb8fc398ef74b88d0eed9bc0c8dcc4664338e6d4126597f99fc64a9c00455
+Description:  Kernel support for USB Mass Storage devices
+
+Package: kmod-usb2
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-ehci, kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8830
+Filename: kmod-usb2_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9623
+SHA256sum: 7373af3208352be5d40c12587a169888570b193e9e1d9036d5a004a16ab79037
+Description:  Kernel support for USB2 (EHCI) controllers
+
+Package: kmod-usb3
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 73698
+Filename: kmod-usb3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 74047
+SHA256sum: d276da6724c3fd6866845565322acab4dcef8e18855b4afb0929f204a4104915
+Description:  Kernel support for USB3 (XHCI) controllers
+
+Package: kmod-wireguard
+Version: 5.4.102+1.0.20201112-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-udptunnel6, kmod-udptunnel4
+License: GPL-2.0
+Section: kernel
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 62325
+Filename: kmod-wireguard_5.4.102+1.0.20201112-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 63345
+SHA256sum: a687250bbc274134fc32fb0c53c631267a23a766dcaa5f42e4ab0859ba1f60ab
+Description:  WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes
+ state-of-the-art cryptography. It aims to be faster, simpler, leaner, and
+ more useful than IPSec, while avoiding the massive headache. It intends to
+ be considerably more performant than OpenVPN.  WireGuard is designed as a
+ general purpose VPN for running on embedded interfaces and super computers
+ alike, fit for many different circumstances. It uses UDP.
+ 
+ This package provides the kernel module for WireGuard.
+
+Package: libgcc1
+Version: 8.4.0-3
+Provides: libgcc
+License: GPL-3.0-with-GCC-exception
+Section: libs
+Status: unknown hold not-installed
+Essential: yes
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 21618
+Filename: libgcc1_8.4.0-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 22359
+SHA256sum: 37f88f846ceab4881e123e0a7e2a2b6f518731d451d104753eb7627b40192dcb
+Description:  GCC support library
+
+Package: libip4tc2
+Version: 1.8.7-1
+Depends: libc, libxtables12
+Provides: libip4tc
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19419
+Filename: libip4tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 20225
+SHA256sum: fb847abccfc62b2f7d5626359f78b2c25cc18d70c676cfd4d2764b5e8af9d0c7
+Description:  IPv4 firewall - shared libiptc library
+
+Package: libip6tc2
+Version: 1.8.7-1
+Depends: libc, libxtables12
+Provides: libip6tc
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19166
+Filename: libip6tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19950
+SHA256sum: 7aeb1242a1b5a92c5988b3d4fe06ceda652191b7b3f3fa4209f150459944ca83
+Description:  IPv6 firewall - shared libiptc library
+
+Package: libiwinfo-lua
+Version: 2021-01-31-4a32b33e-1
+Depends: libc, libiwinfo20210106, liblua5.1.5
+License: GPL-2.0
+Section: lang
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6486
+Filename: libiwinfo-lua_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7319
+SHA256sum: 7f33c091a00c20375d134f397a05af766e1ec3b1f26901205ffd5de2c3298e47
+Description:  This is the Lua binding for the iwinfo library. It provides access to all enabled
+ backends.
+
+Package: libiwinfo20210106
+Version: 2021-01-31-4a32b33e-1
+Depends: libc, libnl-tiny1, libuci20130104, libubus20210215
+Provides: libiwinfo
+License: GPL-2.0
+Section: libs
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 27056
+Filename: libiwinfo20210106_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 27863
+SHA256sum: 771654ccee4217bbb9f9c5aac4ad375518c7ea0d106a32999b01fe9fff48cc6e
+Description:  Wireless information library with consistent interface for proprietary Broadcom,
+ nl80211 and wext driver interfaces.
+
+Package: libpthread
+Version: 1.1.24-3
+Depends: libgcc1
+License: GPL-3.0-with-GCC-exception
+Section: libs
+Status: unknown hold not-installed
+Essential: yes
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 123
+Filename: libpthread_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 901
+SHA256sum: f63e55be34222c83559561af84dfebd7fd41ee8bbca83d569146c2ad3b75df94
+Description:  POSIX thread library
+
+Package: librt
+Version: 1.1.24-3
+Depends: libpthread
+License: GPL-3.0-with-GCC-exception
+Section: libs
+Status: unknown hold not-installed
+Essential: yes
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 123
+Filename: librt_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 914
+SHA256sum: 435a2fee28c48cf6bd8a151a3d7870e59113acd4b4968483741e05d77082d27b
+Description:  POSIX.1b RealTime extension library
+
+Package: libxtables12
+Version: 1.8.7-1
+Depends: libc
+Provides: libxtables
+License: GPL-2.0
+Section: libs
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 44803
+Filename: libxtables12_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 45562
+SHA256sum: f26ba200a1e99e7751dfc840bb63a5432c38076afc90a26d2d7373ed2879d870
+Description:  IPv4/IPv6 firewall - shared xtables library
+
+Package: mtd
+Version: 26
+Depends: libc, libubox20201212
+License: GPL-2.0+
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10472
+Filename: mtd_26_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11254
+SHA256sum: c1d7fe43485744b4964c9cd28025fd3bd996a34835a90e3b112100df3280f593
+Description:  This package contains an utility useful to upgrade from other firmware or 
+ older OpenWrt releases.
+
+Package: ubi-utils
+Version: 2.1.2-1
+Depends: libc
+License: GPLv2
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 76703
+Filename: ubi-utils_2.1.2-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 77341
+SHA256sum: 28cd663e33e7a8c1ba0906dbc1aec04b4f5bd819a6313c22b3e2ae149183a8d0
+Description:  Utilities for manipulating memory technology devices.
+
+Package: uboot-envtools
+Version: 2021.01-2
+Depends: libc
+License: GPL-2.0 GPL-2.0+
+Section: utils
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 13653
+Filename: uboot-envtools_2021.01-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 14425
+SHA256sum: 4fc815d64ce10ac07ef2de2fd753a50ec6097a005791f5777df5bd41c5842931
+Description:  This package includes tools to read and modify U-Boot bootloader environment.
+
diff --git a/bin/targets/ipq806x/generic/packages/Packages.gz b/bin/targets/ipq806x/generic/packages/Packages.gz
new file mode 100644
index 0000000000..f2c1c25343
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/Packages.gz differ
diff --git a/bin/targets/ipq806x/generic/packages/Packages.manifest b/bin/targets/ipq806x/generic/packages/Packages.manifest
new file mode 100644
index 0000000000..d4e39e98b2
--- /dev/null
+++ b/bin/targets/ipq806x/generic/packages/Packages.manifest
@@ -0,0 +1,2245 @@
+Package: base-files
+Version: 1405-r15878+18-8b3d879861
+Depends: libc, netifd, jsonfilter, usign, openwrt-keyring, ubi-utils, fstools, fwtool
+Source: package/base-files
+SourceName: base-files
+License: GPL-2.0
+Section: base
+SourceDateEpoch: 1613438493
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 49173
+Filename: base-files_1405-r15878+18-8b3d879861_arm_cortex-a15_neon-vfpv4.ipk
+Size: 50206
+SHA256sum: 83977cecfd8af5bf44864c0942033375b592b38f0afe884c33a1fdf4788754d9
+Description:  This package contains a base filesystem and system scripts for OpenWrt.
+
+Package: block-mount
+Version: 2021-01-04-c53b1882-1
+Depends: libc, ubox, libubox20201212, libuci20130104, libblobmsg-json20201212, libjson-c5
+Source: package/system/fstools
+SourceName: block-mount
+License: GPL-2.0
+Section: base
+SourceDateEpoch: 1609794455
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 26272
+Filename: block-mount_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 27035
+SHA256sum: b8d4a1a5d5ea21c59ee6fcc087eba26a38236589af9a25f1e79e4bb2370b1499
+Description:  Block device mounting and checking
+
+Package: dropbear
+Version: 2020.81-2
+Depends: libc
+Alternatives: 100:/usr/bin/scp:/usr/sbin/dropbear, 100:/usr/bin/ssh:/usr/sbin/dropbear
+Source: package/network/services/dropbear
+SourceName: dropbear
+License: MIT
+LicenseFiles: LICENSE libtomcrypt/LICENSE libtommath/LICENSE
+Section: net
+SourceDateEpoch: 1607690904
+CPE-ID: cpe:/a:matt_johnston:dropbear_ssh_server
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 108027
+Filename: dropbear_2020.81-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 108814
+SHA256sum: 2db973b80009065898eb40ce6f90f4f41198da790aed96bc4603c387a75c4680
+Description:  A small SSH2 server/client designed for small memory environments.
+
+Package: fstools
+Version: 2021-01-04-c53b1882-1
+Depends: libc, ubox, ubi-utils
+Source: package/system/fstools
+SourceName: fstools
+License: GPL-2.0
+Section: base
+SourceDateEpoch: 1609794455
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 15271
+Filename: fstools_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15974
+SHA256sum: c2860c1175d920104dc4b3af10b804181b0265cd95e24c941130204e525c8686
+Description:  OpenWrt filesystem tools
+
+Package: fwtool
+Version: 2019-11-12-8f7fe925-1
+Depends: libc
+Source: package/system/fwtool
+SourceName: fwtool
+License: GPL-2.0
+Section: utils
+SourceDateEpoch: 1573768411
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3767
+Filename: fwtool_2019-11-12-8f7fe925-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4538
+SHA256sum: cc081ccf30967ee35986cf9ee85572fc68590fdbe1cd743ad9e805897b27b081
+Description:  Utility for appending and extracting firmware metadata and signatures
+
+Package: ip6tables-mod-nat
+Version: 1.8.7-1
+Depends: libc, ip6tables, kmod-ipt-nat6
+Source: package/network/utils/iptables
+SourceName: ip6tables-mod-nat
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1473
+Filename: ip6tables-mod-nat_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2260
+SHA256sum: 373f4ae586f583d26782fe153d84c04b879180cc05cec9b59a56d5386b04bced
+Description:  iptables extensions for IPv6-NAT targets.
+
+Package: ip6tables
+Version: 1.8.7-1
+Depends: libc, kmod-ip6tables, iptables
+Source: package/network/utils/iptables
+SourceName: ip6tables
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 218
+Filename: ip6tables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 978
+SHA256sum: 88e8966ba0406a7546286d7bfac25a03ddc7dcca734ddd763c3406dbfb5a9c3b
+Description:  IPv6 firewall administration tool
+
+Package: iptables-mod-conntrack-extra
+Version: 1.8.7-1
+Depends: libc, iptables, kmod-ipt-conntrack-extra, kmod-ipt-raw
+Source: package/network/utils/iptables
+SourceName: iptables-mod-conntrack-extra
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10546
+Filename: iptables-mod-conntrack-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11403
+SHA256sum: 8ab695e7f93c1ef53ed3830dd478cdf02f10ef53589bab730f53a41d1983e845
+Description:  Extra iptables extensions for connection tracking.
+ 
+ Matches:
+ - connbytes
+ - connlimit
+ - connmark
+ - recent
+ - helper
+ 
+ Targets:
+ - CONNMARK
+ 
+
+Package: iptables-mod-extra
+Version: 1.8.7-1
+Depends: libc, iptables, kmod-ipt-extra
+Source: package/network/utils/iptables
+SourceName: iptables-mod-extra
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7197
+Filename: iptables-mod-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8016
+SHA256sum: c4b2dba00c4fb499d656ec7759db8e2f40d292350992569eb05e4d949df75485
+Description:  Other extra iptables extensions.
+ 
+ Matches:
+ - addrtype
+ - condition
+ - owner
+ - pkttype
+ - quota
+ 
+
+Package: iptables-mod-ipopt
+Version: 1.8.7-1
+Depends: libc, iptables, kmod-ipt-ipopt
+Source: package/network/utils/iptables
+SourceName: iptables-mod-ipopt
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12162
+Filename: iptables-mod-ipopt_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12952
+SHA256sum: ff1d6fcd733e1387114ff80299b78493ebe2efd4ef1f59f00c74adba4fa76523
+Description:  iptables extensions for matching/changing IP packet options.
+ 
+ Matches:
+ - dscp
+ - ecn
+ - length
+ - statistic
+ - tcpmss
+ - unclean
+ - hl
+ 
+ Targets:
+ - DSCP
+ - CLASSIFY
+ - ECN
+ - HL
+ 
+
+Package: iptables-mod-physdev
+Version: 1.8.7-1
+Depends: libc, iptables, kmod-ipt-physdev
+Source: package/network/utils/iptables
+SourceName: iptables-mod-physdev
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1772
+Filename: iptables-mod-physdev_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2552
+SHA256sum: 16e3f076794ddc6af9333d7e2824ac49b96a45013beaf4a2213c993bdf0acf59
+Description:  The iptables physdev match.
+
+Package: iptables
+Version: 1.8.7-1
+Depends: libc, kmod-ipt-core, libip4tc2, libip6tc2, libxtables12
+Source: package/network/utils/iptables
+SourceName: iptables
+License: GPL-2.0
+Section: net
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 24415
+Filename: iptables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 25225
+SHA256sum: f5781b9a7cb783806f90fd67710dc0e7d2a43a476dffed87c281259a7d61440e
+Description:  IP firewall administration tool.
+ 
+ Matches:
+ - icmp
+ - tcp
+ - udp
+ - comment
+ - conntrack
+ - limit
+ - mac
+ - mark
+ - multiport
+ - set
+ - state
+ - time
+ 
+ Targets:
+ - ACCEPT
+ - CT
+ - DNAT
+ - DROP
+ - REJECT
+ - FLOWOFFLOAD
+ - LOG
+ - MARK
+ - MASQUERADE
+ - REDIRECT
+ - SET
+ - SNAT
+ - TCPMSS
+ 
+ Tables:
+ - filter
+ - mangle
+ - nat
+ - raw
+ 
+
+Package: iwinfo
+Version: 2021-01-31-4a32b33e-1
+Depends: libc, libiwinfo20210106
+Source: package/network/utils/iwinfo
+SourceName: iwinfo
+License: GPL-2.0
+Section: utils
+SourceDateEpoch: 1613244049
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7017
+Filename: iwinfo_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7849
+SHA256sum: f807c42b566ac6e3caacd653ca25015c0b14ef3e8ca700eb31057df2f47a39c7
+Description:  Command line frontend for the wireless information library.
+
+Package: kmod-ata-ahci-platform
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ata-core
+Source: package/kernel/linux
+SourceName: kmod-ata-ahci-platform
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6280
+Filename: kmod-ata-ahci-platform_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7109
+SHA256sum: 2d037f74594c94a991052d2ce337a39226de1214ba714625452e253ecc04f474
+Description:  Platform support for AHCI Serial ATA controllers
+
+Package: kmod-ata-ahci
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ata-core
+Source: package/kernel/linux
+SourceName: kmod-ata-ahci
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6719
+Filename: kmod-ata-ahci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7526
+SHA256sum: 80fb0633603a17d30f986c114af707f215d9c50b1a184cda1a20982964430328
+Description:  Support for AHCI Serial ATA controllers
+
+Package: kmod-ata-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-scsi-core
+Source: package/kernel/linux
+SourceName: kmod-ata-core
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104068
+Filename: kmod-ata-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 103995
+SHA256sum: 68547fcea0aa5d89f8b1bae23e2bcf1ab171bd7ea8eed5c1d0016f9979a9907e
+Description:  Serial and Parallel ATA support
+
+Package: kmod-ath10k-ct
+Version: 5.4.102+2021-01-11-9fe1df7d-2
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-mac80211, kmod-ath, kmod-hwmon-core
+Provides: kmod-ath10k
+Source: package/kernel/ath10k-ct
+SourceName: kmod-ath10k-ct
+License: GPLv2
+Section: kernel
+SourceDateEpoch: 1615144626
+Maintainer: Ben Greear <greearb@candelatech.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 246390
+Filename: kmod-ath10k-ct_5.4.102+2021-01-11-9fe1df7d-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 244655
+SHA256sum: 85defa6143e3864c5248e75873e82633db0c35bcf16e02bb306f66520f9f17a3
+Description:  ath10k-ct driver optimized for CT ath10k firmware
+
+Package: kmod-ath
+Version: 5.4.102+5.10.16-1-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-mac80211
+Source: package/kernel/mac80211
+SourceName: kmod-ath
+Section: kernel
+SourceDateEpoch: 1615144626
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12420
+Filename: kmod-ath_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13128
+SHA256sum: 196608a52b9b2a41c54df4196bae63f4fd452999dd0be9caafcca6e1ddd5dbe8
+Description:  This module contains some common parts needed by Atheros Wireless drivers.
+
+Package: kmod-bonding
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-bonding
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 63358
+Filename: kmod-bonding_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 63909
+SHA256sum: 38daa93bf4ad181e20d90e0f1a367409ee8189055f7d4207440037d9fecc4d8c
+Description:  Kernel module for NIC bonding.
+
+Package: kmod-br-netfilter
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core
+Source: package/kernel/linux
+SourceName: kmod-br-netfilter
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 385
+Filename: kmod-br-netfilter_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1157
+SHA256sum: ac014d6c92e452132efebb379fefcacdc77e912c4dc357ce52abc671cc6d10df
+Description:  Bridge netfilter support modules
+
+Package: kmod-cfg80211
+Version: 5.4.102+5.10.16-1-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), iw, wireless-regdb
+Source: package/kernel/mac80211
+SourceName: kmod-cfg80211
+Section: kernel
+SourceDateEpoch: 1615144626
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 164313
+Filename: kmod-cfg80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 164438
+SHA256sum: a5557225f7c5fc9337c7c30b840e8f201ab9f6c655ac1f54a0619cd01155b4f0
+Description:  cfg80211 is the Linux wireless LAN (802.11) configuration API.
+
+Package: kmod-crypto-acompress
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-crypto-acompress
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 199
+Filename: kmod-crypto-acompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 953
+SHA256sum: 3f2c102ce5b8cee93d02eea3814c65a7ee2533ba8f22990c969ce9fe923b7bc5
+Description:  Asynchronous Compression operations
+
+Package: kmod-crypto-aead
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-null
+Source: package/kernel/linux
+SourceName: kmod-crypto-aead
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 233
+Filename: kmod-crypto-aead_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 983
+SHA256sum: 163f36c59520646ee148d0c25fbb0bdefd8e4b18d25bc41de74264fbe66303ea
+Description:  CryptoAPI AEAD support
+
+Package: kmod-crypto-arc4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-crypto-arc4
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1354
+Filename: kmod-crypto-arc4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2138
+SHA256sum: bf21bc1e39877e18c122c1b92ecf275d05f1d472a1d04e017144bcf38bb4fb18
+Description:  ARC4 cipher CryptoAPI module
+
+Package: kmod-crypto-authenc
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-manager, kmod-crypto-null
+Source: package/kernel/linux
+SourceName: kmod-crypto-authenc
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3933
+Filename: kmod-crypto-authenc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4700
+SHA256sum: 0673264226228fb73b1e9c8604a24d9f7e0815f060189caf51183fae9b874b92
+Description:  Combined mode wrapper for IPsec
+
+Package: kmod-crypto-cbc
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-manager
+Source: package/kernel/linux
+SourceName: kmod-crypto-cbc
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2073
+Filename: kmod-crypto-cbc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2828
+SHA256sum: 8bb97732790895aaf4dde15842f5632ed1e6f16f1bc281aee0847f01cbd81cf7
+Description:  Cipher Block Chaining CryptoAPI module
+
+Package: kmod-crypto-ccm
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-ctr, kmod-crypto-aead
+Source: package/kernel/linux
+SourceName: kmod-crypto-ccm
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6554
+Filename: kmod-crypto-ccm_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7380
+SHA256sum: c58f81748d4aa60a7af324ba3265c0da6b6f36412c591e55dc7dc1a1686d39f6
+Description:  Support for Counter with CBC MAC (CCM)
+
+Package: kmod-crypto-cmac
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+Source: package/kernel/linux
+SourceName: kmod-crypto-cmac
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2681
+Filename: kmod-crypto-cmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3462
+SHA256sum: d69e0c5f42a458878e92014ce02818e527eecfb5e4fe3461ea42b9e2bfc80502
+Description:  Support for Cipher-based Message Authentication Code (CMAC)
+
+Package: kmod-crypto-crc32c
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+Source: package/kernel/linux
+SourceName: kmod-crypto-crc32c
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1553
+Filename: kmod-crypto-crc32c_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2301
+SHA256sum: b36ea82891618f0e6df0d30f02aaded19d8fb53edf93b179eb9fed4fddd0db3b
+Description:  CRC32c CRC module
+
+Package: kmod-crypto-ctr
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-manager, kmod-crypto-seqiv
+Source: package/kernel/linux
+SourceName: kmod-crypto-ctr
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2981
+Filename: kmod-crypto-ctr_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3739
+SHA256sum: 2d59b9c50776253df0b5415f20159853a0475c47c67962c43e9255818398019f
+Description:  Counter Mode CryptoAPI module
+
+Package: kmod-crypto-deflate
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-lib-zlib-inflate, kmod-lib-zlib-deflate, kmod-crypto-acompress
+Source: package/kernel/linux
+SourceName: kmod-crypto-deflate
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 193
+Filename: kmod-crypto-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 970
+SHA256sum: 8d800bea0a2b9d82a59212cc54fbcfe45dab98b025bdd59d1f35dd26ba4292da
+Description:  Deflate compression CryptoAPI module
+
+Package: kmod-crypto-des
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-crypto-des
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 9540
+Filename: kmod-crypto-des_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10132
+SHA256sum: 7b5b1d9af7d2cc3f601695d441276f9f277215968f0219375c2bd3a1cbd94663
+Description:  DES/3DES cipher CryptoAPI module
+
+Package: kmod-crypto-ecb
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-manager
+Source: package/kernel/linux
+SourceName: kmod-crypto-ecb
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1577
+Filename: kmod-crypto-ecb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2369
+SHA256sum: dd36280c7f3e4f9eabec34f96dc84eaf889301c1d27bd1c16c0347d841b3bc59
+Description:  Electronic CodeBook CryptoAPI module
+
+Package: kmod-crypto-echainiv
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-aead
+Source: package/kernel/linux
+SourceName: kmod-crypto-echainiv
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2205
+Filename: kmod-crypto-echainiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2960
+SHA256sum: 4dad303173a67e677a91097388646db75ac4d6bac86832d7cb3f95d140699151
+Description:  Encrypted Chain IV Generator
+
+Package: kmod-crypto-hash
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-crypto-hash
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 242
+Filename: kmod-crypto-hash_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 994
+SHA256sum: e65ddfb03e5e72ed64d1f6607f0dc6e1612ff693630f03c4c1c8f94e011f3a6b
+Description:  CryptoAPI hash support
+
+Package: kmod-crypto-hmac
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash, kmod-crypto-manager
+Source: package/kernel/linux
+SourceName: kmod-crypto-hmac
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 191
+Filename: kmod-crypto-hmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 954
+SHA256sum: a908a7480e0a96cc240c24d66006f5ee459255aa2093a70cd24f9eb82383faf9
+Description:  HMAC digest CryptoAPI module
+
+Package: kmod-crypto-manager
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-aead, kmod-crypto-hash, kmod-crypto-pcompress
+Source: package/kernel/linux
+SourceName: kmod-crypto-manager
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 241
+Filename: kmod-crypto-manager_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 1008
+SHA256sum: 48b581c7ee4afd19cdee2be6dd36a5f3b0a81e212e08a8a90b55e7b41803ea90
+Description:  CryptoAPI algorithm manager
+
+Package: kmod-crypto-md4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+Source: package/kernel/linux
+SourceName: kmod-crypto-md4
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2986
+Filename: kmod-crypto-md4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3743
+SHA256sum: 95d7afdada0504a72d0cdb62f0047906c6964fb89b81c6038e6a83d1a2276ff6
+Description:  MD4 digest CryptoAPI module
+
+Package: kmod-crypto-md5
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+Source: package/kernel/linux
+SourceName: kmod-crypto-md5
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3898
+Filename: kmod-crypto-md5_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4653
+SHA256sum: 5998b84d2fd1d145701f13bef34bafa4882d5a9e1e5a55b9691ff34ad2a7061e
+Description:  MD5 digest CryptoAPI module
+
+Package: kmod-crypto-null
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+Source: package/kernel/linux
+SourceName: kmod-crypto-null
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 196
+Filename: kmod-crypto-null_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 949
+SHA256sum: 10a7835f513fec61327b68f4821c1b0af89507385704450bc3586bec81e45992
+Description:  Null CryptoAPI module
+
+Package: kmod-crypto-pcompress
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-crypto-pcompress
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-crypto-pcompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 858
+SHA256sum: 83f3e0b69faf350f3f512aa696d43474a17075f32e3c8eca71aa9652fff4364a
+Description:  CryptoAPI Partial (de)compression operations
+
+Package: kmod-crypto-rng
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash, kmod-crypto-hmac, kmod-crypto-sha256
+Source: package/kernel/linux
+SourceName: kmod-crypto-rng
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 208
+Filename: kmod-crypto-rng_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 979
+SHA256sum: 4266b796178facd1a938547df652a882677173f926a421c5b7913417640a9911
+Description:  CryptoAPI random number generation
+
+Package: kmod-crypto-seqiv
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-aead, kmod-crypto-rng
+Source: package/kernel/linux
+SourceName: kmod-crypto-seqiv
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2356
+Filename: kmod-crypto-seqiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3128
+SHA256sum: abb8776c38ff6e8a4cc072a5b34fb942e28142df715359a146e44c1657d41285
+Description:  CryptoAPI Sequence Number IV Generator
+
+Package: kmod-crypto-sha1
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+Source: package/kernel/linux
+SourceName: kmod-crypto-sha1
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2277
+Filename: kmod-crypto-sha1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3030
+SHA256sum: b904f11bfde4feea58fdcf1897b5d9030a87730548729f6919bd3e7b3e9e060e
+Description:  SHA1 digest CryptoAPI module
+
+Package: kmod-crypto-sha256
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+Source: package/kernel/linux
+SourceName: kmod-crypto-sha256
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 202
+Filename: kmod-crypto-sha256_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 966
+SHA256sum: 257ee25d4931cead4d620e24a8c1513f6495116bbf3f374ef471747af5695e78
+Description:  SHA224 SHA256 digest CryptoAPI module
+
+Package: kmod-crypto-sha512
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-hash
+Source: package/kernel/linux
+SourceName: kmod-crypto-sha512
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6894
+Filename: kmod-crypto-sha512_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7719
+SHA256sum: 788e59c535d2a56110ffaa2e2f4b90cc772f1095ea6506c32ed29145f6450752
+Description:  SHA512 digest CryptoAPI module
+
+Package: kmod-cryptodev
+Version: 5.4.102+1.11-ipq806x-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-authenc, kmod-crypto-hash
+Source: package/kernel/cryptodev-linux
+SourceName: kmod-cryptodev
+License: GPL-2.0
+LicenseFiles: COPYING
+Section: kernel
+SourceDateEpoch: 1609527359
+Maintainer: Ansuel Smith <ansuelsmth@gmail.com>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 21704
+Filename: kmod-cryptodev_5.4.102+1.11-ipq806x-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 22454
+SHA256sum: 4877f2b699345470b949ba57074ddf5d63864986be0400d8b06b571a3e66c971
+Description:  This is a driver for that allows to use the Linux kernel supported
+ hardware ciphers by user-space applications.
+
+Package: kmod-fs-cifs
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base, kmod-crypto-md4, kmod-crypto-md5, kmod-crypto-sha256, kmod-crypto-sha512, kmod-crypto-cmac, kmod-crypto-hmac, kmod-crypto-arc4, kmod-crypto-aead, kmod-crypto-ccm, kmod-crypto-ecb, kmod-crypto-des
+Source: package/kernel/linux
+SourceName: kmod-fs-cifs
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 221682
+Filename: kmod-fs-cifs_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 218835
+SHA256sum: ae5d9c62de306d81b68a4e137e7d3c7dfee61eafb85788790087aa2d4870c945
+Description:  Kernel module for CIFS support
+
+Package: kmod-fs-exfat
+Version: 5.4.102+5.10.1-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+Source: package/kernel/exfat
+SourceName: kmod-fs-exfat
+License: GPL-2.0-only
+Section: kernel
+SourceDateEpoch: 1606295680
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 40663
+Filename: kmod-fs-exfat_5.4.102+5.10.1-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 41360
+SHA256sum: 6fb3dbe6ea9f5648d974a8d61c6ec8408604d0514caad5d48129468a3f3fee09
+Description:  exFAT kernel module
+
+Package: kmod-fs-ext4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-lib-crc16, kmod-crypto-hash, kmod-crypto-crc32c
+Source: package/kernel/linux
+SourceName: kmod-fs-ext4
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 278619
+Filename: kmod-fs-ext4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 277398
+SHA256sum: 1f6abd1bcc96d82a7e4b76417e7248e899f12b0d44f695f07f243afefbc30859
+Description:  Kernel module for EXT4 filesystem support
+
+Package: kmod-fs-hfsplus
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base, kmod-nls-utf8
+Source: package/kernel/linux
+SourceName: kmod-fs-hfsplus
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 57711
+Filename: kmod-fs-hfsplus_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 58328
+SHA256sum: 1791a40f323613ebd2fabb5ec100bb5928ab7eaa97c8ceb9ddd9bb366cb0403d
+Description:  Kernel module for HFS+ filesystem support
+
+Package: kmod-fs-msdos
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-fs-vfat, kmod-nls-base
+Source: package/kernel/linux
+SourceName: kmod-fs-msdos
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5494
+Filename: kmod-fs-msdos_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6284
+SHA256sum: 955d41f0ccb62c70b56a57af6ca33caa5c2300ff4b3588ef47a9fc8f8726a610
+Description:  Kernel module for MSDOS filesystem support
+
+Package: kmod-fs-vfat
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base, kmod-nls-cp437, kmod-nls-iso8859-1, kmod-nls-utf8
+Source: package/kernel/linux
+SourceName: kmod-fs-vfat
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 45214
+Filename: kmod-fs-vfat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 45876
+SHA256sum: 6c6fd94cfc1c8fbb562b0443be70beccf4c5eb6172e9616004b6756feb1f6ee1
+Description:  Kernel module for VFAT filesystem support
+
+Package: kmod-fuse
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-fuse
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 55713
+Filename: kmod-fuse_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 56249
+SHA256sum: 3b3efc296415a5fac1da1c1a373a493b1c88d53f0ff4034aa3203f0f18c03388
+Description:  Kernel module for userspace filesystem support
+
+Package: kmod-gpio-button-hotplug
+Version: 5.4.102-3
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/gpio-button-hotplug
+SourceName: kmod-gpio-button-hotplug
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1583676655
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6354
+Filename: kmod-gpio-button-hotplug_5.4.102-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7316
+SHA256sum: 3454ec40ee252d1c18b135d9b293a9a14e1eec3628f2786839af8034f3d2cee3
+Description:  This is a replacement for the following in-kernel drivers:
+ 1) gpio_keys (KEYBOARD_GPIO)
+ 2) gpio_keys_polled (KEYBOARD_GPIO_POLLED)
+ 
+ Instead of generating input events (like in-kernel drivers do) it generates
+ uevent-s and broadcasts them. This allows disabling input subsystem which is
+ an overkill for OpenWrt simple needs.
+
+Package: kmod-hwmon-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-hwmon-core
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-hwmon-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 854
+SHA256sum: b3980a2d060c18007e0942bb0f988d5dd625ccf67a60c9470da70c06b5530714
+Description:  Kernel modules for hardware monitoring
+
+Package: kmod-i2c-algo-bit
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-i2c-core
+Source: package/kernel/linux
+SourceName: kmod-i2c-algo-bit
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4060
+Filename: kmod-i2c-algo-bit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4829
+SHA256sum: 4eeaf5a05c70ba0ce9c4b190e0d84d837cdc2c16300f2f0b33b06c7017d95ea3
+Description:  Kernel modules for I2C bit-banging interfaces
+
+Package: kmod-i2c-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-i2c-core
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 194
+Filename: kmod-i2c-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 939
+SHA256sum: 9efd996ea6c309df0814410edf35e267a5a398881a86fce6ebcb32c83694fcc9
+Description:  Kernel modules for I2C support
+
+Package: kmod-i2c-gpio
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-i2c-algo-bit
+Source: package/kernel/linux
+SourceName: kmod-i2c-gpio
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2895
+Filename: kmod-i2c-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3711
+SHA256sum: 16a5f0fd7948f6ff8d06327ca162902a632fa6df8377cabd888075dd321ff4f5
+Description:  Kernel modules for a very simple bitbanging I2C driver utilizing the
+ arch-neutral GPIO API to control the SCL and SDA lines.
+
+Package: kmod-ifb
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-ifb
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3893
+Filename: kmod-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4640
+SHA256sum: d1fb584bbcd365d42b1022061d896f8c206e370a5e90e62071d644b4d4e763fb
+Description:  The Intermediate Functional Block
+
+Package: kmod-ip6tables
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-reject6, kmod-nf-ipt6, kmod-ipt-core
+Source: package/kernel/linux
+SourceName: kmod-ip6tables
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7811
+Filename: kmod-ip6tables_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8579
+SHA256sum: 23910a0ae9f1d0c6a08ccf407218e3b13e95430fb608ac1a08b08f871b3a4df7
+Description:  Netfilter IPv6 firewalling support
+
+Package: kmod-ipsec
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-crypto-authenc, kmod-crypto-cbc, kmod-crypto-deflate, kmod-crypto-des, kmod-crypto-echainiv, kmod-crypto-hmac, kmod-crypto-md5, kmod-crypto-sha1
+Source: package/kernel/linux
+SourceName: kmod-ipsec
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 36675
+Filename: kmod-ipsec_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 37576
+SHA256sum: 8a658080c9bd7cbd45bbb02937594ccf4b08ddcee31b41c37c4f2d5ffbc51b84
+Description:  Kernel modules for IPsec support in both IPv4 and IPv6.
+ Includes:
+ - af_key
+ - xfrm_algo
+ - xfrm_ipcomp
+ - xfrm_user
+
+Package: kmod-ipt-conntrack-extra
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-ipt-conntrack
+Source: package/kernel/linux
+SourceName: kmod-ipt-conntrack-extra
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 15883
+Filename: kmod-ipt-conntrack-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 16687
+SHA256sum: 537466b8e846548416c708332afbc3d51dd265a4a6667048a05c4a1ffc00a679
+Description:  Netfilter (IPv4) extra kernel modules for connection tracking
+ Includes:
+ - connbytes
+ - connmark/CONNMARK
+ - conntrack
+ - helper
+ - recent
+
+Package: kmod-ipt-conntrack
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nf-conntrack
+Source: package/kernel/linux
+SourceName: kmod-ipt-conntrack
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 5683
+Filename: kmod-ipt-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 6511
+SHA256sum: decb42de6a8e98741caf5e56c1b76feb79d808e1822d1a12b440b133fa1ec2d0
+Description:  Netfilter (IPv4) kernel modules for connection tracking
+ Includes:
+ - conntrack
+ - defrag
+ - iptables_raw
+ - NOTRACK
+ - state
+
+Package: kmod-ipt-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-reject, kmod-nf-ipt
+Source: package/kernel/linux
+SourceName: kmod-ipt-core
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19087
+Filename: kmod-ipt-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19914
+SHA256sum: 499d2f2d7535e8a9c2fd166b0d7ff402eb1785c192f7b90d32e33e3bcb8dde82
+Description:  Netfilter core kernel modules
+ Includes:
+ - comment
+ - limit
+ - LOG
+ - mac
+ - multiport
+ - REJECT
+ - TCPMSS
+
+Package: kmod-ipt-extra
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core
+Source: package/kernel/linux
+SourceName: kmod-ipt-extra
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4949
+Filename: kmod-ipt-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5735
+SHA256sum: 38c1efef70579d036bb29f86b7789d9e7bdee1aab477a0d1a6aa52b6f38b2c07
+Description:  Other Netfilter (IPv4) kernel modules
+ Includes:
+ - addrtype
+ - owner
+ - pkttype
+ - quota
+
+Package: kmod-ipt-ipopt
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core
+Source: package/kernel/linux
+SourceName: kmod-ipt-ipopt
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8420
+Filename: kmod-ipt-ipopt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9270
+SHA256sum: 71d3990c99783a35b8e8ccea830d8775c236253aa1d1217cf919d6ea9d814963
+Description:  Netfilter (IPv4) modules for matching/changing IP packet options
+ Includes:
+ - CLASSIFY
+ - dscp/DSCP
+ - ecn/ECN
+ - hl/HL
+ - length
+ - mark/MARK
+ - statistic
+ - tcpmss
+ - time
+ - ttl/TTL
+ - unclean
+
+Package: kmod-ipt-ipset
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nfnetlink
+Source: package/kernel/linux
+SourceName: kmod-ipt-ipset
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 190089
+Filename: kmod-ipt-ipset_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 190471
+SHA256sum: 7d6e90709a3415a661e249d454bad296492478fff2e5a8f63cf6e0a3859111ae
+Description:  IPset netfilter modules
+
+Package: kmod-ipt-nat6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nf-nat6, kmod-ipt-core, kmod-ipt-conntrack, kmod-ipt-core, kmod-ipt-nat, kmod-ipt-core, kmod-ip6tables
+Source: package/kernel/linux
+SourceName: kmod-ipt-nat6
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3200
+Filename: kmod-ipt-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4009
+SHA256sum: dddd9df85d36c8dd4b5a533f205ef85dc18616d2e61609103e3b0eef4d2711e7
+Description:  Netfilter (IPv6) kernel modules for NAT targets
+
+Package: kmod-ipt-nat
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nf-nat
+Source: package/kernel/linux
+SourceName: kmod-ipt-nat
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4897
+Filename: kmod-ipt-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5697
+SHA256sum: 23662a9b9f863228f487dea0e27b03df1438b5e0bd1bf715b9c6c54ec87f2e51
+Description:  Netfilter (IPv4) kernel modules for basic NAT targets
+ Includes:
+ - MASQUERADE
+
+Package: kmod-ipt-offload
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-nf-flow
+Source: package/kernel/linux
+SourceName: kmod-ipt-offload
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3681
+Filename: kmod-ipt-offload_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4444
+SHA256sum: 60d11bc909d19b3ad22d11da1e0d16b6a111107d7fef4b43c83d1244ac46946b
+Description:  Netfilter routing/NAT offload support
+
+Package: kmod-ipt-physdev
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core, kmod-br-netfilter
+Source: package/kernel/linux
+SourceName: kmod-ipt-physdev
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2116
+Filename: kmod-ipt-physdev_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2876
+SHA256sum: e3c107bdce6809dfa6e135a7e6dd90bf8a9f3a5c7633de150322adf35ec1c464
+Description:  The iptables physdev kernel module
+
+Package: kmod-ipt-raw
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ipt-core
+Source: package/kernel/linux
+SourceName: kmod-ipt-raw
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1990
+Filename: kmod-ipt-raw_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2738
+SHA256sum: 7fef18cb8523b45ae631f1f4567c75ce85ad6421cabbdf7fcf8c00a9ee7ea33d
+Description:  Netfilter IPv4 raw table support
+
+Package: kmod-iptunnel4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-iptunnel4
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2378
+Filename: kmod-iptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3129
+SHA256sum: 6d2eb052d8c163cc7c42c45e9c3ca5233b95134e06b1b08690e4b15a01b43609
+Description:  Kernel modules for IPv4 tunneling
+
+Package: kmod-iptunnel
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-iptunnel
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10050
+Filename: kmod-iptunnel_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 10814
+SHA256sum: b19e970c8b804f5f151015d95bedcd5ba123db8fe00c9fc7b507dd38f94397c9
+Description:  Kernel module for generic IP tunnel support
+
+Package: kmod-leds-gpio
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-leds-gpio
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3205
+Filename: kmod-leds-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3961
+SHA256sum: 2e49775b993fad850ab2d40a3f1fba6d45f02c9079de42cc34d2c3efbd1ec0fa
+Description:  Kernel module for LEDs on GPIO lines
+
+Package: kmod-lib-crc-ccitt
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-lib-crc-ccitt
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2255
+Filename: kmod-lib-crc-ccitt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3042
+SHA256sum: beb15e1318b4bbd573e2839022e7028124791f5f2f61f0cfde834f0b6085d1f1
+Description:  Kernel module for CRC-CCITT support
+
+Package: kmod-lib-crc16
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-lib-crc16
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 231
+Filename: kmod-lib-crc16_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 977
+SHA256sum: d4309a20346c1510d9a5d7396f570ec747b8413f0074bb5209d73103f9669ed9
+Description:  Kernel module for CRC16 support
+
+Package: kmod-lib-zlib-deflate
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-lib-zlib-deflate
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 195
+Filename: kmod-lib-zlib-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 936
+SHA256sum: 234bb1b07b7d5be70906939d333616586f5a90256eebff69555d5d765ee12e2d
+Description:  Zlib support
+
+Package: kmod-lib-zlib-inflate
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-lib-zlib-inflate
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 196
+Filename: kmod-lib-zlib-inflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 933
+SHA256sum: 0df1bfd338aeebaa4efccccad46800f4743bc76f70f17a9808992fbe49757ad9
+Description:  Zlib support
+
+Package: kmod-mac80211
+Version: 5.4.102+5.10.16-1-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-cfg80211, hostapd-common, kmod-qca-nss-drv
+Source: package/kernel/mac80211
+SourceName: kmod-mac80211
+Section: kernel
+SourceDateEpoch: 1615144626
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 303688
+Filename: kmod-mac80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 301434
+SHA256sum: 2b176c5862fd0877a40f738a38428477f66e45d844db9c13faceefacc4802183
+Description:  Generic IEEE 802.11 Networking Stack (mac80211)
+
+Package: kmod-nf-conntrack-netlink
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nfnetlink, kmod-ipt-conntrack
+Source: package/kernel/linux
+SourceName: kmod-nf-conntrack-netlink
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 15796
+Filename: kmod-nf-conntrack-netlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 16559
+SHA256sum: a09b80ff737f35cb6e5d618ffbd85ba4a9b15802e30e201e5f5a38d09fa3d8c3
+Description:  Kernel modules support for a netlink-based connection tracking
+ userspace interface
+
+Package: kmod-nf-conntrack6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-conntrack
+Source: package/kernel/linux
+SourceName: kmod-nf-conntrack6
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-nf-conntrack6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 858
+SHA256sum: 24f886b48edeb73cc1abcb8477816914ba188c58cfd13ff8623485d005da8657
+Description:  Netfilter IPv6 connection tracking
+
+Package: kmod-nf-conntrack
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-nf-conntrack
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 53095
+Filename: kmod-nf-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 53631
+SHA256sum: a7b9d0e890b7e564fb808da2461c6772d1f178f93ed4a7a7f8b900fc253824e9
+Description:  Netfilter connection tracking
+
+Package: kmod-nf-flow
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-conntrack
+Source: package/kernel/linux
+SourceName: kmod-nf-flow
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12123
+Filename: kmod-nf-flow_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 12898
+SHA256sum: ecb476fc0c8f59c0ce722d5f7635a15a029349463a0ec926b431118692cfb17f
+Description:  Netfilter flowtable support
+
+Package: kmod-nf-ipt6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-ipt
+Source: package/kernel/linux
+SourceName: kmod-nf-ipt6
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 9054
+Filename: kmod-nf-ipt6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9819
+SHA256sum: 9860c42fb5a3eb38a4fc683d8316a048c1adf870acc4100ef29f51bc81e56590
+Description:  Ip6tables core
+
+Package: kmod-nf-ipt
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-nf-ipt
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 18634
+Filename: kmod-nf-ipt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19362
+SHA256sum: 085a2726ef99b6926909d2ed102544db5431c9668f4614ee072bc8dc90a205e3
+Description:  Iptables core
+
+Package: kmod-nf-nat6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-conntrack6, kmod-nf-nat
+Source: package/kernel/linux
+SourceName: kmod-nf-nat6
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-nf-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 857
+SHA256sum: 32b4d5313f95ad89beeb82cdc8a3c446397c0e9bfa3c307aca67d41efe18caaf
+Description:  Netfilter IPV6-NAT
+
+Package: kmod-nf-nat
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nf-conntrack
+Source: package/kernel/linux
+SourceName: kmod-nf-nat
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 14567
+Filename: kmod-nf-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 15303
+SHA256sum: 5fba5ee716b7a1be21bae6347a30484169db70ed3ac8d477ef2199e32af27a5b
+Description:  Netfilter NAT
+
+Package: kmod-nf-reject6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-nf-reject6
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2804
+Filename: kmod-nf-reject6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3557
+SHA256sum: fa0c4414489660e01daf420756c81c5fb37505e17ed241c11751ae338c5c2c85
+Description:  Netfilter IPv6 reject support
+
+Package: kmod-nf-reject
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-nf-reject
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2436
+Filename: kmod-nf-reject_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3175
+SHA256sum: 1e4bcbb0a57c20431f5a0450ed5d5f4b9d08d418eb96070d80f20b262338ac60
+Description:  Netfilter IPv4 reject support
+
+Package: kmod-nfnetlink
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-nfnetlink
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4753
+Filename: kmod-nfnetlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5511
+SHA256sum: 23c903195dfba2a30c71b8271289665a4b28e23f92782b2646fdd3d53d278ef6
+Description:  Kernel modules support for a netlink-based userspace interface
+
+Package: kmod-nls-base
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-nls-base
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 104
+Filename: kmod-nls-base_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 862
+SHA256sum: 41b25f2afda297291d4ba24adcc7ad62e9a40e8938e89e65cab083a98271dee9
+Description:  Kernel module for NLS (Native Language Support)
+
+Package: kmod-nls-cp1250
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+Source: package/kernel/linux
+SourceName: kmod-nls-cp1250
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2433
+Filename: kmod-nls-cp1250_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3214
+SHA256sum: de7a660d46582ee2e9b334d5db30429ccae4a130a2d30e865c36d8c08d4a9d7f
+Description:  Kernel module for NLS Codepage 1250 (Eastern Europe)
+
+Package: kmod-nls-cp437
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+Source: package/kernel/linux
+SourceName: kmod-nls-cp437
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2497
+Filename: kmod-nls-cp437_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3290
+SHA256sum: 78485440a70f2abb7df5853f0d3b1fe2a6e535a908a927a7db2dea34df261d48
+Description:  Kernel module for NLS Codepage 437 (United States, Canada)
+
+Package: kmod-nls-cp850
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+Source: package/kernel/linux
+SourceName: kmod-nls-cp850
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2454
+Filename: kmod-nls-cp850_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3226
+SHA256sum: 12323e2715082f383b6eaa706b438e58114a73ce00f455f314f4aa071527512c
+Description:  Kernel module for NLS Codepage 850 (Europe)
+
+Package: kmod-nls-iso8859-15
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+Source: package/kernel/linux
+SourceName: kmod-nls-iso8859-15
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2250
+Filename: kmod-nls-iso8859-15_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3014
+SHA256sum: 7c63b73ad51d241bffafc93ea7b4ae39477a23e84d70e9128c1ab4a8afe88998
+Description:  Kernel module for NLS ISO 8859-15 (Latin 9)
+
+Package: kmod-nls-iso8859-1
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+Source: package/kernel/linux
+SourceName: kmod-nls-iso8859-1
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2178
+Filename: kmod-nls-iso8859-1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2945
+SHA256sum: 46e0f3d3db733697385f1ba3b1473e571f9ca47f40c107f3a365648fc918096d
+Description:  Kernel module for NLS ISO 8859-1 (Latin 1)
+
+Package: kmod-nls-utf8
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+Source: package/kernel/linux
+SourceName: kmod-nls-utf8
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1424
+Filename: kmod-nls-utf8_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2203
+SHA256sum: e3363e1dbb37be11ae843e7b7bc02e3dcc909ba7ad1ab1f6cdcb25a6c7f34a1b
+Description:  Kernel module for NLS UTF-8
+
+Package: kmod-nss-ifb
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-drv
+Source: package/qca/nss-ifb
+SourceName: kmod-nss-ifb
+Section: kernel
+SourceDateEpoch: 1615144625
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3626
+Filename: kmod-nss-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4390
+SHA256sum: 4e3a5e8ec9241a3af992899f90648ba10e439f64001035db336031f273ada091
+Description:  Kernel module to register a NSS aware IFB interface.
+
+Package: kmod-phy-qcom-ipq806x-usb
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-phy-qcom-ipq806x-usb
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3160
+Filename: kmod-phy-qcom-ipq806x-usb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3981
+SHA256sum: 48fb22daa9c93b0e421b5c8566d2cc504ea8f4dcba6504fc99cc97c2ddb389ef
+Description:  This driver provides support for the integrated DesignWare
+ USB3 IP Core within the QCOM SoCs.
+
+Package: kmod-ppp
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-lib-crc-ccitt, kmod-slhc
+Source: package/kernel/linux
+SourceName: kmod-ppp
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 25100
+Filename: kmod-ppp_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 25832
+SHA256sum: f49c11762500f66275fab78cd779d5e032dbc197db82264633e07361c7437eac
+Description:  Kernel modules for PPP support
+
+Package: kmod-pppoe
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ppp, kmod-pppox
+Source: package/kernel/linux
+SourceName: kmod-pppoe
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 7839
+Filename: kmod-pppoe_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 8627
+SHA256sum: b825ea9ec31d8960715f9b2451122fd346fc2b3e97c89727f0fe1a169ed64daf
+Description:  Kernel module for PPPoE (PPP over Ethernet) support
+
+Package: kmod-pppox
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-ppp
+Source: package/kernel/linux
+SourceName: kmod-pppox
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 1986
+Filename: kmod-pppox_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2780
+SHA256sum: f197112792a8d95654a2253e659520c4b67165fbfd95fecf060bb1faf68409b3
+Description:  Kernel helper module for PPPoE and PPTP support
+
+Package: kmod-qca-nss-drv-pppoe
+Version: 5.4.102+740d0102-2
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-drv, kmod-pppoe, kmod-bonding
+Source: package/qca/qca-nss-clients
+SourceName: kmod-qca-nss-drv-pppoe
+Section: kernel
+SourceDateEpoch: 1615144625
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2688
+Filename: kmod-qca-nss-drv-pppoe_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3464
+SHA256sum: b755992f5b7fc71b3e41fd2a1692d323901149cb81fe5e1a8093b4a577388a66
+Description:  Kernel driver for NSS (connection manager) - PPPoE
+
+Package: kmod-qca-nss-drv-qdisc
+Version: 5.4.102+740d0102-2
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-drv
+Source: package/qca/qca-nss-clients
+SourceName: kmod-qca-nss-drv-qdisc
+Section: kernel
+SourceDateEpoch: 1615144625
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 29444
+Filename: kmod-qca-nss-drv-qdisc_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 30090
+SHA256sum: aa084496c6f3ac15a2c6af6f01c72d49c4318b592919201289b773abaae8b800
+Description:  Qdisc for configuring shapers in NSS
+
+Package: kmod-qca-nss-drv
+Version: 5.4.102+809a00de-2
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-gmac
+Source: package/qca/qca-nss-drv
+SourceName: kmod-qca-nss-drv
+Section: kernel
+SourceDateEpoch: 1615144625
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 392481
+Filename: kmod-qca-nss-drv_5.4.102+809a00de-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 390240
+SHA256sum: d447226c0b3917256a2b6624957245403cda870923b351bbc423b3538500b900
+Description:  Kernel driver for NSS (core driver)
+
+Package: kmod-qca-nss-ecm-standard
+Version: 5.4.102+9228212b-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-qca-nss-drv, iptables-mod-extra, kmod-ipt-conntrack, kmod-pppoe, kmod-ipsec
+Provides: kmod-qca-nss-ecm
+Source: package/qca/qca-nss-ecm
+SourceName: kmod-qca-nss-ecm-standard
+Section: kernel
+SourceDateEpoch: 1615144625
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 148892
+Filename: kmod-qca-nss-ecm-standard_5.4.102+9228212b-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 146899
+SHA256sum: 1682297eb7055dc93993322279071eb32b38543b1e0192bc43be4b88018efd21
+Description:  QCA NSS Enhanced Connection Manager (ECM)
+
+Package: kmod-qca-nss-gmac
+Version: 5.4.102+9b74deef-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/qca/qca-nss-gmac
+SourceName: kmod-qca-nss-gmac
+Section: kernel
+SourceDateEpoch: 1615144625
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 24622
+Filename: kmod-qca-nss-gmac_5.4.102+9b74deef-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 25229
+SHA256sum: e68d342bb8f8769127899c99590707e4f22a74158bf8232f7ce1cf18401b7b29
+Description:  Kernel driver for NSS gmac
+
+Package: kmod-sched-cake
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-sched-core
+Source: package/kernel/linux
+SourceName: kmod-sched-cake
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19366
+Filename: kmod-sched-cake_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 20121
+SHA256sum: 40d8c1b06b137c76a6866d9d4d8e40e0d7f5476b53292981d5095c0897710c73
+Description:  Common Applications Kept Enhanced fq_codel/blue derived shaper
+
+Package: kmod-sched-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-sched-core
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 61459
+Filename: kmod-sched-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 62236
+SHA256sum: 34acc0662734430fda7330ac91fbeb88eefd57e2c543f213ab1420b7f1a36c32
+Description:  Core kernel scheduler support for IP traffic
+
+Package: kmod-scsi-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-scsi-core
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 82273
+Filename: kmod-scsi-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 82675
+SHA256sum: 6d7419bab3a57a98ed678a50d37e3e8858fffd39c32de9ecdd29ec8cd546601a
+Description:  SCSI device support
+
+Package: kmod-sit
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-iptunnel, kmod-iptunnel4
+Source: package/kernel/linux
+SourceName: kmod-sit
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 12696
+Filename: kmod-sit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13453
+SHA256sum: 1c76fb8713dfba14674d12d4fbf22a93aae974c6119d11ff114bb60392418f69
+Description:  Kernel modules for IPv6-in-IPv4 tunnelling
+
+Package: kmod-slhc
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-lib-crc-ccitt
+Source: package/kernel/linux
+SourceName: kmod-slhc
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3972
+Filename: kmod-slhc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4721
+SHA256sum: a9d8bef4105955c6774619f3c567b3d6eefa4e2b8f3e6821fd928db9f4dd11ce
+Description:  Serial Line Header Compression
+
+Package: kmod-tun
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-tun
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 23435
+Filename: kmod-tun_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 24137
+SHA256sum: 617235132c52385b33ae44ba2ca2c9d92c9641fdebd52ae4dee89a6a1febb156
+Description:  Kernel support for the TUN/TAP tunneling device
+
+Package: kmod-udptunnel4
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-udptunnel4
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2637
+Filename: kmod-udptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 3385
+SHA256sum: ae79ebf67cef758e6055aba7be40bfb97358bb70d8b9b3cb3297a75713355939
+Description:  IPv4 UDP tunneling support
+
+Package: kmod-udptunnel6
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea)
+Source: package/kernel/linux
+SourceName: kmod-udptunnel6
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 2026
+Filename: kmod-udptunnel6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 2806
+SHA256sum: 5c03b4688fc39f63d3024458c8a15a7975fe83d2bd00a324b49d93d1700dcc28
+Description:  IPv6 UDP tunneling support
+
+Package: kmod-usb-core
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-nls-base
+Source: package/kernel/linux
+SourceName: kmod-usb-core
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 237
+Filename: kmod-usb-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 988
+SHA256sum: 08bf5e50bf393b73067695af071abdd489d969c143bf30b9ee97d338f7e898ca
+Description:  Kernel support for USB
+
+Package: kmod-usb-dwc3-qcom
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-dwc3, kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-usb-dwc3-qcom
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 4311
+Filename: kmod-usb-dwc3-qcom_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 5159
+SHA256sum: 1957f4b6ec4426f5c4058ec04f778e9a62c5190b19ce22d5d0286a2a66b08d55
+Description:  Some Qualcomm SoCs use DesignWare Core IP for USB2/3 functionality.
+ This driver also handles Qscratch wrapper which is needed for
+ peripheral mode support.
+
+Package: kmod-usb-dwc3
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-usb-dwc3
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 13036
+Filename: kmod-usb-dwc3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 13438
+SHA256sum: e6319c58edfe01a8e49d26353c44d37dec681db6c5cc898e98ab133531d523a1
+Description:  This driver provides support for the Dual Role SuperSpeed
+ USB Controller based on the Synopsys DesignWare USB3 IP Core
+
+Package: kmod-usb-ehci
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-usb-ehci
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 24905
+Filename: kmod-usb-ehci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 25600
+SHA256sum: 9a1d80225d41c89ba70af5b93b1b49855a3e4b6e97525333aeffdcd1f0ac20e4
+Description:  EHCI controller support
+
+Package: kmod-usb-ledtrig-usbport
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-usb-ledtrig-usbport
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 3376
+Filename: kmod-usb-ledtrig-usbport_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 4255
+SHA256sum: 44deed4de51be939b65947267e9974efec8d6ed8db2b998196d6d2913c8df248
+Description:  This driver allows LEDs to be controlled by USB events. Enabling this
+ trigger allows specifying list of USB ports that should turn on LED
+ when some USB device gets connected.
+ If possible it should be prefered over similar ledtrig-usbdev.
+
+Package: kmod-usb-ohci
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-usb-ohci
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 20938
+Filename: kmod-usb-ohci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 21664
+SHA256sum: 7b4e5f170049575315d39edec44026699361eef5b6c114ccb497d03095de69fe
+Description:  Kernel support for USB OHCI controllers
+
+Package: kmod-usb-storage
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-scsi-core, kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-usb-storage
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 23920
+Filename: kmod-usb-storage_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 24159
+SHA256sum: 27bcb8fc398ef74b88d0eed9bc0c8dcc4664338e6d4126597f99fc64a9c00455
+Description:  Kernel support for USB Mass Storage devices
+
+Package: kmod-usb2
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-ehci, kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-usb2
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 8830
+Filename: kmod-usb2_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 9623
+SHA256sum: 7373af3208352be5d40c12587a169888570b193e9e1d9036d5a004a16ab79037
+Description:  Kernel support for USB2 (EHCI) controllers
+
+Package: kmod-usb3
+Version: 5.4.102-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-usb-core
+Source: package/kernel/linux
+SourceName: kmod-usb3
+License: GPL-2.0
+Section: kernel
+SourceDateEpoch: 1610731471
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 73698
+Filename: kmod-usb3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 74047
+SHA256sum: d276da6724c3fd6866845565322acab4dcef8e18855b4afb0929f204a4104915
+Description:  Kernel support for USB3 (XHCI) controllers
+
+Package: kmod-wireguard
+Version: 5.4.102+1.0.20201112-1
+Depends: kernel (=5.4.102-1-c237bfa391adbb461d5b734fb701a4ea), kmod-udptunnel6, kmod-udptunnel4
+Source: package/network/services/wireguard
+SourceName: kmod-wireguard
+License: GPL-2.0
+LicenseFiles: COPYING
+Section: kernel
+SourceDateEpoch: 1605184118
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 62325
+Filename: kmod-wireguard_5.4.102+1.0.20201112-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 63345
+SHA256sum: a687250bbc274134fc32fb0c53c631267a23a766dcaa5f42e4ab0859ba1f60ab
+Description:  WireGuard is a novel VPN that runs inside the Linux Kernel and utilizes
+ state-of-the-art cryptography. It aims to be faster, simpler, leaner, and
+ more useful than IPSec, while avoiding the massive headache. It intends to
+ be considerably more performant than OpenVPN.  WireGuard is designed as a
+ general purpose VPN for running on embedded interfaces and super computers
+ alike, fit for many different circumstances. It uses UDP.
+ 
+ This package provides the kernel module for WireGuard.
+
+Package: libgcc1
+Version: 8.4.0-3
+Provides: libgcc
+Source: package/libs/toolchain
+SourceName: libgcc
+License: GPL-3.0-with-GCC-exception
+Section: libs
+SourceDateEpoch: 1608660710
+Status: unknown hold not-installed
+Essential: yes
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 21618
+Filename: libgcc1_8.4.0-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 22359
+SHA256sum: 37f88f846ceab4881e123e0a7e2a2b6f518731d451d104753eb7627b40192dcb
+Description:  GCC support library
+
+Package: libip4tc2
+Version: 1.8.7-1
+Depends: libc, libxtables12
+Provides: libip4tc
+Source: package/network/utils/iptables
+SourceName: libip4tc
+License: GPL-2.0
+Section: libs
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19419
+Filename: libip4tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 20225
+SHA256sum: fb847abccfc62b2f7d5626359f78b2c25cc18d70c676cfd4d2764b5e8af9d0c7
+Description:  IPv4 firewall - shared libiptc library
+
+Package: libip6tc2
+Version: 1.8.7-1
+Depends: libc, libxtables12
+Provides: libip6tc
+Source: package/network/utils/iptables
+SourceName: libip6tc
+License: GPL-2.0
+Section: libs
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 19166
+Filename: libip6tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 19950
+SHA256sum: 7aeb1242a1b5a92c5988b3d4fe06ceda652191b7b3f3fa4209f150459944ca83
+Description:  IPv6 firewall - shared libiptc library
+
+Package: libiwinfo-lua
+Version: 2021-01-31-4a32b33e-1
+Depends: libc, libiwinfo20210106, liblua5.1.5
+Source: package/network/utils/iwinfo
+SourceName: libiwinfo-lua
+License: GPL-2.0
+Section: lang
+SourceDateEpoch: 1613244049
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 6486
+Filename: libiwinfo-lua_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 7319
+SHA256sum: 7f33c091a00c20375d134f397a05af766e1ec3b1f26901205ffd5de2c3298e47
+Description:  This is the Lua binding for the iwinfo library. It provides access to all enabled
+ backends.
+
+Package: libiwinfo20210106
+Version: 2021-01-31-4a32b33e-1
+Depends: libc, libnl-tiny1, libuci20130104, libubus20210215
+Provides: libiwinfo
+Source: package/network/utils/iwinfo
+SourceName: libiwinfo
+License: GPL-2.0
+Section: libs
+SourceDateEpoch: 1613244049
+Maintainer: Jo-Philipp Wich <jo@mein.io>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 27056
+Filename: libiwinfo20210106_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 27863
+SHA256sum: 771654ccee4217bbb9f9c5aac4ad375518c7ea0d106a32999b01fe9fff48cc6e
+Description:  Wireless information library with consistent interface for proprietary Broadcom,
+ nl80211 and wext driver interfaces.
+
+Package: libpthread
+Version: 1.1.24-3
+Depends: libgcc1
+Source: package/libs/toolchain
+SourceName: libpthread
+License: GPL-3.0-with-GCC-exception
+Section: libs
+SourceDateEpoch: 1608660710
+Status: unknown hold not-installed
+Essential: yes
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 123
+Filename: libpthread_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 901
+SHA256sum: f63e55be34222c83559561af84dfebd7fd41ee8bbca83d569146c2ad3b75df94
+Description:  POSIX thread library
+
+Package: librt
+Version: 1.1.24-3
+Depends: libpthread
+Source: package/libs/toolchain
+SourceName: librt
+License: GPL-3.0-with-GCC-exception
+Section: libs
+SourceDateEpoch: 1608660710
+Status: unknown hold not-installed
+Essential: yes
+Maintainer: Felix Fietkau <nbd@nbd.name>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 123
+Filename: librt_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk
+Size: 914
+SHA256sum: 435a2fee28c48cf6bd8a151a3d7870e59113acd4b4968483741e05d77082d27b
+Description:  POSIX.1b RealTime extension library
+
+Package: libxtables12
+Version: 1.8.7-1
+Depends: libc
+Provides: libxtables
+Source: package/network/utils/iptables
+SourceName: libxtables
+License: GPL-2.0
+Section: libs
+SourceDateEpoch: 1613474876
+CPE-ID: cpe:/a:netfilter_core_team:iptables
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 44803
+Filename: libxtables12_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 45562
+SHA256sum: f26ba200a1e99e7751dfc840bb63a5432c38076afc90a26d2d7373ed2879d870
+Description:  IPv4/IPv6 firewall - shared xtables library
+
+Package: mtd
+Version: 26
+Depends: libc, libubox20201212
+Source: package/system/mtd
+SourceName: mtd
+License: GPL-2.0+
+Section: utils
+SourceDateEpoch: 1598818715
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 10472
+Filename: mtd_26_arm_cortex-a15_neon-vfpv4.ipk
+Size: 11254
+SHA256sum: c1d7fe43485744b4964c9cd28025fd3bd996a34835a90e3b112100df3280f593
+Description:  This package contains an utility useful to upgrade from other firmware or 
+ older OpenWrt releases.
+
+Package: ubi-utils
+Version: 2.1.2-1
+Depends: libc
+Source: package/utils/mtd-utils
+SourceName: ubi-utils
+License: GPLv2
+Section: utils
+SourceDateEpoch: 1607289697
+Maintainer: John Crispin <john@phrozen.org>
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 76703
+Filename: ubi-utils_2.1.2-1_arm_cortex-a15_neon-vfpv4.ipk
+Size: 77341
+SHA256sum: 28cd663e33e7a8c1ba0906dbc1aec04b4f5bd819a6313c22b3e2ae149183a8d0
+Description:  Utilities for manipulating memory technology devices.
+
+Package: uboot-envtools
+Version: 2021.01-2
+Depends: libc
+Source: package/boot/uboot-envtools
+SourceName: uboot-envtools
+License: GPL-2.0 GPL-2.0+
+LicenseFiles: Licenses/README
+Section: utils
+SourceDateEpoch: 1614631808
+Architecture: arm_cortex-a15_neon-vfpv4
+Installed-Size: 13653
+Filename: uboot-envtools_2021.01-2_arm_cortex-a15_neon-vfpv4.ipk
+Size: 14425
+SHA256sum: 4fc815d64ce10ac07ef2de2fd753a50ec6097a005791f5777df5bd41c5842931
+Description:  This package includes tools to read and modify U-Boot bootloader environment.
+
diff --git a/bin/targets/ipq806x/generic/packages/Packages.sig b/bin/targets/ipq806x/generic/packages/Packages.sig
new file mode 100644
index 0000000000..f31e673ea1
--- /dev/null
+++ b/bin/targets/ipq806x/generic/packages/Packages.sig
@@ -0,0 +1,2 @@
+untrusted comment: signed by key d1f1809848731cb7
+RWTR8YCYSHMctyt3xzS8AbkGrYZeEAocxAUXt9I5MW+JaEvABsCK5mmW6Cov3LBnCssjdUm2TZ920mCZmWLyP3uaCfeeE642sQc=
diff --git a/bin/targets/ipq806x/generic/packages/base-files_1405-r15878+18-8b3d879861_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/base-files_1405-r15878+18-8b3d879861_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..f407b11cdc
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/base-files_1405-r15878+18-8b3d879861_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/block-mount_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/block-mount_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..51edba42ae
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/block-mount_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/dropbear_2020.81-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/dropbear_2020.81-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..daed7e505d
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/dropbear_2020.81-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/fstools_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/fstools_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..76eba6bbef
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/fstools_2021-01-04-c53b1882-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/fwtool_2019-11-12-8f7fe925-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/fwtool_2019-11-12-8f7fe925-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..afe0983a02
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/fwtool_2019-11-12-8f7fe925-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/ip6tables-mod-nat_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/ip6tables-mod-nat_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c8a0bd6141
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/ip6tables-mod-nat_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/ip6tables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/ip6tables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..73feb3372d
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/ip6tables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/iptables-mod-conntrack-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/iptables-mod-conntrack-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..16847c98f3
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/iptables-mod-conntrack-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/iptables-mod-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/iptables-mod-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..085cad600c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/iptables-mod-extra_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/iptables-mod-ipopt_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/iptables-mod-ipopt_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..219a1c5217
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/iptables-mod-ipopt_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/iptables-mod-physdev_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/iptables-mod-physdev_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..3c9402fc9d
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/iptables-mod-physdev_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/iptables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/iptables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..467d6ba761
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/iptables_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/iwinfo_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/iwinfo_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..122223e68b
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/iwinfo_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kernel_5.4.102-1-c237bfa391adbb461d5b734fb701a4ea_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kernel_5.4.102-1-c237bfa391adbb461d5b734fb701a4ea_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8192ccae17
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kernel_5.4.102-1-c237bfa391adbb461d5b734fb701a4ea_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ata-ahci-platform_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ata-ahci-platform_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..74e88930c6
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ata-ahci-platform_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ata-ahci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ata-ahci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..7034444bf8
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ata-ahci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ata-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ata-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..022ace9419
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ata-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ath10k-ct_5.4.102+2021-01-11-9fe1df7d-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ath10k-ct_5.4.102+2021-01-11-9fe1df7d-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..11db7582bc
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ath10k-ct_5.4.102+2021-01-11-9fe1df7d-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ath_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ath_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c5c38154ce
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ath_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-bonding_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-bonding_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2adfc96832
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-bonding_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-br-netfilter_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-br-netfilter_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..7409a5d82c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-br-netfilter_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-cfg80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-cfg80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..417d5973d0
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-cfg80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-acompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-acompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..88834bbba1
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-acompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-aead_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-aead_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..81d782d33b
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-aead_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-arc4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-arc4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c36f5d5732
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-arc4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-authenc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-authenc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..4162fb5933
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-authenc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-cbc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-cbc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0185f28806
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-cbc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-ccm_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-ccm_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..db955ee0dd
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-ccm_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-cmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-cmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0729c03091
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-cmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-crc32c_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-crc32c_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d37191af04
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-crc32c_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-ctr_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-ctr_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..ac8a34f499
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-ctr_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..20c35bbb78
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-des_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-des_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..45dc42330a
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-des_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-ecb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-ecb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..b207a87c01
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-ecb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-echainiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-echainiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..54b5883d78
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-echainiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-hash_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-hash_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..dbcf21ea97
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-hash_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-hmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-hmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..795902a31d
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-hmac_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-manager_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-manager_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..3e5aaa458b
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-manager_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-md4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-md4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..47bdeec67c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-md4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-md5_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-md5_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..a722afcfe8
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-md5_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-null_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-null_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..6cdc945b0b
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-null_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-pcompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-pcompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..345d1fdf91
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-pcompress_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-rng_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-rng_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..e79f6595b8
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-rng_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-seqiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-seqiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..69f70519e1
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-seqiv_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-sha1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-sha1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..fddb21174f
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-sha1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-sha256_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-sha256_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9da7166edc
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-sha256_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-crypto-sha512_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-crypto-sha512_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..039efa9fe9
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-crypto-sha512_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-cryptodev_5.4.102+1.11-ipq806x-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-cryptodev_5.4.102+1.11-ipq806x-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2dd7f9cc0f
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-cryptodev_5.4.102+1.11-ipq806x-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-fs-cifs_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-fs-cifs_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..400c1edf68
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-fs-cifs_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-fs-exfat_5.4.102+5.10.1-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-fs-exfat_5.4.102+5.10.1-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..57b2a8b2f6
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-fs-exfat_5.4.102+5.10.1-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-fs-ext4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-fs-ext4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..dbb784b386
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-fs-ext4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-fs-hfsplus_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-fs-hfsplus_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..eb8c8bf612
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-fs-hfsplus_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-fs-msdos_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-fs-msdos_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..48075a6edf
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-fs-msdos_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-fs-vfat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-fs-vfat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..50d6ef3fee
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-fs-vfat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-fuse_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-fuse_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0facc2cdbc
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-fuse_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-gpio-button-hotplug_5.4.102-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-gpio-button-hotplug_5.4.102-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..6e96496aa8
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-gpio-button-hotplug_5.4.102-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-hwmon-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-hwmon-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9d2604f44d
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-hwmon-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-i2c-algo-bit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-i2c-algo-bit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..3cf15d7a29
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-i2c-algo-bit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-i2c-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-i2c-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..961d3d6e0d
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-i2c-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-i2c-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-i2c-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..a39153dbf0
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-i2c-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0105e2747b
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ip6tables_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ip6tables_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d0ffa6cd7a
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ip6tables_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipsec_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipsec_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..80bb0a6a3c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipsec_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-conntrack-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-conntrack-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1ab7b4aa4c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-conntrack-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..60ef463d0a
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c342972b13
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..aed5026d16
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-extra_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-ipopt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-ipopt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..00ce369d01
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-ipopt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-ipset_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-ipset_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..511c082175
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-ipset_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c626e2052a
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..e1209a70b0
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-offload_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-offload_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d52b39ab90
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-offload_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-physdev_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-physdev_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..b917a53b64
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-physdev_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ipt-raw_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ipt-raw_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..6971fcc25f
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ipt-raw_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-iptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-iptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1464da7f17
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-iptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-iptunnel_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-iptunnel_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..3981542802
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-iptunnel_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-leds-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-leds-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0f10d5f6e6
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-leds-gpio_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-lib-crc-ccitt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-lib-crc-ccitt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..38b1511066
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-lib-crc-ccitt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-lib-crc16_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-lib-crc16_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c32445335e
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-lib-crc16_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-lib-zlib-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-lib-zlib-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..0f71153147
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-lib-zlib-deflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-lib-zlib-inflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-lib-zlib-inflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..f19bb25063
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-lib-zlib-inflate_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-mac80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-mac80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..ffd43c2820
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-mac80211_5.4.102+5.10.16-1-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack-netlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack-netlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1f06b60996
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack-netlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..f0c35c1f40
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8e9308eef3
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-conntrack_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-flow_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-flow_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..a132a97874
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-flow_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-ipt6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-ipt6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c1f73c0a5b
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-ipt6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-ipt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-ipt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..27ca5620e9
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-ipt_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..48a76fea7b
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-nat6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..91e73f2832
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-nat_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-reject6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-reject6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..eb85c1426a
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-reject6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nf-reject_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nf-reject_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..e8d04eb8ef
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nf-reject_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nfnetlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nfnetlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..99b563a68a
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nfnetlink_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nls-base_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nls-base_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..ec8b7413fe
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nls-base_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nls-cp1250_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nls-cp1250_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..13ad9abd27
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nls-cp1250_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nls-cp437_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nls-cp437_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..32ded55410
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nls-cp437_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nls-cp850_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nls-cp850_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..3e51516669
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nls-cp850_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nls-iso8859-15_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nls-iso8859-15_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d98e4d8c6e
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nls-iso8859-15_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nls-iso8859-1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nls-iso8859-1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..48bce03084
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nls-iso8859-1_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nls-utf8_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nls-utf8_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8219697611
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nls-utf8_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-nss-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-nss-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..53cf5e00c4
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-nss-ifb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-phy-qcom-ipq806x-usb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-phy-qcom-ipq806x-usb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..c90fbda21c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-phy-qcom-ipq806x-usb_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-ppp_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-ppp_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9389e6319b
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-ppp_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-pppoe_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-pppoe_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..37d796eb67
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-pppoe_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-pppox_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-pppox_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2e533d4b74
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-pppox_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv-pppoe_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv-pppoe_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1e3b4c6982
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv-pppoe_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv-qdisc_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv-qdisc_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..7d6f235c93
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv-qdisc_5.4.102+740d0102-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv_5.4.102+809a00de-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv_5.4.102+809a00de-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..968560b7e7
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-drv_5.4.102+809a00de-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-qca-nss-ecm-standard_5.4.102+9228212b-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-ecm-standard_5.4.102+9228212b-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..98fc8a64f2
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-ecm-standard_5.4.102+9228212b-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-qca-nss-gmac_5.4.102+9b74deef-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-gmac_5.4.102+9b74deef-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..e5c42eca53
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-qca-nss-gmac_5.4.102+9b74deef-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-sched-cake_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-sched-cake_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9677b166dd
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-sched-cake_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-sched-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-sched-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..eb8ce81af7
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-sched-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-scsi-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-scsi-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..f6f5f6d44c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-scsi-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-sit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-sit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..ee722a723a
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-sit_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-slhc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-slhc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..514d060f4a
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-slhc_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-tun_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-tun_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..8c1f875374
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-tun_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-udptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-udptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..1e213496d7
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-udptunnel4_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-udptunnel6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-udptunnel6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..f4dbbae164
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-udptunnel6_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..51d383fb8c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb-core_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb-dwc3-qcom_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb-dwc3-qcom_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2204a2bbcd
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb-dwc3-qcom_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb-dwc3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb-dwc3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..af833d49f6
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb-dwc3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb-ehci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb-ehci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..f7da4c050c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb-ehci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb-ledtrig-usbport_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb-ledtrig-usbport_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..67c3dee39c
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb-ledtrig-usbport_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb-ohci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb-ohci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..6599cf0bb0
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb-ohci_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb-storage_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb-storage_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9479046b2d
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb-storage_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb2_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb2_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..20bf54c281
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb2_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-usb3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-usb3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..32aebbe0b7
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-usb3_5.4.102-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/kmod-wireguard_5.4.102+1.0.20201112-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/kmod-wireguard_5.4.102+1.0.20201112-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..5eb9f646a1
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/kmod-wireguard_5.4.102+1.0.20201112-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/libc_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/libc_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9659896eed
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/libc_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/libgcc1_8.4.0-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/libgcc1_8.4.0-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9408a34946
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/libgcc1_8.4.0-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/libip4tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/libip4tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..3e7cbd02cc
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/libip4tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/libip6tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/libip6tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..9b487e8ede
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/libip6tc2_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/libiwinfo-lua_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/libiwinfo-lua_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..06ff481ce1
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/libiwinfo-lua_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/libiwinfo20210106_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/libiwinfo20210106_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..df759811f5
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/libiwinfo20210106_2021-01-31-4a32b33e-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/libpthread_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/libpthread_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..2aab2371bd
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/libpthread_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/librt_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/librt_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..62a087d5f7
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/librt_1.1.24-3_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/libxtables12_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/libxtables12_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..cdb961ccc3
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/libxtables12_1.8.7-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/mtd_26_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/mtd_26_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..6253577d49
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/mtd_26_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/ubi-utils_2.1.2-1_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/ubi-utils_2.1.2-1_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..3fb8ee9658
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/ubi-utils_2.1.2-1_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/packages/uboot-envtools_2021.01-2_arm_cortex-a15_neon-vfpv4.ipk b/bin/targets/ipq806x/generic/packages/uboot-envtools_2021.01-2_arm_cortex-a15_neon-vfpv4.ipk
new file mode 100644
index 0000000000..d0a787b07f
Binary files /dev/null and b/bin/targets/ipq806x/generic/packages/uboot-envtools_2021.01-2_arm_cortex-a15_neon-vfpv4.ipk differ
diff --git a/bin/targets/ipq806x/generic/sha256sums b/bin/targets/ipq806x/generic/sha256sums
new file mode 100644
index 0000000000..77fc1b2828
--- /dev/null
+++ b/bin/targets/ipq806x/generic/sha256sums
@@ -0,0 +1,28 @@
+7d8ee638aba995a837ab642f7239453469a3e578bf332682ba92e21c38d68e19 *config.buildinfo
+1305917163b4502842ea223d09172cd73616d2a36055037e01b58551e63a6c52 *feeds.buildinfo
+9373d01046188d49b4133bff706ccd529ee12fea3500b6fdee32130d0fcad836 *openwrt-ipq806x-generic-asrock_g10-initramfs-fit-uImage.itb
+9c9c4d56b0298f4e8287b685fd90fdcf3fd5c5ea1dcdbdc8e5d30c6678461e94 *openwrt-ipq806x-generic-asrock_g10-squashfs-nand-factory.bin
+3a4fe3e5bc249f94f5a8732d3186262b81064d5ee2d5a541af583ed03e93e457 *openwrt-ipq806x-generic-asrock_g10-squashfs-nand-sysupgrade.bin
+10a683fc16ca8da0fd5f8cf6d54a20f34c930431db2727d47d65d00b6e049055 *openwrt-ipq806x-generic-linksys_ea7500-v1-initramfs-uImage
+ea0790ec5058c7aa5c4469600d76bcd5d9c9ba024d81a8ca78849c2e0b6a415f *openwrt-ipq806x-generic-linksys_ea7500-v1-squashfs-factory.bin
+12a4936b3020087eb542b2f37152691a3a413c69992fb1698adfa5e410c15288 *openwrt-ipq806x-generic-linksys_ea7500-v1-squashfs-sysupgrade.bin
+4da1bb4d0758599e61f67254a8c0ce8aed0399406d9cc0ced99d31a4be55bee9 *openwrt-ipq806x-generic-linksys_ea8500-initramfs-uImage
+4c43ca3ce949f6d936dd885611eb394c4e60f15187e37f185c07d3fd4b3c3787 *openwrt-ipq806x-generic-linksys_ea8500-squashfs-factory.bin
+645a4258636474a1849f4532cc7d6174d6f8e04b35dd6b8ea08d87c467604859 *openwrt-ipq806x-generic-linksys_ea8500-squashfs-sysupgrade.bin
+ada58c372ebc4b74099bd8cc032df0e7219f2b61b33bbd0b19faca7ba98d2dfb *openwrt-ipq806x-generic-netgear_r7500-initramfs-uImage
+39f006223b96445ffb8b9267acc73e727bbe6ae0168856c4b1c515e9d1db0097 *openwrt-ipq806x-generic-netgear_r7500-squashfs-factory.img
+6136d7eebe86b480a162b9f456be2f3e27028c5d943f5d93a944c48a90137da8 *openwrt-ipq806x-generic-netgear_r7500-squashfs-sysupgrade.bin
+27e9b5048ac5696740c4faadc406dada2bc0791f6ac3a25402d458a172b737e9 *openwrt-ipq806x-generic-netgear_r7500v2-initramfs-uImage
+abef46fbae5c5739f3dea631774f171309282850545069b3b474eb9956076e1d *openwrt-ipq806x-generic-netgear_r7500v2-squashfs-factory.img
+636e8553f14d36d4ca4d4b020369a4be611efebd0fb51c5dde351a9a1fd40f91 *openwrt-ipq806x-generic-netgear_r7500v2-squashfs-sysupgrade.bin
+39789d5cfd2a82dd5c6d431696adf7c909738b67a04b779a9f690e87d7adf00b *openwrt-ipq806x-generic-netgear_r7800-initramfs-uImage
+887b9f2a32aae0f37784aa4b2579406f81a441f4f4ca364e74f3b613c87c204d *openwrt-ipq806x-generic-netgear_r7800-squashfs-factory.img
+bf4e4b416fe6e98885cc73a798d8521a15bb20d04e67bcbb8b0784cc3103dfeb *openwrt-ipq806x-generic-netgear_r7800-squashfs-sysupgrade.bin
+215094184a8687441ae5f9f29dbba9e5a78d24f72b92e1dbb08fc0eddc30bc4d *openwrt-ipq806x-generic-tplink_c2600-initramfs-uImage
+a9ba85ac5d8e5b18a6f963e523abcf4c2fbb2ee7d5e5bbaa5b9ebf16245b4133 *openwrt-ipq806x-generic-tplink_c2600-squashfs-factory.bin
+e199e1572bb91c697f6439671853d636b02fbe27f867a8b72c5d1529ddbb6fcf *openwrt-ipq806x-generic-tplink_c2600-squashfs-sysupgrade.bin
+621029694c22100525f1b963851bcc718c4ba4f97c09aae2a268c3552c40272d *openwrt-ipq806x-generic-zyxel_nbg6817-initramfs-uImage
+c6faf56aa884753b0db71370ae06f76dd7c5adfae5da74cb7f7f0eb63ca6857f *openwrt-ipq806x-generic-zyxel_nbg6817-squashfs-factory.bin
+3fd31c0c0e73973e140c8a2e28de5db72080b0688f609c21b559dd2280f43b98 *openwrt-ipq806x-generic-zyxel_nbg6817-squashfs-sysupgrade.bin
+da7e89687618a16390a86b647d3384336be3c87df1dac73f6afacd08a2d26878 *openwrt-ipq806x-generic.manifest
+9a27aa584fee8685db4ba62f3bf9702e47e808761b8452365232a3bed782fd86 *version.buildinfo
diff --git a/bin/targets/ipq806x/generic/version.buildinfo b/bin/targets/ipq806x/generic/version.buildinfo
new file mode 100644
index 0000000000..30628d06bd
--- /dev/null
+++ b/bin/targets/ipq806x/generic/version.buildinfo
@@ -0,0 +1 @@
+r15878+18-8b3d879861
diff --git a/diffconfig b/diffconfig
new file mode 100644
index 0000000000..6bb8773fdc
--- /dev/null
+++ b/diffconfig
@@ -0,0 +1,127 @@
+# Use "make defconfig" to expand this to a full .config
+CONFIG_TARGET_ipq806x=y
+CONFIG_TARGET_ipq806x_generic=y
+CONFIG_TARGET_MULTI_PROFILE=y
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_netgear_r7800=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_netgear_r7800=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_linksys_ea8500=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_linksys_ea8500=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_linksys_ea7500-v1=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_linksys_ea7500-v1=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_tplink_c2600=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_tplink_c2600=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_netgear_r7500=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_netgear_r7500=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_netgear_r7500v2=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_netgear_r7500v2=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_zyxel_nbg6817=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_zyxek_nbg6817=""
+CONFIG_TARGET_DEVICE_ipq806x_generic_DEVICE_asrock_g10=y
+CONFIG_TARGET_DEVICE_PACKAGES_ipq806x_generic_DEVICE_asrock_g10=""
+CONFIG_TARGET_PER_DEVICE_ROOTFS=y
+
+# exfat is patented
+CONFIG_BUILD_PATENTED=y
+
+# NSS Drivers
+CONFIG_PACKAGE_kmod-qca-nss-drv=y
+CONFIG_PACKAGE_kmod-qca-nss-drv-qdisc=y
+CONFIG_PACKAGE_kmod-qca-nss-ecm-standard=y
+CONFIG_PACKAGE_kmod-qca-nss-gmac=y
+CONFIG_PACKAGE_kmod-nss-ifb=y
+CONFIG_PACKAGE_iptables-mod-physdev=y
+CONFIG_PACKAGE_kmod-ipt-physdev=y
+CONFIG_PACKAGE_kmod-qca-nss-drv-pppoe=y
+CONFIG_PACKAGE_MAC80211_NSS_SUPPORT=y
+
+# Longer waiting for failsafe button push
+CONFIG_IMAGEOPT=y
+CONFIG_PREINITOPT=y
+CONFIG_TARGET_PREINIT_TIMEOUT=5
+
+# Busybox tweaks
+CONFIG_BUSYBOX_CUSTOM=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_EDITING_SAVEHISTORY=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_EDITING_SAVE_ON_EXIT=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_LESS_FLAGS=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_LESS_REGEXP=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_LESS_WINCH=y
+
+# Add-on programs
+CONFIG_PACKAGE_irqbalance=y
+CONFIG_DROPBEAR_ECC=y
+CONFIG_PACKAGE_openvpn-openssl=y
+CONFIG_PACKAGE_htop=y
+CONFIG_PACKAGE_kmod-cryptodev=y
+CONFIG_PACKAGE_libopenssl-devcrypto=y
+
+# USB device mount & file systems support
+CONFIG_PACKAGE_block-mount=y
+CONFIG_PACKAGE_kmod-usb-storage=y
+CONFIG_PACKAGE_kmod-fs-cifs=y
+CONFIG_PACKAGE_kmod-fs-exfat=y
+CONFIG_PACKAGE_libblkid=y
+CONFIG_PACKAGE_kmod-fs-ext4=y
+CONFIG_PACKAGE_kmod-fs-hfsplus=y
+CONFIG_PACKAGE_kmod-fs-msdos=y
+CONFIG_PACKAGE_kmod-fs-vfat=y
+CONFIG_PACKAGE_ntfs-3g=y
+CONFIG_PACKAGE_kmod-nls-cp1250=y
+CONFIG_PACKAGE_kmod-nls-cp437=y
+CONFIG_PACKAGE_kmod-nls-cp850=y
+CONFIG_PACKAGE_kmod-nls-iso8859-1=y
+CONFIG_PACKAGE_kmod-nls-iso8859-15=y
+CONFIG_PACKAGE_kmod-nls-utf8=y
+
+# IPv6 support
+CONFIG_PACKAGE_6in4=y
+CONFIG_PACKAGE_6to4=y
+CONFIG_PACKAGE_6rd=y
+
+# IPv6 NAT support (ip6tables NAT extensions, ipt-nat6 and nf-nat6 kmods)
+CONFIG_PACKAGE_ip6tables-mod-nat=y
+
+# WLAN/WPS support
+CONFIG_PACKAGE_hostapd-utils=y
+CONFIG_WPA_MSG_MIN_PRIORITY=4
+CONFIG_PACKAGE_wpad-openssl=y
+# CONFIG_PACKAGE_wpad-basic-wolfssl is not set
+# CONFIG_PACKAGE_libustream-wolfssl is not set
+
+# SSL certificates
+CONFIG_PACKAGE_ca-certificates=y
+
+# Luci (SSL from OpenSSL)
+CONFIG_PACKAGE_luci-ssl-openssl=y
+CONFIG_PACKAGE_luci-app-commands=y
+CONFIG_PACKAGE_luci-app-sqm=y
+CONFIG_PACKAGE_luci-app-dawn=y
+CONFIG_PACKAGE_luci-app-adblock=y
+CONFIG_PACKAGE_luci-app-openvpn=y
+CONFIG_PACKAGE_luci-app-ddns=y
+CONFIG_PACKAGE_luci-app-wireguard=y
+CONFIG_PACKAGE_luci-theme-openwrt-2020=y
+CONFIG_PACKAGE_luci-app-bcp38=y
+CONFIG_PACKAGE_luci-app-banip=y
+
+# Luci statistics
+CONFIG_PACKAGE_luci-app-statistics=y
+CONFIG_PACKAGE_collectd-mod-conntrack=y
+CONFIG_PACKAGE_collectd-mod-cpufreq=y
+CONFIG_PACKAGE_collectd-mod-dhcpleases=y
+CONFIG_PACKAGE_collectd-mod-entropy=y
+CONFIG_PACKAGE_collectd-mod-exec=y
+CONFIG_PACKAGE_collectd-mod-interface=y
+CONFIG_PACKAGE_collectd-mod-iwinfo=y
+CONFIG_PACKAGE_collectd-mod-load=y
+CONFIG_PACKAGE_collectd-mod-memory=y
+CONFIG_PACKAGE_collectd-mod-network=y
+CONFIG_PACKAGE_collectd-mod-ping=y
+CONFIG_PACKAGE_collectd-mod-sqm=y
+CONFIG_PACKAGE_collectd-mod-thermal=y
+CONFIG_PACKAGE_collectd-mod-wireless=y
+CONFIG_PACKAGE_collectd-mod-uptime=y
+
+# nlbwmon app
+CONFIG_PACKAGE_luci-app-nlbwmon=y
+
diff --git a/package/kernel/ath10k-ct/patches/999-ath10k-Enable-802.11-encap-offload-in-tx-path.patch b/package/kernel/ath10k-ct/patches/999-ath10k-Enable-802.11-encap-offload-in-tx-path.patch
new file mode 100644
index 0000000000..08755c1839
--- /dev/null
+++ b/package/kernel/ath10k-ct/patches/999-ath10k-Enable-802.11-encap-offload-in-tx-path.patch
@@ -0,0 +1,315 @@
+--- a/ath10k-5.10/core.c
++++ b/ath10k-5.10/core.c
+@@ -37,6 +37,7 @@ static bool uart_print;
+ static bool skip_otp;
+ static bool rawmode;
+ static bool fw_diag_log;
++static bool ethernetmode;
+ 
+ unsigned long ath10k_coredump_mask = BIT(ATH10K_FW_CRASH_DUMP_REGISTERS) |
+ 				     BIT(ATH10K_FW_CRASH_DUMP_CE_DATA);
+@@ -54,6 +55,7 @@ module_param(skip_otp, bool, 0644);
+ module_param(rawmode, bool, 0644);
+ module_param(fw_diag_log, bool, 0644);
+ module_param_named(coredump_mask, ath10k_coredump_mask, ulong, 0444);
++module_param(ethernetmode, bool, 0644);
+ 
+ MODULE_PARM_DESC(debug_mask, "Debugging mask");
+ MODULE_PARM_DESC(uart_print, "Uart target debugging");
+@@ -62,6 +64,7 @@ MODULE_PARM_DESC(cryptmode, "Crypto mode
+ MODULE_PARM_DESC(rawmode, "Use raw 802.11 frame datapath");
+ MODULE_PARM_DESC(coredump_mask, "Bitfield of what to include in firmware crash file");
+ MODULE_PARM_DESC(fw_diag_log, "Diag based fw log debugging");
++MODULE_PARM_DESC(ethernetmode, "Use ethernet frame datapath");
+ 
+ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
+ 	{
+@@ -3936,6 +3939,14 @@ static void ath10k_core_register_work(st
+ 	/* peer stats are enabled by default */
+ 	set_bit(ATH10K_FLAG_PEER_STATS, &ar->dev_flags);
+ 
++	if (ethernetmode && rawmode) {
++		ath10k_err(ar, "invalid configuration, ethernet and rawmode data path can not coexist\n");
++		status = -EINVAL;
++		goto err;
++	}
++
++	ar->ethernetmode = ethernetmode;
++
+ 	status = ath10k_core_probe_fw(ar);
+ 	if (status) {
+ 		ath10k_err(ar, "could not probe fw (%d)\n", status);
+--- a/ath10k-5.10/core.h
++++ b/ath10k-5.10/core.h
+@@ -122,6 +122,7 @@ enum ath10k_skb_flags {
+ 	ATH10K_SKB_F_QOS = BIT(4),
+ 	ATH10K_SKB_F_RAW_TX = BIT(5),
+ 	ATH10K_SKB_F_NOACK_TID = BIT(6),
++	ATH10K_SKB_F_HW_80211_ENCAP = BIT(7),
+ };
+ 
+ /* This uses same mem structure as the struct ieee80211_tx_info.  First 12
+@@ -1663,6 +1664,8 @@ struct ath10k {
+ 	const char *led_default_trigger;
+ #endif
+ 
++	bool ethernetmode;
++
+ 	/* must be last */
+ 	u8 drv_priv[] __aligned(sizeof(void *));
+ };
+--- a/ath10k-5.10/htt_tx.c
++++ b/ath10k-5.10/htt_tx.c
+@@ -1195,6 +1195,10 @@ static u8 ath10k_htt_tx_get_tid(struct s
+ 	struct ieee80211_hdr *hdr = (void *)skb->data;
+ 	struct ath10k_skb_cb *cb = ATH10K_SKB_CB(skb);
+ 
++	/* Firmware takes care of tid classification for ethernet format */
++	if (cb->flags & ATH10K_SKB_F_HW_80211_ENCAP)
++		return skb->priority & IEEE80211_QOS_CTL_TID_MASK;
++
+ 	if (!is_eth && ieee80211_is_mgmt(hdr->frame_control))
+ 		return HTT_DATA_TX_EXT_TID_MGMT;
+ 
+@@ -1640,12 +1644,14 @@ skip_fixed_rate:
+ 	}
+ 
+ 	if (!(skb_cb->flags & ATH10K_SKB_F_NO_HWCRYPT)) {
+-		if (ieee80211_is_robust_mgmt_frame_tx(hdr) &&
+-		    ieee80211_has_protected(hdr->frame_control)) {
+-			skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
+-		} else if (txmode == ATH10K_HW_TXRX_RAW &&
+-			   ieee80211_has_protected(hdr->frame_control)) {
+-			skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
++		if (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)) {
++			if (ieee80211_is_robust_mgmt_frame_tx(hdr) &&
++		    	ieee80211_has_protected(hdr->frame_control)) {
++				skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
++			} else if (txmode == ATH10K_HW_TXRX_RAW &&
++			   	ieee80211_has_protected(hdr->frame_control)) {
++				skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
++			}
+ 		}
+ 	}
+ 
+--- a/ath10k-5.10/mac.c
++++ b/ath10k-5.10/mac.c
+@@ -4293,12 +4293,16 @@ ath10k_mac_tx_h_get_txmode(struct ath10k
+ 			   struct sk_buff *skb)
+ {
+ 	const struct ieee80211_hdr *hdr = (void *)skb->data;
++	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+ 	const struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);
+ 	__le16 fc = hdr->frame_control;
+ 
+ 	if (!vif || vif->type == NL80211_IFTYPE_MONITOR)
+ 		return ATH10K_HW_TXRX_RAW;
+ 
++	if (tx_info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)
++		return ATH10K_HW_TXRX_ETHERNET;
++
+ 	/* CT Firmware with HTT-TX support sends all frames, including
+ 	 * management frames, over HTT in NATIVE-WIFI format.
+ 	 */
+@@ -4478,6 +4482,15 @@ static void ath10k_mac_tx_h_fill_cb(stru
+ 	bool noack = false;
+ 
+ 	cb->flags = 0;
++	cb->vif = vif;
++	cb->txq = txq;
++	cb->airtime_est = airtime;
++
++	if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {
++		cb->flags |= ATH10K_SKB_F_HW_80211_ENCAP;
++		return;
++	}
++
+ 	if (!ath10k_tx_h_use_hwcrypto(vif, skb))
+ 		cb->flags |= ATH10K_SKB_F_NO_HWCRYPT;
+ 
+@@ -4516,9 +4529,6 @@ static void ath10k_mac_tx_h_fill_cb(stru
+ 		cb->flags |= ATH10K_SKB_F_RAW_TX;
+ 	}
+ 
+-	cb->vif = vif;
+-	cb->txq = txq;
+-	cb->airtime_est = airtime;
+ 	if (sta) {
+ 		arsta = (struct ath10k_sta *)sta->drv_priv;
+ 		spin_lock_bh(&ar->data_lock);
+@@ -4637,6 +4647,9 @@ static int ath10k_mac_tx(struct ath10k *
+ 	const struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);
+ 	int ret;
+ 
++	if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)
++		goto skip_encap;
++
+ 	/* We should disable CCK RATE due to P2P */
+ 	if (info->flags & IEEE80211_TX_CTL_NO_CCK_RATE)
+ 		ath10k_dbg(ar, ATH10K_DBG_MAC, "IEEE80211_TX_CTL_NO_CCK_RATE\n");
+@@ -4665,6 +4678,7 @@ static int ath10k_mac_tx(struct ath10k *
+ 		}
+ 	}
+ 
++skip_encap:
+ 	if (!noque_offchan && info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) {
+ 		if (!ath10k_mac_tx_frm_has_freq(ar)) {
+ 			ath10k_dbg(ar, ATH10K_DBG_MAC, "mac queued offchannel skb %pK len %d\n",
+@@ -4714,6 +4728,7 @@ void ath10k_offchan_tx_work(struct work_
+ 	int ret;
+ 	unsigned long time_left;
+ 	bool tmp_peer_created = false;
++	struct ieee80211_tx_info *info;
+ 
+ 	/* FW requirement: We must create a peer before FW will send out
+ 	 * an offchannel frame. Otherwise the frame will be stuck and
+@@ -4733,8 +4748,14 @@ void ath10k_offchan_tx_work(struct work_
+ 		ath10k_dbg(ar, ATH10K_DBG_MAC, "mac offchannel skb %pK len %d\n",
+ 			   skb, skb->len);
+ 
+-		hdr = (struct ieee80211_hdr *)skb->data;
+-		peer_addr = ieee80211_get_DA(hdr);
++		info = IEEE80211_SKB_CB(skb);
++
++		if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {
++			peer_addr = skb->data;
++		} else {
++			hdr = (struct ieee80211_hdr *)skb->data;
++			peer_addr = ieee80211_get_DA(hdr);
++		}
+ 
+ 		spin_lock_bh(&ar->data_lock);
+ 		vdev_id = ar->scan.vdev_id;
+@@ -5352,14 +5373,19 @@ static void ath10k_mac_op_tx(struct ieee
+ 			return;
+ 		}
+ 
+-		ret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);
+-		if (ret) {
+-			ath10k_dbg(ar, ATH10K_DBG_MAC, "failed to increase tx mgmt pending count: %d, dropping\n",
+-				   ret);
+-			ath10k_htt_tx_dec_pending(htt);
+-			spin_unlock_bh(&ar->htt.tx_lock);
+-			ieee80211_free_txskb(ar->hw, skb);
+-			return;
++		if (is_mgmt) {
++			hdr = (struct ieee80211_hdr *)skb->data;
++			is_presp = ieee80211_is_probe_resp(hdr->frame_control);
++
++			ret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);
++			if (ret) {
++				ath10k_dbg(ar, ATH10K_DBG_MAC, "failed to increase tx mgmt pending count: %d, dropping\n",
++				   	ret);
++				ath10k_htt_tx_dec_pending(htt);
++				spin_unlock_bh(&ar->htt.tx_lock);
++				ieee80211_free_txskb(ar->hw, skb);
++				return;
++			}
+ 		}
+ 		spin_unlock_bh(&ar->htt.tx_lock);
+ 	}
+@@ -6214,6 +6240,36 @@ static int ath10k_mac_set_txbf_conf(stru
+ 					 ar->wmi.vdev_param->txbf, value);
+ }
+ 
++static void ath10k_mac_op_update_vif_offload(struct ieee80211_hw *hw,
++					     struct ieee80211_vif *vif)
++{
++	struct ath10k *ar = hw->priv;
++	struct ath10k_vif *arvif = (void *)vif->drv_priv;
++
++	u32 vdev_param, param_value;
++	int ret;
++
++	vdev_param = ar->wmi.vdev_param->tx_encap_type;
++	if (!ar->ethernetmode ||
++			(vif->type != NL80211_IFTYPE_STATION &&
++			 vif->type != NL80211_IFTYPE_AP))
++		vif->offload_flags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;
++
++	if (vif->offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
++		param_value = ATH10K_HW_TXRX_ETHERNET;
++	else
++		param_value = ATH10K_HW_TXRX_NATIVE_WIFI;
++
++	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,
++					param_value);
++
++	if (ret) {
++		ath10k_info(ar, "failed to set vdev %i TX encapsulation: %d\n",
++			    arvif->vdev_id, ret);
++		vif->offload_flags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;
++	}
++}
++
+ /*
+  * TODO:
+  * Figure out how to handle WMI_VDEV_SUBTYPE_P2P_DEVICE,
+@@ -6415,15 +6471,7 @@ static int ath10k_add_interface(struct i
+ 
+ 	arvif->def_wep_key_idx = -1;
+ 
+-	vdev_param = ar->wmi.vdev_param->tx_encap_type;
+-	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,
+-					ATH10K_HW_TXRX_NATIVE_WIFI);
+-	/* 10.X firmware does not support this VDEV parameter. Do not warn */
+-	if (ret && ret != -EOPNOTSUPP) {
+-		ath10k_warn(ar, "failed to set vdev %i TX encapsulation: %d\n",
+-			    arvif->vdev_id, ret);
+-		goto err_vdev_delete;
+-	}
++	ath10k_mac_op_update_vif_offload(hw, vif);
+ 
+ 	/* Configuring number of spatial stream for monitor interface is causing
+ 	 * target assert in qca9888 and qca6174.
+@@ -10345,6 +10393,7 @@ static const struct ieee80211_ops ath10k
+ 	.config				= ath10k_config,
+ 	.add_interface			= ath10k_add_interface,
+ 	.remove_interface		= ath10k_remove_interface,
++	.update_vif_offload		= ath10k_mac_op_update_vif_offload,
+ 	.configure_filter		= ath10k_configure_filter,
+ 	.bss_info_changed		= ath10k_bss_info_changed,
+ 	.set_coverage_class		= ath10k_mac_op_set_coverage_class,
+@@ -11089,7 +11138,6 @@ int ath10k_mac_register(struct ath10k *a
+ 	ieee80211_hw_set(ar->hw, HAS_RATE_CONTROL);
+ 	ieee80211_hw_set(ar->hw, AP_LINK_PS);
+ 	ieee80211_hw_set(ar->hw, SPECTRUM_MGMT);
+-	ieee80211_hw_set(ar->hw, SUPPORT_FAST_XMIT);
+ 	if (ar->bmiss_offload_max_vdev > 0)
+ 		ieee80211_hw_set(ar->hw, CONNECTION_MONITOR);
+ 	ieee80211_hw_set(ar->hw, SUPPORTS_PER_STA_GTK);
+@@ -11099,6 +11147,11 @@ int ath10k_mac_register(struct ath10k *a
+ 	ieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);
+ 	ieee80211_hw_set(ar->hw, REPORTS_LOW_ACK);
+ 
++	if(ar->ethernetmode)
++		ieee80211_hw_set(ar->hw, SUPPORTS_TX_ENCAP_OFFLOAD);
++	else
++		ieee80211_hw_set(ar->hw, SUPPORT_FAST_XMIT);
++
+ 	if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))
+ 		ieee80211_hw_set(ar->hw, SW_CRYPTO_CONTROL);
+ 
+--- a/ath10k-5.10/txrx.c
++++ b/ath10k-5.10/txrx.c
+@@ -166,6 +166,7 @@ int ath10k_txrx_tx_unref(struct ath10k_h
+ 	struct ath10k_skb_cb *skb_cb;
+ 	struct ath10k_txq *artxq;
+ 	struct sk_buff *msdu;
++	struct ieee80211_vif *vif;
+ 	u8 flags;
+ 	bool tx_failed = false;
+ 
+@@ -317,7 +318,11 @@ int ath10k_txrx_tx_unref(struct ath10k_h
+ 	}
+ #endif
+ 
+-	ieee80211_tx_status(htt->ar->hw, msdu);
++	if (flags & ATH10K_SKB_F_HW_80211_ENCAP)
++		ieee80211_tx_status_8023(htt->ar->hw, vif, msdu);
++	else
++		ieee80211_tx_status(htt->ar->hw, msdu);
++
+ 	/* we do not own the msdu anymore */
+ 
+ 	return 0;
diff --git a/package/kernel/mac80211/Makefile b/package/kernel/mac80211/Makefile
index f6ad06452f..a54cb938b0 100644
--- a/package/kernel/mac80211/Makefile
+++ b/package/kernel/mac80211/Makefile
@@ -84,6 +84,7 @@ config-$(CONFIG_PACKAGE_CFG80211_TESTMODE) += NL80211_TESTMODE
 
 config-$(call config_package,mac80211) += MAC80211
 config-$(CONFIG_PACKAGE_MAC80211_MESH) += MAC80211_MESH
+config-$(CONFIG_PACKAGE_MAC80211_NSS_SUPPORT) += MAC80211_NSS_SUPPORT
 
 include ath.mk
 include broadcom.mk
@@ -127,7 +128,7 @@ define KernelPackage/mac80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=Linux 802.11 Wireless Networking Stack
   # +kmod-crypto-cmac is a runtime only dependency of net/mac80211/aes_cmac.c
-  DEPENDS+= +kmod-cfg80211 +hostapd-common
+  DEPENDS+= +kmod-cfg80211 +hostapd-common +PACKAGE_kmod-qca-nss-drv:kmod-qca-nss-drv
   KCONFIG:=\
 	CONFIG_AVERAGE=y
   FILES:= $(PKG_BUILD_DIR)/net/mac80211/mac80211.ko
@@ -138,6 +139,15 @@ endef
 define KernelPackage/mac80211/config
   if PACKAGE_kmod-mac80211
 
+	if PACKAGE_kmod-qca-nss-drv
+		config PACKAGE_MAC80211_NSS_SUPPORT
+			bool "Enable NSS support for IPQ platform"
+			default y
+			help
+			  This option enables support for NSS in boards
+			  like Netgear R7800.
+	endif
+
 	config PACKAGE_MAC80211_DEBUGFS
 		bool "Export mac80211 internals in DebugFS"
 		select KERNEL_DEBUG_FS
@@ -436,7 +446,8 @@ config-$(CONFIG_LEDS_TRIGGERS) += MAC80211_LEDS
 
 MAKE_OPTS:= -C "$(PKG_BUILD_DIR)" \
 	$(KERNEL_MAKE_FLAGS) \
-	EXTRA_CFLAGS="-I$(PKG_BUILD_DIR)/include $(IREMAP_CFLAGS)" \
+	EXTRA_CFLAGS="-I$(PKG_BUILD_DIR)/include $(IREMAP_CFLAGS) \
+		      -I$(STAGING_DIR)/usr/include/qca-nss-drv" \
 	KLIB_BUILD="$(LINUX_DIR)" \
 	MODPROBE=true \
 	KLIB=$(TARGET_MODULES_DIR) \
diff --git a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
index 92c56afd24..8e6092483e 100644
--- a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
+++ b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
@@ -107,7 +107,7 @@ mac80211_hostapd_setup_base() {
 	[ -n "$acs_exclude_dfs" ] && [ "$acs_exclude_dfs" -gt 0 ] &&
 		append base_cfg "acs_exclude_dfs=1" "$N"
 
-	json_get_vars noscan ht_coex
+	json_get_vars noscan ht_coex vendor_vht
 	json_get_values ht_capab_list ht_capab tx_burst
 	json_get_values channel_list channels
 
@@ -230,7 +230,7 @@ mac80211_hostapd_setup_base() {
 	esac
 	[ "$hwmode" = "a" ] || enable_ac=0
 
-	if [ "$enable_ac" != "0" ]; then
+	if [ "$enable_ac" != "0" -o "$vendor_vht" = "1" ]; then
 		json_get_vars \
 			rxldpc:1 \
 			short_gi_80:1 \
diff --git a/package/kernel/mac80211/patches/ath/983-ath10k-allow-vht-on-2g.patch b/package/kernel/mac80211/patches/ath/983-ath10k-allow-vht-on-2g.patch
new file mode 100644
index 0000000000..eeca88a613
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath/983-ath10k-allow-vht-on-2g.patch
@@ -0,0 +1,10 @@
+--- a/drivers/net/wireless/ath/ath10k/mac.c
++++ b/drivers/net/wireless/ath/ath10k/mac.c
+@@ -4718,6 +4718,7 @@ static void ath10k_mac_setup_ht_vht_cap(
+ 	if (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {
+ 		band = &ar->mac.sbands[NL80211_BAND_2GHZ];
+ 		band->ht_cap = ht_cap;
++		band->vht_cap = vht_cap;
+ 	}
+ 	if (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {
+ 		band = &ar->mac.sbands[NL80211_BAND_5GHZ];
diff --git a/package/kernel/mac80211/patches/ath/999-ath10k-Enable-802.11-encap-offload-in-tx-path.patch b/package/kernel/mac80211/patches/ath/999-ath10k-Enable-802.11-encap-offload-in-tx-path.patch
new file mode 100644
index 0000000000..6e8934f224
--- /dev/null
+++ b/package/kernel/mac80211/patches/ath/999-ath10k-Enable-802.11-encap-offload-in-tx-path.patch
@@ -0,0 +1,347 @@
+--- a/drivers/net/wireless/ath/ath10k/core.c
++++ b/drivers/net/wireless/ath/ath10k/core.c
+@@ -35,6 +35,7 @@ static bool uart_print;
+ static bool skip_otp;
+ static bool rawmode;
+ static bool fw_diag_log;
++static bool ethernetmode = true;
+ 
+ unsigned long ath10k_coredump_mask = BIT(ATH10K_FW_CRASH_DUMP_REGISTERS) |
+ 				     BIT(ATH10K_FW_CRASH_DUMP_CE_DATA);
+@@ -47,6 +48,7 @@ module_param(skip_otp, bool, 0644);
+ module_param(rawmode, bool, 0644);
+ module_param(fw_diag_log, bool, 0644);
+ module_param_named(coredump_mask, ath10k_coredump_mask, ulong, 0444);
++module_param(ethernetmode, bool, 0644);
+ 
+ MODULE_PARM_DESC(debug_mask, "Debugging mask");
+ MODULE_PARM_DESC(uart_print, "Uart target debugging");
+@@ -55,6 +57,7 @@ MODULE_PARM_DESC(cryptmode, "Crypto mode
+ MODULE_PARM_DESC(rawmode, "Use raw 802.11 frame datapath");
+ MODULE_PARM_DESC(coredump_mask, "Bitfield of what to include in firmware crash file");
+ MODULE_PARM_DESC(fw_diag_log, "Diag based fw log debugging");
++MODULE_PARM_DESC(ethernetmode, "Use ethernet frame datapath");
+ 
+ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
+ 	{
+@@ -3135,6 +3138,14 @@ static void ath10k_core_register_work(st
+ 	/* peer stats are enabled by default */
+ 	set_bit(ATH10K_FLAG_PEER_STATS, &ar->dev_flags);
+ 
++	if (ethernetmode && rawmode) {
++		ath10k_err(ar, "invalid configuration, ethernet and rawmode data path can not coexist\n");
++		status = -EINVAL;
++		goto err;
++	}
++
++	ar->ethernetmode = ethernetmode;
++
+ 	status = ath10k_core_probe_fw(ar);
+ 	if (status) {
+ 		ath10k_err(ar, "could not probe fw (%d)\n", status);
+--- a/drivers/net/wireless/ath/ath10k/core.h
++++ b/drivers/net/wireless/ath/ath10k/core.h
+@@ -113,6 +113,7 @@ enum ath10k_skb_flags {
+ 	ATH10K_SKB_F_QOS = BIT(4),
+ 	ATH10K_SKB_F_RAW_TX = BIT(5),
+ 	ATH10K_SKB_F_NOACK_TID = BIT(6),
++	ATH10K_SKB_F_HW_80211_ENCAP = BIT(7),
+ };
+ 
+ struct ath10k_skb_cb {
+@@ -1294,6 +1295,8 @@ struct ath10k {
+ 	const char *led_default_trigger;
+ #endif
+ 
++	bool ethernetmode;
++
+ 	/* must be last */
+ 	u8 drv_priv[] __aligned(sizeof(void *));
+ };
+--- a/drivers/net/wireless/ath/ath10k/htt_tx.c
++++ b/drivers/net/wireless/ath/ath10k/htt_tx.c
+@@ -1187,6 +1187,10 @@ static u8 ath10k_htt_tx_get_tid(struct s
+ 	struct ieee80211_hdr *hdr = (void *)skb->data;
+ 	struct ath10k_skb_cb *cb = ATH10K_SKB_CB(skb);
+ 
++	/* Firmware takes care of tid classification for ethernet format */
++	if (cb->flags & ATH10K_SKB_F_HW_80211_ENCAP)
++		return skb->priority & IEEE80211_QOS_CTL_TID_MASK;
++
+ 	if (!is_eth && ieee80211_is_mgmt(hdr->frame_control))
+ 		return HTT_DATA_TX_EXT_TID_MGMT;
+ 	else if (cb->flags & ATH10K_SKB_F_QOS)
+@@ -1434,15 +1438,17 @@ static int ath10k_htt_tx_32(struct ath10
+ 	txbuf_paddr = htt->txbuf.paddr +
+ 		      (sizeof(struct ath10k_htt_txbuf_32) * msdu_id);
+ 
+-	if ((ieee80211_is_action(hdr->frame_control) ||
+-	     ieee80211_is_deauth(hdr->frame_control) ||
+-	     ieee80211_is_disassoc(hdr->frame_control)) &&
+-	     ieee80211_has_protected(hdr->frame_control)) {
+-		skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
+-	} else if (!(skb_cb->flags & ATH10K_SKB_F_NO_HWCRYPT) &&
+-		   txmode == ATH10K_HW_TXRX_RAW &&
+-		   ieee80211_has_protected(hdr->frame_control)) {
+-		skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
++	if (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)) {
++		if ((ieee80211_is_action(hdr->frame_control) ||
++		     ieee80211_is_deauth(hdr->frame_control) ||
++		     ieee80211_is_disassoc(hdr->frame_control)) &&
++		    ieee80211_has_protected(hdr->frame_control)) {
++			skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
++		} else if (!(skb_cb->flags & ATH10K_SKB_F_NO_HWCRYPT) &&
++			   txmode == ATH10K_HW_TXRX_RAW &&
++			   ieee80211_has_protected(hdr->frame_control)) {
++			skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
++		}
+ 	}
+ 
+ 	skb_cb->paddr = dma_map_single(dev, msdu->data, msdu->len,
+--- a/drivers/net/wireless/ath/ath10k/mac.c
++++ b/drivers/net/wireless/ath/ath10k/mac.c
+@@ -3573,12 +3573,16 @@ ath10k_mac_tx_h_get_txmode(struct ath10k
+ 			   struct sk_buff *skb)
+ {
+ 	const struct ieee80211_hdr *hdr = (void *)skb->data;
++	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
+ 	const struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);
+ 	__le16 fc = hdr->frame_control;
+ 
+ 	if (!vif || vif->type == NL80211_IFTYPE_MONITOR)
+ 		return ATH10K_HW_TXRX_RAW;
+ 
++	if (tx_info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)
++		return ATH10K_HW_TXRX_ETHERNET;
++
+ 	if (ieee80211_is_mgmt(fc))
+ 		return ATH10K_HW_TXRX_MGMT;
+ 
+@@ -3736,6 +3740,15 @@ static void ath10k_mac_tx_h_fill_cb(stru
+ 	bool noack = false;
+ 
+ 	cb->flags = 0;
++	cb->vif = vif;
++	cb->txq = txq;
++	cb->airtime_est = airtime;
++
++	if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {
++		cb->flags |= ATH10K_SKB_F_HW_80211_ENCAP;
++		return;
++	}
++
+ 	if (!ath10k_tx_h_use_hwcrypto(vif, skb))
+ 		cb->flags |= ATH10K_SKB_F_NO_HWCRYPT;
+ 
+@@ -3774,9 +3787,6 @@ static void ath10k_mac_tx_h_fill_cb(stru
+ 		cb->flags |= ATH10K_SKB_F_RAW_TX;
+ 	}
+ 
+-	cb->vif = vif;
+-	cb->txq = txq;
+-	cb->airtime_est = airtime;
+ 	if (sta) {
+ 		arsta = (struct ath10k_sta *)sta->drv_priv;
+ 		spin_lock_bh(&ar->data_lock);
+@@ -3892,6 +3902,9 @@ static int ath10k_mac_tx(struct ath10k *
+ 	const struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);
+ 	int ret;
+ 
++	if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)
++		goto skip_encap;
++
+ 	/* We should disable CCK RATE due to P2P */
+ 	if (info->flags & IEEE80211_TX_CTL_NO_CCK_RATE)
+ 		ath10k_dbg(ar, ATH10K_DBG_MAC, "IEEE80211_TX_CTL_NO_CCK_RATE\n");
+@@ -3915,6 +3928,7 @@ static int ath10k_mac_tx(struct ath10k *
+ 		}
+ 	}
+ 
++skip_encap:
+ 	if (!noque_offchan && info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) {
+ 		if (!ath10k_mac_tx_frm_has_freq(ar)) {
+ 			ath10k_dbg(ar, ATH10K_DBG_MAC, "mac queued offchannel skb %pK len %d\n",
+@@ -3964,6 +3978,7 @@ void ath10k_offchan_tx_work(struct work_
+ 	int ret;
+ 	unsigned long time_left;
+ 	bool tmp_peer_created = false;
++	struct ieee80211_tx_info *info;
+ 
+ 	/* FW requirement: We must create a peer before FW will send out
+ 	 * an offchannel frame. Otherwise the frame will be stuck and
+@@ -3983,8 +3998,14 @@ void ath10k_offchan_tx_work(struct work_
+ 		ath10k_dbg(ar, ATH10K_DBG_MAC, "mac offchannel skb %pK len %d\n",
+ 			   skb, skb->len);
+ 
+-		hdr = (struct ieee80211_hdr *)skb->data;
+-		peer_addr = ieee80211_get_DA(hdr);
++		info = IEEE80211_SKB_CB(skb);
++
++		if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {
++			peer_addr = skb->data;
++		} else {
++			hdr = (struct ieee80211_hdr *)skb->data;
++			peer_addr = ieee80211_get_DA(hdr);
++		}
+ 
+ 		spin_lock_bh(&ar->data_lock);
+ 		vdev_id = ar->scan.vdev_id;
+@@ -4517,7 +4538,7 @@ static void ath10k_mac_op_tx(struct ieee
+ 	struct ieee80211_vif *vif = info->control.vif;
+ 	struct ieee80211_sta *sta = control->sta;
+ 	struct ieee80211_txq *txq = NULL;
+-	struct ieee80211_hdr *hdr = (void *)skb->data;
++	struct ieee80211_hdr *hdr;
+ 	enum ath10k_hw_txrx_mode txmode;
+ 	enum ath10k_mac_tx_path txpath;
+ 	bool is_htt;
+@@ -4537,7 +4558,6 @@ static void ath10k_mac_op_tx(struct ieee
+ 
+ 	if (is_htt) {
+ 		spin_lock_bh(&ar->htt.tx_lock);
+-		is_presp = ieee80211_is_probe_resp(hdr->frame_control);
+ 
+ 		ret = ath10k_htt_tx_inc_pending(htt);
+ 		if (ret) {
+@@ -4548,14 +4568,19 @@ static void ath10k_mac_op_tx(struct ieee
+ 			return;
+ 		}
+ 
+-		ret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);
+-		if (ret) {
+-			ath10k_dbg(ar, ATH10K_DBG_MAC, "failed to increase tx mgmt pending count: %d, dropping\n",
+-				   ret);
+-			ath10k_htt_tx_dec_pending(htt);
+-			spin_unlock_bh(&ar->htt.tx_lock);
+-			ieee80211_free_txskb(ar->hw, skb);
+-			return;
++		if (is_mgmt) {
++			hdr = (struct ieee80211_hdr *)skb->data;
++			is_presp = ieee80211_is_probe_resp(hdr->frame_control);
++
++			ret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);
++			if (ret) {
++				ath10k_dbg(ar, ATH10K_DBG_MAC, "failed to increase tx mgmt pending count: %d, dropping\n",
++				   	   ret);
++				ath10k_htt_tx_dec_pending(htt);
++				spin_unlock_bh(&ar->htt.tx_lock);
++				ieee80211_free_txskb(ar->hw, skb);
++				return;
++			}
+ 		}
+ 		spin_unlock_bh(&ar->htt.tx_lock);
+ 	}
+@@ -5378,6 +5403,36 @@ static int ath10k_mac_set_txbf_conf(stru
+ 					 ar->wmi.vdev_param->txbf, value);
+ }
+ 
++static void ath10k_mac_op_update_vif_offload(struct ieee80211_hw *hw,
++					   struct ieee80211_vif *vif)
++{
++	struct ath10k *ar = hw->priv;
++	struct ath10k_vif *arvif = (void *)vif->drv_priv;
++
++	u32 vdev_param, param_value;
++	int ret;
++
++	vdev_param = ar->wmi.vdev_param->tx_encap_type;
++	if (!ar->ethernetmode ||
++			(vif->type != NL80211_IFTYPE_STATION &&
++			 vif->type != NL80211_IFTYPE_AP))
++		vif->offload_flags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;
++
++	if (vif->offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)
++		param_value = ATH10K_HW_TXRX_ETHERNET;
++	else
++		param_value = ATH10K_HW_TXRX_NATIVE_WIFI;
++
++	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,
++					param_value);
++
++	if (ret) {
++		ath10k_info(ar, "failed to set vdev %i TX encapsulation: %d\n",
++			    arvif->vdev_id, ret);
++		vif->offload_flags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;
++	}
++}
++
+ /*
+  * TODO:
+  * Figure out how to handle WMI_VDEV_SUBTYPE_P2P_DEVICE,
+@@ -5571,15 +5626,7 @@ static int ath10k_add_interface(struct i
+ 
+ 	arvif->def_wep_key_idx = -1;
+ 
+-	vdev_param = ar->wmi.vdev_param->tx_encap_type;
+-	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,
+-					ATH10K_HW_TXRX_NATIVE_WIFI);
+-	/* 10.X firmware does not support this VDEV parameter. Do not warn */
+-	if (ret && ret != -EOPNOTSUPP) {
+-		ath10k_warn(ar, "failed to set vdev %i TX encapsulation: %d\n",
+-			    arvif->vdev_id, ret);
+-		goto err_vdev_delete;
+-	}
++	ath10k_mac_op_update_vif_offload(hw, vif);
+ 
+ 	/* Configuring number of spatial stream for monitor interface is causing
+ 	 * target assert in qca9888 and qca6174.
+@@ -9260,6 +9307,7 @@ static const struct ieee80211_ops ath10k
+ 	.config				= ath10k_config,
+ 	.add_interface			= ath10k_add_interface,
+ 	.remove_interface		= ath10k_remove_interface,
++	.update_vif_offload		= ath10k_mac_op_update_vif_offload,
+ 	.configure_filter		= ath10k_configure_filter,
+ 	.bss_info_changed		= ath10k_bss_info_changed,
+ 	.set_coverage_class		= ath10k_mac_op_set_coverage_class,
+@@ -9877,7 +9925,6 @@ int ath10k_mac_register(struct ath10k *a
+ 	ieee80211_hw_set(ar->hw, HAS_RATE_CONTROL);
+ 	ieee80211_hw_set(ar->hw, AP_LINK_PS);
+ 	ieee80211_hw_set(ar->hw, SPECTRUM_MGMT);
+-	ieee80211_hw_set(ar->hw, SUPPORT_FAST_XMIT);
+ 	ieee80211_hw_set(ar->hw, CONNECTION_MONITOR);
+ 	ieee80211_hw_set(ar->hw, SUPPORTS_PER_STA_GTK);
+ 	ieee80211_hw_set(ar->hw, WANT_MONITOR_VIF);
+@@ -9886,6 +9933,11 @@ int ath10k_mac_register(struct ath10k *a
+ 	ieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);
+ 	ieee80211_hw_set(ar->hw, REPORTS_LOW_ACK);
+ 
++	if(ar->ethernetmode)
++		ieee80211_hw_set(ar->hw, SUPPORTS_TX_ENCAP_OFFLOAD);
++	else
++		ieee80211_hw_set(ar->hw, SUPPORT_FAST_XMIT);
++
+ 	if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))
+ 		ieee80211_hw_set(ar->hw, SW_CRYPTO_CONTROL);
+ 
+--- a/drivers/net/wireless/ath/ath10k/txrx.c
++++ b/drivers/net/wireless/ath/ath10k/txrx.c
+@@ -50,6 +50,7 @@ int ath10k_txrx_tx_unref(struct ath10k_h
+ 	struct ath10k_skb_cb *skb_cb;
+ 	struct ath10k_txq *artxq;
+ 	struct sk_buff *msdu;
++	struct ieee80211_vif *vif;
+ 	u8 flags;
+ 
+ 	ath10k_dbg(ar, ATH10K_DBG_HTT,
+@@ -80,6 +81,8 @@ int ath10k_txrx_tx_unref(struct ath10k_h
+ 	}
+ 
+ 	flags = skb_cb->flags;
++	vif = skb_cb->vif;
++
+ 	ath10k_htt_tx_free_msdu_id(htt, tx_done->msdu_id);
+ 	ath10k_htt_tx_dec_pending(htt);
+ 	if (htt->num_pending_tx == 0)
+@@ -130,7 +133,11 @@ int ath10k_txrx_tx_unref(struct ath10k_h
+ 		info->status.is_valid_ack_signal = true;
+ 	}
+ 
+-	ieee80211_tx_status(htt->ar->hw, msdu);
++	if (flags & ATH10K_SKB_F_HW_80211_ENCAP)
++		ieee80211_tx_status_8023(htt->ar->hw, vif, msdu);
++	else
++		ieee80211_tx_status(htt->ar->hw, msdu);
++
+ 	/* we do not own the msdu anymore */
+ 
+ 	return 0;
diff --git a/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch b/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch
new file mode 100644
index 0000000000..cad4e42fc0
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch
@@ -0,0 +1,36 @@
+--- a/net/mac80211/vht.c
++++ b/net/mac80211/vht.c
+@@ -135,7 +135,8 @@ ieee80211_vht_cap_ie_to_sta_vht_cap(stru
+ 	have_80mhz = false;
+ 	for (i = 0; i < sband->n_channels; i++) {
+-		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
+-						IEEE80211_CHAN_NO_80MHZ))
++ 		if ((sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
++						IEEE80211_CHAN_NO_80MHZ)) &&
++						(sband->band != NL80211_BAND_2GHZ))
+ 			continue;
+ 
+ 		have_80mhz = true;
+--- a/net/mac80211/util.c
++++ b/net/mac80211/util.c
+@@ -1769,7 +1769,8 @@ static int ieee80211_build_preq_ies_band
+ 	/* Check if any channel in this sband supports at least 80 MHz */
+ 	for (i = 0; i < sband->n_channels; i++) {
+-		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
+-						IEEE80211_CHAN_NO_80MHZ))
++ 		if ((sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
++						IEEE80211_CHAN_NO_80MHZ)) &&
++						(sband->band != NL80211_BAND_2GHZ))
+ 			continue;
+ 
+ 		have_80mhz = true;
++--- a/net/mac80211/mlme.c
+++++ b/net/mac80211/mlme.c
+@@ -4823,8 +4823,9 @@
+ 	/* Allow VHT if at least one channel on the sband supports 80 MHz */
+ 	have_80mhz = false;
+ 	for (i = 0; i < sband->n_channels; i++) {
+-		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
+-						IEEE80211_CHAN_NO_80MHZ))
++		if ((sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
++						IEEE80211_CHAN_NO_80MHZ)) &&
diff --git a/package/kernel/mac80211/patches/subsys/999-mac80211-add-option-for-NSS-support.patch b/package/kernel/mac80211/patches/subsys/999-mac80211-add-option-for-NSS-support.patch
new file mode 100644
index 0000000000..3b0e5c05d8
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/999-mac80211-add-option-for-NSS-support.patch
@@ -0,0 +1,230 @@
+--- a/net/mac80211/Kconfig	2019-01-03 21:03:17.839001000 +0800
++++ b/net/mac80211/Kconfig	2019-01-03 21:04:43.931001000 +0800
+@@ -16,6 +16,13 @@
+ 
+ if MAC80211 != n
+ 
++config MAC80211_NSS_SUPPORT
++	bool "Enable NSS support for IPQ platform"
++	default n
++	---help---
++	This option enables support for NSS in boards
++	like AP148.
++
+ config MAC80211_HAS_RC
+ 	bool
+ 
+--- a/local-symbols	2019-01-03 21:24:00.087001000 +0800
++++ b/local-symbols	2019-01-03 21:24:56.535001000 +0800
+@@ -47,6 +47,7 @@ LIB80211_CRYPT_CCMP=
+ LIB80211_CRYPT_TKIP=
+ LIB80211_DEBUG=
+ MAC80211=
++MAC80211_NSS_SUPPORT=
+ MAC80211_HAS_RC=
+ MAC80211_RC_MINSTREL=
+ MAC80211_RC_DEFAULT_MINSTREL=
+--- a/net/mac80211/ieee80211_i.h	2019-01-03 21:04:57.527001000 +0800
++++ b/net/mac80211/ieee80211_i.h	2019-01-03 21:05:44.827001000 +0800
+@@ -35,6 +35,10 @@
+ 
+ extern const struct cfg80211_ops mac80211_config_ops;
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++#include <nss_api_if.h>
++#endif
++
+ struct ieee80211_local;
+ 
+ /* Maximum number of broadcast/multicast frames to buffer when some of the
+@@ -990,6 +994,12 @@ struct ieee80211_sub_if_data {
+ 	} debugfs;
+ #endif
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++	struct nss_virt_if_handle *nssctx;
++	struct sk_buff_head rx_queue;
++	struct work_struct rx_work;
++#endif
++
+ 	/* must be last, dynamically sized area in this! */
+ 	struct ieee80211_vif vif;
+ };
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -645,6 +645,15 @@ static int ieee80211_stop(struct net_device *dev)
+ {
+ 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++	if (sdata->nssctx) {
++		cancel_work_sync(&sdata->rx_work);
++		skb_queue_purge(&sdata->rx_queue);
++		nss_virt_if_destroy_sync(sdata->nssctx);
++		sdata_info(sdata, "Destroyed NSS virtual interface\n");
++	}
++#endif
++
+ 	ieee80211_do_stop(sdata, true);
+ 
+ 	return 0;
+@@ -1090,6 +1099,89 @@ void ieee80211_del_virtual_monitor(struct ieee80211_local *local)
+ 	kfree(sdata);
+ }
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++#define case_rtn_string(val) case val: return #val
++
++static const char *nss_tx_status_str(nss_tx_status_t status)
++{
++	switch (status) {
++		case_rtn_string(NSS_TX_SUCCESS);
++		case_rtn_string(NSS_TX_FAILURE);
++		case_rtn_string(NSS_TX_FAILURE_QUEUE);
++		case_rtn_string(NSS_TX_FAILURE_NOT_READY);
++		case_rtn_string(NSS_TX_FAILURE_TOO_LARGE);
++		case_rtn_string(NSS_TX_FAILURE_TOO_SHORT);
++		case_rtn_string(NSS_TX_FAILURE_NOT_SUPPORTED);
++		case_rtn_string(NSS_TX_FAILURE_BAD_PARAM);
++		case_rtn_string(NSS_TX_FAILURE_NOT_ENABLED);
++		case_rtn_string(NSS_TX_FAILURE_SYNC_BAD_PARAM);
++		case_rtn_string(NSS_TX_FAILURE_SYNC_TIMEOUT);
++		case_rtn_string(NSS_TX_FAILURE_SYNC_FW_ERR);
++	default:
++		return "Unknown NSS TX status";
++	}
++}
++
++static void netif_rx_nss_work(struct work_struct *work)
++{
++	int ret;
++	unsigned long flags;
++	struct sk_buff *skb;
++	struct sk_buff_head *list;
++	struct ieee80211_sub_if_data *sdata =
++	    container_of(work, struct ieee80211_sub_if_data, rx_work);
++
++	list = &sdata->rx_queue;
++	skb = skb_dequeue(list);
++
++	while (skb != NULL) {
++		skb_push(skb, ETH_HLEN);
++		ret = nss_virt_if_tx_buf(sdata->nssctx, skb);
++		if (unlikely(ret)) {
++			if (net_ratelimit()) {
++				sdata_err(sdata, "NSS TX failed with error: %s\n",
++					nss_tx_status_str(ret));
++			}
++			skb_pull(skb, ETH_HLEN);
++			netif_receive_skb(skb);
++		}
++
++		skb = skb_dequeue(list);
++	}
++
++	/* Check if we there are more packet to process and resched */
++	skb = skb_peek(list);
++	if (skb)
++		schedule_work(&sdata->rx_work);
++}
++
++/* This callback is registered for nss redirect to receive packet exceptioned from nss in Rx path.
++ * When packet does not match any of the ecm rules is redirected back here.
++ */
++void receive_from_nss(struct net_device *dev, struct sk_buff *sk_buff, struct napi_struct *napi)
++{
++	struct net_device *netdev;
++	struct sk_buff *skb;
++	struct ieee80211_sub_if_data *sdata;
++
++	if (!dev) {
++		kfree(sk_buff);
++		return;
++	}
++
++	netdev = (struct net_device *)dev;
++	sdata = netdev_priv(netdev);
++	if (sdata->dev != dev) {
++		kfree(sk_buff);
++		return;
++	}
++	skb = (struct sk_buff *)sk_buff;
++	skb->dev = netdev;
++	skb->protocol = eth_type_trans(skb, netdev);
++	napi_gro_receive(napi, skb);
++}
++#endif
++
+ /*
+  * NOTE: Be very careful when changing this function, it must NOT return
+  * an error on interface type changes that have been pre-checked, so most
+@@ -1348,6 +1417,17 @@ int ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)
+ 
+ 	ieee80211_recalc_ps(local);
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++	sdata->nssctx = nss_virt_if_create_sync(dev);
++	if (sdata->nssctx) {
++		sdata_info(sdata, "Created a NSS virtual interface\n");
++		nss_virt_if_register(sdata->nssctx, receive_from_nss, sdata->dev);
++		skb_queue_head_init(&sdata->rx_queue);
++		INIT_WORK(&sdata->rx_work, &netif_rx_nss_work);
++	} else
++		sdata_err(sdata, "Failed to create a NSS virtual interface\n");
++#endif
++
+ 	if (sdata->vif.type == NL80211_IFTYPE_MONITOR ||
+ 	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
+ 	    local->ops->wake_tx_queue) {
+--- a/net/mac80211/rx.c
++++ b/net/mac80211/rx.c
+@@ -2519,6 +2519,13 @@ static bool ieee80211_frame_allowed(stru
+ 	return true;
+ }
+
++static inline void netif_rx_nss(struct sk_buff *skb, struct ieee80211_sub_if_data *sdata)
++{
++	skb_queue_tail(&sdata->rx_queue, skb);
++
++	schedule_work(&sdata->rx_work);
++}
++
+ static void ieee80211_deliver_skb_to_local_stack(struct sk_buff *skb,
+ 						 struct ieee80211_rx_data *rx)
+ {
+@@ -2537,6 +2544,13 @@ static void ieee80211_deliver_skb_to_loc
+ 	} else {
+ 		memset(skb->cb, 0, sizeof(skb->cb));
+
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++		if (sdata->nssctx) {
++			netif_rx_nss(skb, sdata);
++			return;
++		}
++#endif
++
+ 		/* deliver to local stack */
+ 		if (rx->list)
+ #if LINUX_VERSION_IS_GEQ(4,19,0)
+@@ -4306,6 +4306,7 @@ static void ieee80211_rx_8023(struct iee
+ {
+ 	struct ieee80211_sta_rx_stats *stats;
+ 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
++	struct ieee80211_sub_if_data *sdata = rx->sdata;
+ 	struct sta_info *sta = rx->sta;
+ 	struct sk_buff *skb = rx->skb;
+ 	void *sa = skb->data + ETH_ALEN;
+@@ -4377,6 +4391,13 @@ static void ieee80211_rx_8023(struct iee
+ 	/* deliver to local stack */
+ 	skb->protocol = eth_type_trans(skb, fast_rx->dev);
+ 	memset(skb->cb, 0, sizeof(skb->cb));
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++       if (sdata->nssctx) {
++               netif_rx_nss(skb, sdata);
++               return;
++       }
++#endif
++
+ 	if (rx->list)
+ #if LINUX_VERSION_IS_GEQ(4,19,0)
+ 		list_add_tail(&skb->list, rx->list);
diff --git a/package/kernel/mac80211/patches/subsys/999-mac80211-nss-classify-tx.patch b/package/kernel/mac80211/patches/subsys/999-mac80211-nss-classify-tx.patch
new file mode 100644
index 0000000000..b03b94d21f
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/999-mac80211-nss-classify-tx.patch
@@ -0,0 +1,45 @@
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -38,6 +38,11 @@
+ #include "wme.h"
+ #include "rate.h"
+ 
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++#include <net/ip.h>
++#include <net/dsfield.h>
++#endif
++
+ /* misc utils */
+ 
+ static inline void ieee80211_tx_stats(struct net_device *dev, u32 len)
+@@ -3561,6 +3566,30 @@ void __ieee80211_subif_start_xmit(struct
+ netdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,
+ 				       struct net_device *dev)
+ {
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++	/* Packets from NSS does not have valid protocol, priority and other
++	 * network stack values. Derive required parameters (priority
++	 * and network_header) from payload for QoS header.
++	 * XXX: Here the assumption is that packet are in 802.3 format.
++	 * As of now priority is handled only for IPv4 and IPv6.
++	 */
++	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
++
++	if (sdata->nssctx && likely(!skb->protocol)) {
++		skb_set_network_header(skb, 14);
++		switch (((struct ethhdr *)skb->data)->h_proto) {
++		case htons(ETH_P_IP):
++			skb->priority = (ipv4_get_dsfield(ip_hdr(skb)) &
++					 0xfc) >> 5;
++			break;
++		case htons(ETH_P_IPV6):
++			skb->priority = (ipv6_get_dsfield(ipv6_hdr(skb)) &
++					 0xfc) >> 5;
++			break;
++		}
++	}
++#endif
++
+ 	if (unlikely(ieee80211_multicast_to_unicast(skb, dev))) {
+ 		struct sk_buff_head queue;
+ 
diff --git a/package/kernel/mac80211/patches/subsys/999-mac80211-xmit-busy.patch b/package/kernel/mac80211/patches/subsys/999-mac80211-xmit-busy.patch
new file mode 100644
index 0000000000..1b5723f5f8
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/999-mac80211-xmit-busy.patch
@@ -0,0 +1,20 @@
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -1580,7 +1580,16 @@ static bool ieee80211_tx_frags(struct ie
+ 					return true;
+ 				}
+ 			} else {
+-
++#ifdef CPTCFG_MAC80211_NSS_SUPPORT
++				if (skb_queue_len(&local->pending[q]) >= 1000) {
++					spin_unlock_irqrestore(
++						&local->queue_stop_reason_lock,
++						flags);
++					ieee80211_purge_tx_queue(&local->hw,
++								 skbs);
++					return false;
++				}
++#endif
+ 				/*
+ 				 * Since queue is stopped, queue up frames for
+ 				 * later transmission from the tx-pending
diff --git a/package/network/services/hostapd/files/hostapd.sh b/package/network/services/hostapd/files/hostapd.sh
index 45a49b8faa..4a4d071b11 100644
--- a/package/network/services/hostapd/files/hostapd.sh
+++ b/package/network/services/hostapd/files/hostapd.sh
@@ -99,6 +99,7 @@ hostapd_common_add_device_config() {
 	config_add_string require_mode
 	config_add_boolean legacy_rates
 	config_add_int cell_density
+	config_add_boolean vendor_vht
 
 	config_add_string acs_chan_bias
 	config_add_array hostapd_options
@@ -115,7 +116,7 @@ hostapd_prepare_device_config() {
 	local base_cfg=
 
 	json_get_vars country country_ie beacon_int:100 dtim_period:2 doth require_mode legacy_rates \
-		acs_chan_bias local_pwr_constraint spectrum_mgmt_required airtime_mode cell_density
+		acs_chan_bias local_pwr_constraint spectrum_mgmt_required airtime_mode cell_density vendor_vht
 
 	hostapd_set_log_options base_cfg
 
@@ -125,6 +126,7 @@ hostapd_prepare_device_config() {
 	set_default legacy_rates 0
 	set_default airtime_mode 0
 	set_default cell_density 0
+	set_default vendor_vht 1
 
 	[ -n "$country" ] && {
 		append base_cfg "country_code=$country" "$N"
@@ -152,6 +154,9 @@ hostapd_prepare_device_config() {
 			ac) append base_cfg "require_vht=1" "$N";;
 		esac
 	fi
+
+	[ "$hwmode" = "g" -a -n "$vendor_vht" ] && append base_cfg "vendor_vht=$vendor_vht" "$N"
+
 	case "$hwmode" in
 		b)
 			if [ "$cell_density" -eq 1 ]; then
diff --git a/package/network/utils/iproute2/patches/400-add-nss-qdisc.patch b/package/network/utils/iproute2/patches/400-add-nss-qdisc.patch
new file mode 100644
index 0000000000..68859225e4
--- /dev/null
+++ b/package/network/utils/iproute2/patches/400-add-nss-qdisc.patch
@@ -0,0 +1,2101 @@
+Index: iproute2-4.0.0/include/linux/pkt_sched.h
+===================================================================
+--- a/include/uapi/linux/pkt_sched.h	2018-06-22 16:26:27.026460232 -0700
++++ b/include/uapi/linux/pkt_sched.h	2018-06-22 16:26:27.022460063 -0700
+@@ -119,6 +119,251 @@
+ 
+ #define TCA_STAB_MAX (__TCA_STAB_MAX - 1)
+ 
++enum {
++	TCA_NSS_ACCEL_MODE_NSS_FW,
++	TCA_NSS_ACCEL_MODE_PPE,
++	TCA_NSS_ACCEL_MODE_MAX
++};
++
++/* NSSFIFO section */
++
++enum {
++	TCA_NSSFIFO_UNSPEC,
++	TCA_NSSFIFO_PARMS,
++	__TCA_NSSFIFO_MAX
++};
++
++#define TCA_NSSFIFO_MAX	(__TCA_NSSFIFO_MAX - 1)
++
++struct tc_nssfifo_qopt {
++	__u32	limit;		/* Queue length: bytes for bfifo, packets for pfifo */
++	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSWRED section */
++
++enum {
++	TCA_NSSWRED_UNSPEC,
++	TCA_NSSWRED_PARMS,
++	__TCA_NSSWRED_MAX
++};
++
++#define TCA_NSSWRED_MAX (__TCA_NSSWRED_MAX - 1)
++#define NSSWRED_CLASS_MAX 6
++struct tc_red_alg_parameter {
++	__u32	min;	/* qlen_avg < min: pkts are all enqueued */
++	__u32	max;	/* qlen_avg > max: pkts are all dropped */
++	__u32	probability;/* Drop probability at qlen_avg = max */
++	__u32	exp_weight_factor;/* exp_weight_factor for calculate qlen_avg */
++};
++
++struct tc_nsswred_traffic_class {
++	__u32 limit;			/* Queue length */
++	__u32 weight_mode_value;	/* Weight mode value */
++	struct tc_red_alg_parameter rap;/* Parameters for RED alg */
++};
++
++/*
++ * Weight modes for WRED
++ */
++enum tc_nsswred_weight_modes {
++	TC_NSSWRED_WEIGHT_MODE_DSCP = 0,/* Weight mode is DSCP */
++	TC_NSSWRED_WEIGHT_MODES,	/* Must be last */
++};
++typedef enum tc_nsswred_weight_modes tc_nsswred_weight_mode_t;
++
++struct tc_nsswred_qopt {
++	__u32	limit;			/* Queue length */
++	enum tc_nsswred_weight_modes weight_mode;
++					/* Weight mode */
++	__u32	traffic_classes;	/* How many traffic classes: DPs */
++	__u32	def_traffic_class;	/* Default traffic if no match: def_DP */
++	__u32	traffic_id;		/* The traffic id to be configured: DP */
++	__u32	weight_mode_value;	/* Weight mode value */
++	struct tc_red_alg_parameter rap;/* RED algorithm parameters */
++	struct tc_nsswred_traffic_class tntc[NSSWRED_CLASS_MAX];
++					/* Traffic settings for dumpping */
++	__u8	ecn;			/* Setting ECN bit or dropping */
++	__u8	set_default;		/* Sets qdisc to be the default for enqueue */
++	__u8	accel_mode;		/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSCODEL section */
++
++enum {
++	TCA_NSSCODEL_UNSPEC,
++	TCA_NSSCODEL_PARMS,
++	__TCA_NSSCODEL_MAX
++};
++
++#define TCA_NSSCODEL_MAX	(__TCA_NSSCODEL_MAX - 1)
++
++struct tc_nsscodel_qopt {
++	__u32	target;		/* Acceptable queueing delay */
++	__u32	limit;		/* Max number of packets that can be held in the queue */
++	__u32	interval;	/* Monitoring interval */
++	__u32	flows;		/* Number of flow buckets */
++	__u32	quantum;	/* Weight (in bytes) used for DRR of flow buckets */
++	__u8	ecn;		/* 0 - disable ECN, 1 - enable ECN */
++	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++struct tc_nsscodel_xstats {
++	__u32 peak_queue_delay;	/* Peak delay experienced by a dequeued packet */
++	__u32 peak_drop_delay;	/* Peak delay experienced by a dropped packet */
++};
++
++/* NSSFQ_CODEL section */
++
++struct tc_nssfq_codel_xstats {
++	__u32 new_flow_count;	/* Total number of new flows seen */
++	__u32 new_flows_len;	/* Current number of new flows */
++	__u32 old_flows_len;	/* Current number of old flows */
++	__u32 ecn_mark;		/* Number of packets marked with ECN */
++	__u32 drop_overlimit;	/* Number of packets dropped due to overlimit */
++	__u32 maxpacket;	/* The largest packet seen so far in the queue */
++};
++
++/* NSSTBL section */
++
++enum {
++	TCA_NSSTBL_UNSPEC,
++	TCA_NSSTBL_PARMS,
++	__TCA_NSSTBL_MAX
++};
++
++#define TCA_NSSTBL_MAX	(__TCA_NSSTBL_MAX - 1)
++
++struct tc_nsstbl_qopt {
++	__u32	burst;		/* Maximum burst size */
++	__u32	rate;		/* Limiting rate of TBF */
++	__u32	peakrate;	/* Maximum rate at which TBF is allowed to send */
++	__u32	mtu;		/* Max size of packet, or minumim burst size */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSPRIO section */
++
++#define TCA_NSSPRIO_MAX_BANDS 256
++
++enum {
++	TCA_NSSPRIO_UNSPEC,
++	TCA_NSSPRIO_PARMS,
++	__TCA_NSSPRIO_MAX
++};
++
++#define TCA_NSSPRIO_MAX	(__TCA_NSSPRIO_MAX - 1)
++
++struct tc_nssprio_qopt {
++	__u32	bands;		/* Number of bands */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSBF section */
++
++enum {
++	TCA_NSSBF_UNSPEC,
++	TCA_NSSBF_CLASS_PARMS,
++	TCA_NSSBF_QDISC_PARMS,
++	__TCA_NSSBF_MAX
++};
++
++#define TCA_NSSBF_MAX	(__TCA_NSSBF_MAX - 1)
++
++struct tc_nssbf_class_qopt {
++	__u32	burst;		/* Maximum burst size */
++	__u32	rate;		/* Allowed bandwidth for this class */
++	__u32	mtu;		/* MTU of the associated interface */
++	__u32	quantum;	/* Quantum allocation for DRR */
++};
++
++struct tc_nssbf_qopt {
++	__u16	defcls;		/* Default class value */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSWRR section */
++
++enum {
++	TCA_NSSWRR_UNSPEC,
++	TCA_NSSWRR_CLASS_PARMS,
++	TCA_NSSWRR_QDISC_PARMS,
++	__TCA_NSSWRR_MAX
++};
++
++#define TCA_NSSWRR_MAX	(__TCA_NSSWRR_MAX - 1)
++
++struct tc_nsswrr_class_qopt {
++	__u32	quantum;	/* Weight associated to this class */
++};
++
++struct tc_nsswrr_qopt {
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSWFQ section */
++
++enum {
++	TCA_NSSWFQ_UNSPEC,
++	TCA_NSSWFQ_CLASS_PARMS,
++	TCA_NSSWFQ_QDISC_PARMS,
++	__TCA_NSSWFQ_MAX
++};
++
++#define TCA_NSSWFQ_MAX	(__TCA_NSSWFQ_MAX - 1)
++
++struct tc_nsswfq_class_qopt {
++	__u32	quantum;	/* Weight associated to this class */
++};
++
++struct tc_nsswfq_qopt {
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSHTB section */
++
++enum {
++	TCA_NSSHTB_UNSPEC,
++	TCA_NSSHTB_CLASS_PARMS,
++	TCA_NSSHTB_QDISC_PARMS,
++	__TCA_NSSHTB_MAX
++};
++
++#define TCA_NSSHTB_MAX	(__TCA_NSSHTB_MAX - 1)
++
++struct tc_nsshtb_class_qopt {
++	__u32	burst;		/* Allowed burst size */
++	__u32	rate;		/* Allowed bandwidth for this class */
++	__u32	cburst;		/* Maximum burst size */
++	__u32	crate;		/* Maximum bandwidth for this class */
++	__u32	quantum;	/* Quantum allocation for DRR */
++	__u32	priority;	/* Priority value associated with this class */
++	__u32	overhead;	/* Overhead in bytes per packet */
++};
++
++struct tc_nsshtb_qopt {
++	__u32	r2q;		/* Rate to quantum ratio */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSBLACKHOLE section */
++
++enum {
++	TCA_NSSBLACKHOLE_UNSPEC,
++	TCA_NSSBLACKHOLE_PARMS,
++	__TCA_NSSBLACKHOLE_MAX
++};
++
++#define TCA_NSSBLACKHOLE_MAX	(__TCA_NSSBLACKHOLE_MAX - 1)
++
++struct tc_nssblackhole_qopt {
++	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++
+ /* FIFO section */
+ 
+ struct tc_fifo_qopt {
+Index: iproute2-4.0.0/tc/Makefile
+===================================================================
+--- a/tc/Makefile	2018-06-22 16:26:27.026460232 -0700
++++ b/tc/Makefile	2018-06-22 16:26:27.022460063 -0700
+@@ -81,6 +81,7 @@ TCMODULES += q_etf.o
+ TCMODULES += q_taprio.o
+ TCMODULES += q_plug.o
+ TCMODULES += q_ets.o
++TCMODULES += q_nss.o
+
+ TCSO :=
+ ifeq ($(TC_CONFIG_ATM),y)
+Index: iproute2-4.0.0/tc/q_nss.c
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ b/tc/q_nss.c	2018-06-22 16:28:11.650913251 -0700
+@@ -0,0 +1,1828 @@
++/*
++ **************************************************************************
++ * Copyright (c) 2015, 2018 The Linux Foundation. All rights reserved.
++ * Permission to use, copy, modify, and/or distribute this software for
++ * any purpose with or without fee is hereby granted, provided that the
++ * above copyright notice and this permission notice appear in all copies.
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
++ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ **************************************************************************
++ */
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <unistd.h>
++#include <syslog.h>
++#include <fcntl.h>
++#include <sys/socket.h>
++#include <netinet/in.h>
++#include <arpa/inet.h>
++#include <string.h>
++#include <math.h>
++
++#include "utils.h"
++#include "tc_util.h"
++#include "tc_red.h"
++
++/* ======================== NSSWRED =======================*/
++
++static void nssred_explain(void)
++{
++	fprintf(stderr, "Usage: ...  nssred limit BYTES avpkt BYTES [ min BYTES ] [ max BYTES ] [ probability VALUE ]\n");
++	fprintf(stderr, "                   [ burst PACKETS ] [ecn] [ set_default ] [ accel_mode ]\n");
++}
++
++static void nsswred_explain(void)
++{
++	fprintf(stderr, "Usage: ...  nsswred setup DPs NUMBER dp_default NUMBER [ weight_mode dscp ] [ecn] [ set_default ] [ accel_mode ]\n");
++	fprintf(stderr, "            nsswred limit BYTES DP NUMBER min BYTES max BYTES avpkt BYTES dscp NUMBER [ probability VALUE ] [ burst PACKETS ]\n");
++}
++
++static int nsswred_setup(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct rtattr *tail;
++	struct tc_nsswred_qopt opt;
++
++	memset(&opt, 0, sizeof(opt));
++	unsigned int dps = 0;
++	unsigned int def_dp = 0;
++	bool accel_mode = false;
++
++	while (argc > 0) {
++		if (strcmp(*argv, "DPs") == 0) {
++			NEXT_ARG();
++			if (get_unsigned(&dps, *argv, 0) || dps > NSSWRED_CLASS_MAX) {
++
++				fprintf(stderr, "DPs should be between 1 - %d\n", NSSWRED_CLASS_MAX);
++				return -1;
++			}
++		} else if (strcmp(*argv, "weight_mode") == 0) {
++			NEXT_ARG();
++			if (strcmp(*argv, "dscp") == 0) {
++				opt.weight_mode = TC_NSSWRED_WEIGHT_MODE_DSCP;
++			} else {
++				fprintf(stderr, "Illegal \"weight_mode\", we only support dscp at this moment\n");
++			}
++		} else if (strcmp(*argv, "ecn") == 0) {
++			opt.ecn = 1;
++		} else if (strcmp(*argv, "dp_default") == 0) {
++			NEXT_ARG();
++			if (get_unsigned(&def_dp, *argv, 0) || def_dp > dps) {
++				fprintf(stderr, "Illegal dp_default value\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "help") == 0) {
++			nsswred_explain();
++			return -1;
++		} else if (strcmp(*argv, "set_default") == 0) {
++			opt.set_default = 1;
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nsswred_explain();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
++	} else if (opt.accel_mode != TCA_NSS_ACCEL_MODE_NSS_FW) {
++		fprintf(stderr, "accel_mode should be %d\n", TCA_NSS_ACCEL_MODE_NSS_FW);
++		return -1;
++	}
++
++	if (!dps || !def_dp) {
++		fprintf(stderr, "Illegal nsswred setup parameters\n");
++		return -1;
++	}
++	opt.traffic_classes = dps;
++	opt.def_traffic_class = def_dp;
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSWRED_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsswred_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct rtattr *tail;
++	struct tc_nsswred_qopt opt;
++
++	int total_args = argc;
++	unsigned burst = 0;
++	unsigned avpkt = 0;
++	double probability = 0.0;
++	unsigned char weighted = (strcmp(qu->id, "nsswred") == 0);
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "limit") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.limit, *argv)) {
++				fprintf(stderr, "Illegal \"limit\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "set_default") == 0) {
++			opt.set_default = 1;
++		} else if (strcmp(*argv, "min") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.rap.min, *argv)) {
++				fprintf(stderr, "Illegal \"min\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "max") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.rap.max, *argv)) {
++				fprintf(stderr, "Illegal \"max\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "burst") == 0) {
++			NEXT_ARG();
++			if (get_unsigned(&burst, *argv, 0)) {
++				fprintf(stderr, "Illegal \"burst\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "avpkt") == 0) {
++			NEXT_ARG();
++			if (get_size(&avpkt, *argv)) {
++				fprintf(stderr, "Illegal \"avpkt\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "probability") == 0) {
++			NEXT_ARG();
++			if (sscanf(*argv, "%lg", &probability) != 1) {
++				fprintf(stderr, "Illegal \"probability\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "ecn") == 0) {
++			opt.ecn = 1;
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (strcmp(*argv, "help") == 0) {
++			if (weighted) {
++				nsswred_explain();
++			} else {
++				nssred_explain();
++			}
++			return -1;
++		} else if (weighted) {
++			if (strcmp(*argv, "setup") == 0) {
++				if (argc != total_args) {
++					fprintf(stderr, "Setup command must be the first parameter\n");
++					return -1;
++				}
++				return nsswred_setup(qu, argc-1, argv+1, n);
++			} else if (strcmp(*argv, "DP") == 0) {
++				NEXT_ARG();
++				if (get_unsigned(&opt.traffic_id, *argv, 0)) {
++					fprintf(stderr, "Illegal \"DP\"");
++					return -1;
++				}
++			} else if (strcmp(*argv, "dscp") == 0) {
++				NEXT_ARG();
++				if (get_unsigned(&opt.weight_mode_value, *argv, 0)) {
++					fprintf(stderr, "Illegal \"dscp\" value\n");
++					return -1;
++				}
++			}
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			if (weighted) {
++				nsswred_explain();
++			} else {
++				nssred_explain();
++			}
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
++	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
++		fprintf(stderr, "Accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
++		return -1;
++	}
++
++	if (weighted) {
++		if (!opt.limit || !opt.rap.min || !opt.rap.max || !opt.traffic_id || !avpkt || !opt.weight_mode_value) {
++			fprintf(stderr, "Require limit, min, max, avpkt, DP, weight_mode_value\n");
++			return -1;
++		}
++	} else {
++		if (!opt.limit || !avpkt) {
++			fprintf(stderr, "Require limit, avpkt");
++			return -1;
++		}
++	}
++
++	/*
++	 * Compute default min/max thresholds based on
++	 * Sally Floyd's recommendations:
++	 * http://www.icir.org/floyd/REDparameters.txt
++	 */
++	if (!opt.rap.max)
++		opt.rap.max = opt.rap.min ? opt.rap.min * 3 : opt.limit / 4;
++	if (!opt.rap.min)
++		opt.rap.min = opt.rap.max / 3;
++	if (!burst)
++		burst = (2 * opt.rap.min + opt.rap.max) / (3 * avpkt);
++	if ((opt.rap.exp_weight_factor = tc_red_eval_ewma(opt.rap.min, burst, avpkt)) < 0) {
++		fprintf(stderr, "Failed to calculate EWMA constant.\n");
++		return -1;
++	}
++
++	/*
++	 * project [0.0-1.0] to [0-255] to avoid floating point calculation
++	 */
++	opt.rap.probability = probability * (pow(2, 8)-1);
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSWRED_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsswred_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSWRED_MAX + 1];
++	struct tc_nsswred_qopt *qopt;
++	int i;
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSWRED_MAX, opt);
++
++	if (tb[TCA_NSSWRED_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSWRED_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSWRED_PARMS]);
++
++	if (strcmp(qu->id, "nsswred") == 0) {
++		fprintf(f, "DPs %d def_DP %d weight mode: " , qopt->traffic_classes, qopt->def_traffic_class);
++		if (qopt->weight_mode == TC_NSSWRED_WEIGHT_MODE_DSCP)
++			fprintf(f, "DSCP\n");
++		else
++			fprintf(f, "Unknown\n");
++		for (i = 0;i < qopt->traffic_classes; i ++) {
++			if (qopt->tntc[i].rap.exp_weight_factor) {
++				double prob = (double)qopt->tntc[i].rap.probability;
++				fprintf(f, "DP %d: limit %d, weight mode value: %d min: %d max: %d exp_weight_factor: %d probability %.2f\n",
++						i + 1, qopt->tntc[i].limit, qopt->tntc[i].weight_mode_value
++						, qopt->tntc[i].rap.min,qopt->tntc[i].rap.max,qopt->tntc[i].rap.exp_weight_factor,prob/255);
++			}
++		}
++	} else {
++		double prob = (double)qopt->rap.probability;
++		fprintf(f, "limit %d, min: %d max: %d exp_weight_factor: %d probability %.2f\n",
++				qopt->limit, qopt->rap.min,qopt->rap.max,qopt->rap.exp_weight_factor,prob/255);
++	}
++
++	if (qopt->ecn)
++		fprintf(f, "ECN enabled ");
++        if (qopt->set_default)
++                fprintf(f, "set_default ");
++
++	fprintf(f, "accel_mode: %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++struct qdisc_util nssred_qdisc_util = {
++	.id		= "nssred",
++	.parse_qopt	= nsswred_parse_opt,
++	.print_qopt	= nsswred_print_opt,
++};
++
++struct qdisc_util nsswred_qdisc_util = {
++	.id		= "nsswred",
++	.parse_qopt	= nsswred_parse_opt,
++	.print_qopt	= nsswred_print_opt,
++};
++
++/* ======================== NSSFIFO =======================*/
++
++static void nssfifo_explain(void)
++{
++	fprintf(stderr, "Usage: ...  nsspfifo [ limit PACKETS ] [ set_default ] [ accel_mode ]\n");
++}
++
++static int nssfifo_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct rtattr *tail;
++	struct tc_nssfifo_qopt opt;
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "limit") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.limit, *argv) || opt.limit == 0) {
++				fprintf(stderr, "Illegal \"limit\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "set_default") == 0) {
++			opt.set_default = 1;
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (strcmp(*argv, "help") == 0) {
++			nssfifo_explain();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nssfifo_explain();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
++	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
++		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSFIFO_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nssfifo_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSFIFO_MAX + 1];
++	struct tc_nssfifo_qopt *qopt;
++	SPRINT_BUF(b1);
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSFIFO_MAX, opt);
++
++	if (tb[TCA_NSSFIFO_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSFIFO_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSFIFO_PARMS]);
++
++	if (strcmp(qu->id, "nssbfifo") == 0)
++		fprintf(f, "limit %s ", sprint_size(qopt->limit, b1));
++	else
++		fprintf(f, "limit %up ", qopt->limit);
++
++	if (qopt->set_default)
++		fprintf(f, "set_default ");
++
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++struct qdisc_util nsspfifo_qdisc_util = {
++	.id		= "nsspfifo",
++	.parse_qopt	= nssfifo_parse_opt,
++	.print_qopt	= nssfifo_print_opt,
++};
++
++struct qdisc_util nssbfifo_qdisc_util = {
++	.id		= "nssbfifo",
++	.parse_qopt	= nssfifo_parse_opt,
++	.print_qopt	= nssfifo_print_opt,
++};
++
++/* ======================== NSSFQ_CODEL =======================*/
++
++static void nssfq_codel_explain(void)
++{
++	fprintf(stderr, "Usage: ... nssfq_codel target TIME interval TIME [ flows NUMBER ] [ quantum BYTES ]"
++				"[ limit PACKETS ] [ set_default ] [ accel_mode ]\n");
++}
++
++static void nssfq_codel_explain_err1(void)
++{
++	fprintf(stderr, "Value of target and interval should be greater than 1ms\n");
++}
++
++static int nssfq_codel_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct rtattr *tail;
++	struct tc_nsscodel_qopt opt;
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "target") == 0) {
++			NEXT_ARG();
++			if (get_time(&opt.target, *argv)) {
++				fprintf(stderr, "Illegal \"target\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "limit") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.limit, *argv) || opt.limit == 0) {
++				fprintf(stderr, "Illegal \"limit\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "flows") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.flows, *argv) || opt.flows == 0) {
++				fprintf(stderr, "Illegal \"flows\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "quantum") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.quantum, *argv) || opt.quantum == 0) {
++				fprintf(stderr, "Illegal \"quantum\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "interval") == 0) {
++			NEXT_ARG();
++			if (get_time(&opt.interval, *argv)) {
++				fprintf(stderr, "Illegal \"interval\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "ecn") == 0) {
++			fprintf(stderr, "Illegal, ECN not supported\n");
++			nssfq_codel_explain();
++			return -1;
++		} else if (strcmp(*argv, "set_default") == 0) {
++			opt.set_default = 1;
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (strcmp(*argv, "help") == 0) {
++			nssfq_codel_explain();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nssfq_codel_explain();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
++	} else if (opt.accel_mode != TCA_NSS_ACCEL_MODE_NSS_FW) {
++		fprintf(stderr, "accel_mode should be %d\n", TCA_NSS_ACCEL_MODE_NSS_FW);
++		return -1;
++	}
++
++	if (!opt.target || !opt.interval) {
++		nssfq_codel_explain();
++		return -1;
++	}
++
++	if (opt.target < 1000 || opt.interval < 1000) {
++		nssfq_codel_explain_err1();
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSCODEL_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nssfq_codel_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSCODEL_MAX + 1];
++	struct tc_nsscodel_qopt *qopt;
++	SPRINT_BUF(b1);
++	SPRINT_BUF(b2);
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSCODEL_MAX, opt);
++
++	if (tb[TCA_NSSCODEL_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSCODEL_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSCODEL_PARMS]);
++
++	fprintf(f, "target %s limit %up interval %s flows %u quantum %u ",
++		sprint_time(qopt->target, b1),
++		qopt->limit,
++		sprint_time(qopt->interval, b2),
++		qopt->flows,
++		qopt->quantum);
++
++	if (qopt->ecn)
++		fprintf(f, "ecn ");
++
++	if (qopt->set_default)
++		fprintf(f, "set_default ");
++
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++static int nssfq_codel_print_xstats(struct qdisc_util *qu, FILE *f, struct rtattr *xstats)
++{
++	struct tc_nssfq_codel_xstats *st;
++
++	if (xstats == NULL)
++		return 0;
++
++	if (RTA_PAYLOAD(xstats) < sizeof(*st))
++		return -1;
++
++	st = RTA_DATA(xstats);
++	fprintf(f, " maxpacket %u drop_overlimit %u new_flow_count %u ecn_mark %u\n",
++			st->maxpacket, st->drop_overlimit, st->new_flow_count, st->ecn_mark);
++	fprintf(f, " new_flows_len %u old_flows_len %u", st->new_flows_len, st->old_flows_len);
++
++	return 0;
++}
++
++struct qdisc_util nssfq_codel_qdisc_util = {
++	.id		= "nssfq_codel",
++	.parse_qopt	= nssfq_codel_parse_opt,
++	.print_qopt	= nssfq_codel_print_opt,
++	.print_xstats	= nssfq_codel_print_xstats,
++};
++
++/* ======================== NSSCODEL =======================*/
++
++static void nsscodel_explain(void)
++{
++	fprintf(stderr, "Usage: ... nsscodel target TIME interval TIME [ limit PACKETS ] [ set_default ] [ accel_mode ]\n");
++}
++
++static void nsscodel_explain_err1(void)
++{
++	fprintf(stderr, "Value of target and interval should be greater than 1ms\n");
++}
++
++static int nsscodel_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct rtattr *tail;
++	struct tc_nsscodel_qopt opt;
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "target") == 0) {
++			NEXT_ARG();
++			if (get_time(&opt.target, *argv)) {
++				fprintf(stderr, "Illegal \"target\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "limit") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.limit, *argv) || opt.limit == 0) {
++				fprintf(stderr, "Illegal \"limit\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "interval") == 0) {
++			NEXT_ARG();
++			if (get_time(&opt.interval, *argv)) {
++				fprintf(stderr, "Illegal \"interval\"\n");
++				return -1;
++			}
++		} else if (strcmp(*argv, "set_default") == 0) {
++			opt.set_default = 1;
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (strcmp(*argv, "help") == 0) {
++			nsscodel_explain();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nsscodel_explain();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
++	} else if (opt.accel_mode != TCA_NSS_ACCEL_MODE_NSS_FW) {
++		fprintf(stderr, "accel_mode should be %d\n", TCA_NSS_ACCEL_MODE_NSS_FW);
++		return -1;
++	}
++
++	if (!opt.target || !opt.interval) {
++		nsscodel_explain();
++		return -1;
++	}
++
++	if (opt.target < 1000 || opt.interval < 1000) {
++		nsscodel_explain_err1();
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSCODEL_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsscodel_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSCODEL_MAX + 1];
++	struct tc_nsscodel_qopt *qopt;
++	SPRINT_BUF(b1);
++	SPRINT_BUF(b2);
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSCODEL_MAX, opt);
++
++	if (tb[TCA_NSSCODEL_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSCODEL_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSCODEL_PARMS]);
++
++	fprintf(f, "target %s limit %up interval %s ",
++		sprint_time(qopt->target, b1),
++		qopt->limit,
++		sprint_time(qopt->interval, b2));
++
++	if (qopt->set_default)
++		fprintf(f, "set_default ");
++
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++static int nsscodel_print_xstats(struct qdisc_util *qu, FILE *f, struct rtattr *xstats)
++{
++	struct tc_nsscodel_xstats *st;
++
++	if (xstats == NULL)
++		return 0;
++
++	if (RTA_PAYLOAD(xstats) < sizeof(*st))
++		return -1;
++
++	st = RTA_DATA(xstats);
++	fprintf(f, " peak queue delay %ums peak drop delay %ums",
++			st->peak_queue_delay, st->peak_drop_delay);
++
++	return 0;
++}
++
++struct qdisc_util nsscodel_qdisc_util = {
++	.id		= "nsscodel",
++	.parse_qopt	= nsscodel_parse_opt,
++	.print_qopt	= nsscodel_print_opt,
++	.print_xstats	= nsscodel_print_xstats,
++};
++
++/* ======================== NSSTBL =======================*/
++
++static void nsstbl_explain(void)
++{
++	fprintf(stderr, "Usage: ... nsstbl burst BYTES rate BPS [ mtu BYTES ] [ accel_mode ]\n");
++}
++
++static int nsstbl_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	int ok = 0;
++	struct rtattr *tail;
++	struct tc_nsstbl_qopt opt;
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "burst") == 0 ||
++			   strcmp(*argv, "buffer") == 0 ||
++			   strcmp(*argv, "maxburst") == 0) {
++			NEXT_ARG();
++			if (opt.burst) {
++				fprintf(stderr, "Double \"buffer/burst\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.burst, *argv)) {
++				fprintf(stderr, "Illegal \"burst\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "mtu") == 0 ||
++			   strcmp(*argv, "minburst") == 0) {
++			NEXT_ARG();
++			if (opt.mtu) {
++				fprintf(stderr, "Double \"mtu/minburst\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.mtu, *argv)) {
++				fprintf(stderr, "Illegal \"mtu\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "rate") == 0) {
++			NEXT_ARG();
++			if (opt.rate) {
++				fprintf(stderr, "Double \"rate\" spec\n");
++				return -1;
++			}
++			if (get_rate(&opt.rate, *argv)) {
++				fprintf(stderr, "Illegal \"rate\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (strcmp(*argv, "help") == 0) {
++			nsstbl_explain();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nsstbl_explain();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!ok) {
++		nsstbl_explain();
++		return -1;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
++	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
++		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
++		return -1;
++	}
++
++	if (!opt.rate || !opt.burst) {
++		fprintf(stderr, "Both \"rate\" and \"burst\" are required.\n");
++		return -1;
++	}
++
++	/*
++	 * Peakrate is currently not supported, but we keep the infrastructure
++	 * for future use. However, we have disabled taking input for this.
++	 */
++	if (opt.peakrate) {
++		if (!opt.mtu) {
++			fprintf(stderr, "\"mtu\" is required, if \"peakrate\" is requested.\n");
++			return -1;
++		}
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSTBL_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsstbl_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSTBL_MAX + 1];
++	struct tc_nsstbl_qopt *qopt;
++	SPRINT_BUF(b1);
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSTBL_MAX, opt);
++
++	if (tb[TCA_NSSTBL_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSTBL_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSTBL_PARMS]);
++
++	fprintf(f, "buffer/maxburst %s ", sprint_size(qopt->burst, b1));
++	fprintf(f, "rate %s ", sprint_rate(qopt->rate, b1));
++	fprintf(f, "mtu %s ", sprint_size(qopt->mtu, b1));
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++struct qdisc_util nsstbl_qdisc_util = {
++	.id		= "nsstbl",
++	.parse_qopt	= nsstbl_parse_opt,
++	.print_qopt	= nsstbl_print_opt,
++};
++
++/* ======================== NSSPRIO =======================*/
++
++static void nssprio_explain(void)
++{
++	fprintf(stderr, "Usage: ... nssprio [ bands NUMBER (default 256) ] [ accel_mode ]\n");
++}
++
++static int nssprio_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	int ok = 0;
++	struct rtattr *tail;
++	struct tc_nssprio_qopt opt;
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "bands") == 0) {
++			NEXT_ARG();
++			if (get_unsigned(&opt.bands, *argv, 0)) {
++				fprintf(stderr, "Illegal \"limit\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (strcmp(*argv, "help") == 0) {
++			nssprio_explain();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nssprio_explain();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!ok) {
++		opt.bands = TCA_NSSPRIO_MAX_BANDS;
++	} else if (opt.bands > TCA_NSSPRIO_MAX_BANDS) {
++		nssprio_explain();
++		return -1;
++	}
++
++        if (!accel_mode) {
++                opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
++        } else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
++                fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
++                return -1;
++        }
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSPRIO_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nssprio_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSPRIO_MAX + 1];
++	struct tc_nssprio_qopt *qopt;
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSPRIO_MAX, opt);
++
++	if (tb[TCA_NSSPRIO_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSPRIO_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSPRIO_PARMS]);
++
++	fprintf(f, "bands %u ", qopt->bands);
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++struct qdisc_util nssprio_qdisc_util = {
++	.id		= "nssprio",
++	.parse_qopt	= nssprio_parse_opt,
++	.print_qopt	= nssprio_print_opt,
++};
++
++/* ======================== NSSBF =======================*/
++
++static void nssbf_explain_qdisc(void)
++{
++	fprintf(stderr,
++		"Usage: ... nssbf [ accel_mode ]\n"
++	);
++}
++
++static void nssbf_explain_class(void)
++{
++	fprintf(stderr, "Usage: ... nssbf rate BPS burst BYTES [ mtu BYTES ]\n");
++	fprintf(stderr, "                 [ quantum BYTES ]\n");
++}
++
++static void nssbf_explain1(char *arg)
++{
++	fprintf(stderr, "NSSBF: Illegal \"%s\"\n", arg);
++}
++
++static int nssbf_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct tc_nssbf_qopt opt;
++	struct rtattr *tail;
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (matches(*argv, "default") == 0) {
++			NEXT_ARG();
++			if (opt.defcls != 0) {
++				fprintf(stderr, "NSSBF: Double \"default\"\n");
++				return -1;
++			}
++			if (get_u16(&opt.defcls, *argv, 16) < 0) {
++				nssbf_explain1("default");
++				return -1;
++			}
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (matches(*argv, "help") == 0) {
++			nssbf_explain_qdisc();
++			return -1;
++		} else {
++			fprintf(stderr, "NSSBF: What is \"%s\" ?\n", *argv);
++			nssbf_explain_qdisc();
++			return -1;
++		}
++		argc--, argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_NSS_FW;
++	} else if (opt.accel_mode != TCA_NSS_ACCEL_MODE_NSS_FW) {
++		fprintf(stderr, "accel_mode should be %d\n", TCA_NSS_ACCEL_MODE_NSS_FW);
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSBF_QDISC_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nssbf_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSBF_MAX + 1];
++	struct tc_nssbf_qopt *qopt;
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSBF_MAX, opt);
++
++	if (tb[TCA_NSSBF_QDISC_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSBF_QDISC_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSBF_QDISC_PARMS]);
++
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++static int nssbf_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	int ok = 0;
++	struct rtattr *tail;
++	struct tc_nssbf_class_qopt opt;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "burst") == 0 ||
++			   strcmp(*argv, "buffer") == 0 ||
++			   strcmp(*argv, "maxburst") == 0) {
++			NEXT_ARG();
++			if (opt.burst) {
++				fprintf(stderr, "Double \"buffer/burst\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.burst, *argv)) {
++				fprintf(stderr, "Illegal \"burst\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "mtu") == 0) {
++			NEXT_ARG();
++			if (opt.mtu) {
++				fprintf(stderr, "Double \"mtu\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.mtu, *argv)) {
++				fprintf(stderr, "Illegal \"mtu\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "quantum") == 0) {
++			NEXT_ARG();
++			if (opt.quantum) {
++				fprintf(stderr, "Double \"quantum\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.quantum, *argv)) {
++				fprintf(stderr, "Illegal \"quantum\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "rate") == 0) {
++			NEXT_ARG();
++			if (opt.rate) {
++				fprintf(stderr, "Double \"rate\" spec\n");
++				return -1;
++			}
++			if (get_rate(&opt.rate, *argv)) {
++				fprintf(stderr, "Illegal \"rate\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "help") == 0) {
++			nssbf_explain_class();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nssbf_explain_class();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!ok) {
++		nssbf_explain_class();
++		return -1;
++	}
++
++	if (!opt.rate || !opt.burst) {
++		fprintf(stderr, "Both \"rate\" and \"burst\" are required.\n");
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSBF_CLASS_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nssbf_print_class_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSBF_MAX + 1];
++	struct tc_nssbf_class_qopt *qopt;
++	SPRINT_BUF(b1);
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSBF_MAX, opt);
++
++	if (tb[TCA_NSSBF_CLASS_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSBF_CLASS_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSBF_CLASS_PARMS]);
++
++	fprintf(f, "burst %s ", sprint_size(qopt->burst, b1));
++	fprintf(f, "rate %s ", sprint_rate(qopt->rate, b1));
++	fprintf(f, "quantum %s ", sprint_size(qopt->quantum, b1));
++	fprintf(f, "mtu %s ", sprint_size(qopt->mtu, b1));
++
++	return 0;
++}
++
++struct qdisc_util nssbf_qdisc_util = {
++	.id		= "nssbf",
++	.parse_qopt	= nssbf_parse_opt,
++	.print_qopt	= nssbf_print_opt,
++	.parse_copt	= nssbf_parse_class_opt,
++	.print_copt	= nssbf_print_class_opt,
++};
++
++/* ======================== NSSWRR =======================*/
++
++static void nsswrr_explain_qdisc(void)
++{
++	fprintf(stderr,	"Usage (qdisc): ... nsswrr [ accel_mode ]\n");
++}
++
++static void nsswrr_explain_class(void)
++{
++	fprintf(stderr, "Usage (class): ... nsswrr quantum PACKETS ]\n");
++}
++
++static int nsswrr_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct tc_nsswrr_qopt opt;
++	bool accel_mode = false;
++	struct rtattr *tail;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (matches(*argv, "help") == 0) {
++			nsswrr_explain_qdisc();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\" ?\n", *argv);
++			nsswrr_explain_qdisc();
++			return -1;
++		}
++		argc--, argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
++	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
++		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSWRR_QDISC_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsswrr_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSWRR_MAX + 1];
++	struct tc_nsswrr_qopt *qopt;
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSWRR_MAX, opt);
++
++	if (tb[TCA_NSSWRR_QDISC_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSWRR_QDISC_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSWRR_QDISC_PARMS]);
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++static int nsswrr_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	int ok = 0;
++	struct rtattr *tail;
++	struct tc_nsswrr_class_qopt opt;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "quantum") == 0) {
++			NEXT_ARG();
++			if (get_u32(&opt.quantum, *argv, 10)) {
++				fprintf(stderr, "Illegal \"quantum\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "help") == 0) {
++			nsswrr_explain_class();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nsswrr_explain_class();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!ok) {
++		nsswrr_explain_class();
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSWRR_CLASS_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsswrr_print_class_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSWRR_MAX + 1];
++	struct tc_nsswrr_class_qopt *qopt;
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSWRR_MAX, opt);
++
++	if (tb[TCA_NSSWRR_CLASS_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSWRR_CLASS_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSWRR_CLASS_PARMS]);
++
++	fprintf(f, "quantum %up ", qopt->quantum);
++	return 0;
++}
++
++struct qdisc_util nsswrr_qdisc_util = {
++	.id		= "nsswrr",
++	.parse_qopt	= nsswrr_parse_opt,
++	.print_qopt	= nsswrr_print_opt,
++	.parse_copt	= nsswrr_parse_class_opt,
++	.print_copt	= nsswrr_print_class_opt,
++};
++
++/* ======================== NSSWFQ =======================*/
++
++static void nsswfq_explain_qdisc(void)
++{
++	fprintf(stderr, "Usage (qdisc): ... nsswfq [ accel_mode ]\n");
++}
++
++static void nsswfq_explain_class(void)
++{
++	fprintf(stderr, "Usage (class): ... nsswfq quantum BYTES ]\n");
++}
++
++static int nsswfq_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct tc_nsswfq_qopt opt;
++	bool accel_mode = false;
++	struct rtattr *tail;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (matches(*argv, "help") == 0) {
++			nsswfq_explain_qdisc();
++			return -1;
++		} else {
++			fprintf(stderr, "NSSWFQ: What is \"%s\" ?\n", *argv);
++			nsswfq_explain_qdisc();
++			return -1;
++		}
++		argc--, argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
++	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
++		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSWFQ_QDISC_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsswfq_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSWFQ_MAX + 1];
++	struct tc_nsswfq_qopt *qopt;
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSWFQ_MAX, opt);
++
++	if (tb[TCA_NSSWFQ_QDISC_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSWFQ_QDISC_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSWFQ_QDISC_PARMS]);
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++static int nsswfq_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	int ok = 0;
++	struct rtattr *tail;
++	struct tc_nsswfq_class_qopt opt;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "quantum") == 0) {
++			NEXT_ARG();
++			if (get_size(&opt.quantum, *argv)) {
++				fprintf(stderr, "Illegal \"quantum\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "help") == 0) {
++			nsswfq_explain_class();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nsswfq_explain_class();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!ok) {
++		nsswfq_explain_class();
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSWFQ_CLASS_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsswfq_print_class_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSWFQ_MAX + 1];
++	struct tc_nsswfq_class_qopt *qopt;
++	SPRINT_BUF(b1);
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSWFQ_MAX, opt);
++
++	if (tb[TCA_NSSWFQ_CLASS_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSWFQ_CLASS_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSWFQ_CLASS_PARMS]);
++
++	fprintf(f, "quantum %s ", sprint_size(qopt->quantum, b1));
++
++	return 0;
++}
++
++struct qdisc_util nsswfq_qdisc_util = {
++	.id		= "nsswfq",
++	.parse_qopt	= nsswfq_parse_opt,
++	.print_qopt	= nsswfq_print_opt,
++	.parse_copt	= nsswfq_parse_class_opt,
++	.print_copt	= nsswfq_print_class_opt,
++};
++
++/* ======================== NSSHTB =======================*/
++
++static void nsshtb_explain_qdisc(void)
++{
++	fprintf(stderr,
++		"Usage: ... nsshtb [ r2q ] [ accel_mode ]\n"
++	);
++}
++
++static void nsshtb_explain_class(void)
++{
++	fprintf(stderr, "Usage: ... nsshtb priority 0-3 [ quantum BYTES ] [ rate BPS ] [ burst BYTES ] [crate BPS ] [ cburst BYTES ]\n");
++	fprintf(stderr, "                 [ overhead BYTES ] \n");
++}
++
++static void nsshtb_explain1(char *arg)
++{
++	fprintf(stderr, "NSSHTB: Illegal \"%s\"\n", arg);
++}
++
++static int nsshtb_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct tc_nsshtb_qopt opt;
++	struct rtattr *tail;
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "r2q") == 0) {
++			NEXT_ARG();
++			if (opt.r2q != 0) {
++				fprintf(stderr, "NSSHTB: Double \"r2q\"\n");
++				return -1;
++			}
++			if (get_u32(&opt.r2q, *argv, 10) < 0) {
++				nsshtb_explain1("r2q");
++				return -1;
++			}
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (strcmp(*argv, "help") == 0) {
++			nsshtb_explain_qdisc();
++			return -1;
++		} else {
++			fprintf(stderr, "NSSHTB: What is \"%s\" ?\n", *argv);
++			nsshtb_explain_qdisc();
++			return -1;
++		}
++		argc--, argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
++	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
++		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSHTB_QDISC_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsshtb_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSHTB_MAX + 1];
++	struct tc_nsshtb_qopt *qopt;
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSHTB_MAX, opt);
++
++	if (tb[TCA_NSSHTB_QDISC_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSHTB_QDISC_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSHTB_QDISC_PARMS]);
++
++	if (qopt->r2q != 0)
++		fprintf(f, "r2q %u ", qopt->r2q);
++
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++static int nsshtb_parse_class_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	int ok = 0;
++	struct rtattr *tail;
++	struct tc_nsshtb_class_qopt opt;
++	int crate = 0;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "burst") == 0) {
++			NEXT_ARG();
++			if (opt.burst) {
++				fprintf(stderr, "Double \"burst\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.burst, *argv)) {
++				fprintf(stderr, "Illegal \"burst\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "rate") == 0) {
++			NEXT_ARG();
++			if (opt.rate) {
++				fprintf(stderr, "Double \"rate\" spec\n");
++				return -1;
++			}
++			if (get_rate(&opt.rate, *argv)) {
++				fprintf(stderr, "Illegal \"rate\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "cburst") == 0) {
++			NEXT_ARG();
++			if (opt.cburst) {
++				fprintf(stderr, "Double \"cburst\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.cburst, *argv)) {
++				fprintf(stderr, "Illegal \"cburst\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "crate") == 0) {
++			NEXT_ARG();
++			if (opt.crate) {
++				fprintf(stderr, "Double \"crate\" spec\n");
++				return -1;
++			}
++			if (get_rate(&opt.crate, *argv)) {
++				fprintf(stderr, "Illegal \"crate\"\n");
++				return -1;
++			}
++			crate++;
++			ok++;
++		} else if (strcmp(*argv, "priority") == 0) {
++			NEXT_ARG();
++			if (opt.priority) {
++				fprintf(stderr, "Double \"priority\" spec\n");
++				return -1;
++			}
++			if (get_u32(&opt.priority, *argv, 10) < 0) {
++				fprintf(stderr, "Illegal \"priority\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "quantum") == 0) {
++			NEXT_ARG();
++			if (opt.quantum) {
++				fprintf(stderr, "Double \"quantum\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.quantum, *argv)) {
++				fprintf(stderr, "Illegal \"quantum\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "overhead") == 0) {
++			NEXT_ARG();
++			if (opt.overhead) {
++				fprintf(stderr, "Double \"overhead\" spec\n");
++				return -1;
++			}
++			if (get_size(&opt.overhead, *argv)) {
++				fprintf(stderr, "Illegal \"overhead\"\n");
++				return -1;
++			}
++			ok++;
++		} else if (strcmp(*argv, "help") == 0) {
++			nsshtb_explain_class();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nsshtb_explain_class();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!ok) {
++		nsshtb_explain_class();
++		return -1;
++	}
++
++	if (opt.rate && !opt.burst) {
++		fprintf(stderr, "\"burst\" required if \"rate\" is specified.\n");
++		return -1;
++	}
++
++	if (!crate) {
++		fprintf(stderr, "\"crate\" is required.\n");
++		return -1;
++	}
++
++	if (opt.crate && !opt.cburst) {
++		fprintf(stderr, "\"cburst\" required if \"crate\" is non-zero.\n");
++		return -1;
++	}
++
++	if (opt.priority > 3) {
++		fprintf(stderr, "\"priority\" should be an integer between 0 and 3.\n");
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSHTB_CLASS_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nsshtb_print_class_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSHTB_MAX + 1];
++	struct tc_nsshtb_class_qopt *qopt;
++	SPRINT_BUF(b1);
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSHTB_MAX, opt);
++
++	if (tb[TCA_NSSHTB_CLASS_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSHTB_CLASS_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSHTB_CLASS_PARMS]);
++
++	fprintf(f, "burst %s ", sprint_size(qopt->burst, b1));
++	fprintf(f, "rate %s ", sprint_rate(qopt->rate, b1));
++	fprintf(f, "cburst %s ", sprint_size(qopt->cburst, b1));
++	fprintf(f, "crate %s ", sprint_rate(qopt->crate, b1));
++	fprintf(f, "priority %u ", qopt->priority);
++	fprintf(f, "quantum %s ", sprint_size(qopt->quantum, b1));
++	fprintf(f, "overhead %s ", sprint_size(qopt->overhead, b1));
++
++	return 0;
++}
++
++struct qdisc_util nsshtb_qdisc_util = {
++	.id		= "nsshtb",
++	.parse_qopt	= nsshtb_parse_opt,
++	.print_qopt	= nsshtb_print_opt,
++	.parse_copt	= nsshtb_parse_class_opt,
++	.print_copt	= nsshtb_print_class_opt,
++};
++
++/* ======================== NSSBLACKHOLE ======================= */
++
++static void nssblackhole_explain(void)
++{
++	fprintf(stderr, "Usage: ...  nssblackhole [ set_default ] [ accel_mode ]\n");
++}
++
++static int nssblackhole_parse_opt(struct qdisc_util *qu, int argc, char **argv, struct nlmsghdr *n)
++{
++	struct rtattr *tail;
++	struct tc_nssblackhole_qopt opt;
++	bool accel_mode = false;
++
++	memset(&opt, 0, sizeof(opt));
++
++	while (argc > 0) {
++		if (strcmp(*argv, "set_default") == 0) {
++			opt.set_default = 1;
++		} else if (strcmp(*argv, "accel_mode") == 0) {
++			NEXT_ARG();
++			if (get_u8(&opt.accel_mode, *argv, 0)) {
++				fprintf(stderr, "Illegal accel_mode value\n");
++				return -1;
++			}
++			accel_mode = true;
++		} else if (strcmp(*argv, "help") == 0) {
++			nssblackhole_explain();
++			return -1;
++		} else {
++			fprintf(stderr, "What is \"%s\"?\n", *argv);
++			nssblackhole_explain();
++			return -1;
++		}
++		argc--; argv++;
++	}
++
++	if (!accel_mode) {
++		opt.accel_mode = TCA_NSS_ACCEL_MODE_PPE;
++	} else if (opt.accel_mode >= TCA_NSS_ACCEL_MODE_MAX) {
++		fprintf(stderr, "accel_mode should be < %d\n", TCA_NSS_ACCEL_MODE_MAX);
++		return -1;
++	}
++
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, 1024, TCA_OPTIONS, NULL, 0);
++	addattr_l(n, 1024, TCA_NSSBLACKHOLE_PARMS, &opt, sizeof(opt));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++
++	return 0;
++}
++
++static int nssblackhole_print_opt(struct qdisc_util *qu, FILE *f, struct rtattr *opt)
++{
++	struct rtattr *tb[TCA_NSSBLACKHOLE_MAX + 1];
++	struct tc_nssblackhole_qopt *qopt;
++
++	if (opt == NULL)
++		return 0;
++
++	parse_rtattr_nested(tb, TCA_NSSBLACKHOLE_MAX, opt);
++
++	if (tb[TCA_NSSBLACKHOLE_PARMS] == NULL)
++		return -1;
++
++	if (RTA_PAYLOAD(tb[TCA_NSSBLACKHOLE_PARMS]) < sizeof(*qopt))
++		return -1;
++
++	qopt = RTA_DATA(tb[TCA_NSSBLACKHOLE_PARMS]);
++
++	if (qopt->set_default)
++		fprintf(f, "set_default ");
++
++	fprintf(f, "accel_mode %d ", qopt->accel_mode);
++
++	return 0;
++}
++
++struct qdisc_util nssblackhole_qdisc_util = {
++	.id		= "nssblackhole",
++	.parse_qopt	= nssblackhole_parse_opt,
++	.print_qopt	= nssblackhole_print_opt,
++};
diff --git a/package/network/utils/iproute2/patches/500-add-nssmirred.patch b/package/network/utils/iproute2/patches/500-add-nssmirred.patch
new file mode 100644
index 0000000000..e48058e6c7
--- /dev/null
+++ b/package/network/utils/iproute2/patches/500-add-nssmirred.patch
@@ -0,0 +1,243 @@
+--- a/tc/Makefile	2019-04-08 12:48:15.425854828 +0530
++++ b/tc/Makefile	2019-04-08 13:03:17.204741000 +0530
+@@ -54,6 +54,7 @@ TCMODULES += m_bpf.o
+ TCMODULES += m_sample.o
+ TCMODULES += m_ct.o
+ TCMODULES += m_gate.o
++TCMODULES += m_nssmirred.o
+ TCMODULES += p_ip.o
+ TCMODULES += p_ip6.o
+ TCMODULES += p_icmp.o
+--- /dev/null	1970-01-01 05:30:00.000000000 +0530
++++ b/tc/m_nssmirred.c	2019-06-19 14:25:51.369793000 +0530
+@@ -0,0 +1,183 @@
++/*
++ **************************************************************************
++ * Copyright (c) 2019 The Linux Foundation. All rights reserved.
++ * Permission to use, copy, modify, and/or distribute this software for
++ * any purpose with or without fee is hereby granted, provided that the
++ * above copyright notice and this permission notice appear in all copies.
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
++ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ **************************************************************************
++ */
++
++#include <stdio.h>
++#include <stdlib.h>
++#include <unistd.h>
++#include <syslog.h>
++#include <fcntl.h>
++#include <sys/socket.h>
++#include <netinet/in.h>
++#include <arpa/inet.h>
++#include <string.h>
++#include "utils.h"
++#include "tc_util.h"
++#include "tc_common.h"
++#include <linux/tc_act/tc_nssmirred.h>
++
++/*
++ * explain()
++ *	API to print the explaination of nssmirred action statement's
++ *	elements.
++ */
++static void explain(void)
++{
++	fprintf(stderr, "Usage: nssmirred redirect <dev TO_DEVICENAME fromdev FROM_DEVICENAME> \n");
++	fprintf(stderr, "where: \n");
++	fprintf(stderr, "\tTO_DEVICENAME is the devicename to redirect to\n");
++	fprintf(stderr, "\tFROM_DEVICENAME is the devicename to redirect from\n");
++}
++
++/*
++ * usage()
++ *	API to show the usage of the nssmirred action.
++ */
++static void usage(void)
++{
++	explain();
++	exit(-1);
++}
++
++/*
++ * parse_nss_mirred()
++ *	Parse and validate the nssmirred action statement.
++ */
++static int parse_nss_mirred(struct action_util *a, int *argc_p, char ***argv_p,
++	     int tca_id, struct nlmsghdr *n)
++{
++	int idx, argc = *argc_p;
++	char **argv = *argv_p;
++	struct tc_nss_mirred p;
++	struct rtattr *tail;
++
++	if (argc < 0) {
++		fprintf(stderr, "nssmirred bad argument count %d. Try option \"help\"\n", argc);
++		goto error;
++	}
++
++	if (matches(*argv, "nssmirred")) {
++		fprintf(stderr, "nssmirred bad argument %s. Try option \"help\"\n", *argv);
++		goto error;
++	}
++
++	NEXT_ARG();
++	if (!matches(*argv, "help")) {
++		usage();
++	}
++
++	if (matches(*argv, "redirect")) {
++		fprintf(stderr, "nssmirred bad argument %s. Try option \"help\"\n", *argv);
++		goto error;
++	}
++
++	NEXT_ARG();
++	if (matches(*argv, "dev")) {
++		fprintf(stderr, "nssmirred: bad value %s. Try option \"help\"\n", *argv);
++		goto error;
++	}
++
++	NEXT_ARG();
++	memset(&p, 0, sizeof(struct tc_nss_mirred));
++	if ((idx = ll_name_to_index(*argv)) == 0) {
++		fprintf(stderr, "Cannot find to device \"%s\"\n", *argv);
++		goto error;
++	}
++
++	p.to_ifindex = idx;
++	NEXT_ARG();
++	if (matches(*argv, "fromdev")) {
++		fprintf(stderr, "nssmirred: bad value %s. Try option \"help\"\n", *argv);
++		goto error;
++	}
++
++	NEXT_ARG();
++	if ((idx = ll_name_to_index(*argv)) == 0) {
++		fprintf(stderr, "Cannot find from device \"%s\"\n", *argv);
++		goto error;
++	}
++
++	p.from_ifindex = idx;
++	p.action = TC_ACT_STOLEN;
++	tail = NLMSG_TAIL(n);
++	addattr_l(n, MAX_MSG, tca_id, NULL, 0);
++	addattr_l(n, MAX_MSG, TCA_NSS_MIRRED_PARMS, &p, sizeof (p));
++	tail->rta_len = (void *) NLMSG_TAIL(n) - (void *) tail;
++	argc--;
++	argv++;
++	*argc_p = argc;
++	*argv_p = argv;
++	return 0;
++
++error:
++	return -1;
++}
++
++/*
++ * print_nss_mirred()
++ *	Print information related to nssmirred action.
++ */
++static int print_nss_mirred(struct action_util *au, FILE * f, struct rtattr *arg)
++{
++	struct tc_nss_mirred *p;
++	struct rtattr *tb[TCA_NSS_MIRRED_MAX + 1];
++	const char *from_dev, *to_dev;
++
++	if (arg == NULL) {
++		return -1;
++	}
++
++	parse_rtattr_nested(tb, TCA_NSS_MIRRED_MAX, arg);
++
++	if (tb[TCA_NSS_MIRRED_PARMS] == NULL) {
++		fprintf(f, "[NULL nssmirred parameters]");
++		goto error;
++	}
++
++	p = RTA_DATA(tb[TCA_NSS_MIRRED_PARMS]);
++	if ((from_dev = ll_index_to_name(p->from_ifindex)) == 0) {
++		fprintf(stderr, "Invalid interface (index: %d)\n", p->from_ifindex);
++		goto error;
++	}
++
++	if ((to_dev = ll_index_to_name(p->to_ifindex)) == 0) {
++		fprintf(stderr, "Invalid interface (index: %d)\n", p->to_ifindex);
++		goto error;
++	}
++
++	fprintf(f, "nssmirred (%s to device %s) stolen\n", from_dev, to_dev);
++	fprintf(f, "\tindex %d ref %d bind %d\n",p->index,p->refcnt,p->bindcnt);
++
++	if (show_stats) {
++		if (tb[TCA_NSS_MIRRED_TM]) {
++			struct tcf_t *tm = RTA_DATA(tb[TCA_NSS_MIRRED_TM]);
++			print_tm(f,tm);
++		}
++	}
++	return 0;
++
++error:
++	return -1;
++}
++
++/*
++ * nssmirred_action_util
++ *	nssmirred action utility structure.
++ */
++struct action_util nssmirred_action_util = {
++	.id = "nssmirred",
++	.parse_aopt = parse_nss_mirred,
++	.print_aopt = print_nss_mirred,
++};
+--- /dev/null	1970-01-01 05:30:00.000000000 +0530
++++ a/include/linux/tc_act/tc_nssmirred.h	2019-06-19 14:25:40.787768000 +0530
+@@ -0,0 +1,44 @@
++/*
++ **************************************************************************
++ * Copyright (c) 2019 The Linux Foundation. All rights reserved.
++ * Permission to use, copy, modify, and/or distribute this software for
++ * any purpose with or without fee is hereby granted, provided that the
++ * above copyright notice and this permission notice appear in all copies.
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
++ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ **************************************************************************
++ */
++
++#ifndef __LINUX_TC_NSS_MIR_H
++#define __LINUX_TC_NSS_MIR_H
++
++#include <linux/types.h>
++#include <linux/pkt_cls.h>
++
++/*
++ * tc_nss_mirred
++ *	Structure for nssmirred action.
++ */
++struct tc_nss_mirred {
++	tc_gen;
++	__u32                   from_ifindex;  /* ifindex of the port to be redirected from */
++	__u32                   to_ifindex;  /* ifindex of the port to be redirected to */
++};
++
++/*
++ * Types of nssmirred action parameters.
++ */
++enum {
++	TCA_NSS_MIRRED_UNSPEC,
++	TCA_NSS_MIRRED_TM,
++	TCA_NSS_MIRRED_PARMS,
++	__TCA_NSS_MIRRED_MAX
++};
++#define TCA_NSS_MIRRED_MAX (__TCA_NSS_MIRRED_MAX - 1)
++
++#endif	/* __LINUX_TC_NSS_MIR_H */
diff --git a/package/qca/README.md b/package/qca/README.md
new file mode 100644
index 0000000000..495d9b9205
--- /dev/null
+++ b/package/qca/README.md
@@ -0,0 +1,11 @@
+QSDK NSS Drivers
+================
+
+This repo contains drivers required to activate and use the IPQ806x SoCs'
+NSS accelerator cores.
+
+The drivers are from the QSDK 11.2r1 release.  The entire QSDK 11.2r1 release
+can be found in the link below:
+
+https://source.codeaurora.org/quic/qsdk/releases/manifest/qstak/tree/caf_AU_LINUX_QSDK_NHSS.QSDK.11.2.R1_TARGET_ALL.12.0.4540.030.xml?h=release
+
diff --git a/package/qca/nss-ifb/Makefile b/package/qca/nss-ifb/Makefile
new file mode 100644
index 0000000000..6b7f0b4802
--- /dev/null
+++ b/package/qca/nss-ifb/Makefile
@@ -0,0 +1,49 @@
+#
+# Copyright (C) 2008-2012 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=nss-ifb
+PKG_RELEASE:=1
+
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/nss-ifb
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=NSS IFB Interface
+  DEPENDS:=+kmod-qca-nss-drv @LINUX_5_4
+  FILES:=$(PKG_BUILD_DIR)/nss-ifb.ko
+  KCONFIG:=
+endef
+
+define KernelPackage/nss-ifb/description
+ Kernel module to register a NSS aware IFB interface.
+endef
+
+EXTRA_KCONFIG:= \
+	CONFIG_NET_CLS=y
+
+EXTRA_CFLAGS:= \
+	-I$(STAGING_DIR)/usr/include/qca-nss-drv
+
+MAKE_OPTS:= \
+	$(KERNEL_MAKE_FLAGS) \
+	M="$(PKG_BUILD_DIR)" \
+	EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
+	$(EXTRA_KCONFIG)
+
+define Build/Compile
+	$(MAKE) -C "$(LINUX_DIR)" \
+		$(MAKE_OPTS) \
+		modules
+endef
+
+$(eval $(call KernelPackage,nss-ifb))
+
diff --git a/package/qca/nss-ifb/README.md b/package/qca/nss-ifb/README.md
new file mode 100644
index 0000000000..a0af7a5ebf
--- /dev/null
+++ b/package/qca/nss-ifb/README.md
@@ -0,0 +1,45 @@
+NSS Physical Interface Ingress Driver
+=====================================
+
+This driver redirect NSS physical interface (namely GMACs) ingress traffic to itself
+and sends it back to the Linux network stack (as the source GMACs packets) as it's
+egress traffic.
+
+This allows the NSS QDISC drivers to manage the egress traffic of this driver's
+NSS virtual interface.
+
+This driver will create a single network interface named 'nssifb'.  The default
+source interface is defined as 'eth0'.  It can be changed using the following module
+parameter path:
+
+/sys/module/nss-ifb/parameter/nss_src_dev
+
+To change the source NSS physical interface to 'eth1', use the following command:
+
+printf eth1 > /sys/module/nss-ifb/parameter/nss_src_dev
+
+You need to change the source interface first before bringing up the 'nssifb'
+interface.  Changing it after the interface is up will have no effect.  You need
+to bring down the interface and bring it back up to have the changes take effect.
+
+CPU load imposed on the Krait CPUs appears negligible with this driver intercepting
+the physical interface's ingress traffic.  Full line speed of the GMAC interface
+could still be achieved.
+
+The commands below shows an example to shape ingress traffic to 500 Mbps and egress
+to 200 Mbps for the 'eth0' interface.
+
+# Load the module if it's not loaded
+modprobe nss-ifb
+
+# Bring up the nssifb interface to active ingress redirect
+ip link set up nssifb
+
+# Shape ingress traffic to 500 Mbit with chained NSSFQ_CODEL
+tc qdisc add dev nssifb root handle 1: nsstbl rate 500Mbit burst 1Mb
+tc qdisc add dev nssifb parent 1: handle 10: nssfq_codel limit 10240 flows 1024 quantum 1514 target 5ms interval 100ms set_default
+
+# Shape egress traffic to 200 Mbit with chained NSSFQ_CODEL
+tc qdisc add dev eth0 root handle 1: nsstbl rate 200Mbit burst 1Mb
+tc qdisc add dev eth0 parent 1: handle 10: nssfq_codel limit 10240 flows 1024 quantum 1514 target 5ms interval 100ms set_default
+
diff --git a/package/qca/nss-ifb/src/Makefile b/package/qca/nss-ifb/src/Makefile
new file mode 100644
index 0000000000..332b9b4ed6
--- /dev/null
+++ b/package/qca/nss-ifb/src/Makefile
@@ -0,0 +1,3 @@
+obj-m += nss-ifb.o
+
+nss-ifb-objs := nss_ifb.o
diff --git a/package/qca/nss-ifb/src/nss_ifb.c b/package/qca/nss-ifb/src/nss_ifb.c
new file mode 100644
index 0000000000..18c017fe0d
--- /dev/null
+++ b/package/qca/nss-ifb/src/nss_ifb.c
@@ -0,0 +1,304 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/*
+ * This driver is adapted from the Linux /drivers/net/ifb.c file.
+ *
+ * Redirect QCA NSS physical interface ingress traffic to this driver's
+ * virtual interface.  This will allow ingress traffic shaping using the
+ * QCA NSS shaper.
+ */
+
+#include <nss_api_if.h>
+
+#define TX_Q_LIMIT    32
+
+struct nss_ifb_dev_private {
+	struct nss_virt_if_handle *nssctx;
+	struct net_device *nss_src_dev;
+	uint32_t nss_src_if_num;
+	char nss_src_dev_name[32];
+};
+
+char nss_dev_name_array[32] = "eth0";
+char *nss_dev_name = nss_dev_name_array;
+module_param(nss_dev_name, charp, 0644);
+MODULE_PARM_DESC(nss_dev_name, "NSS physical interface source device name");
+
+/*
+ * Virtual interface egress packet callback.
+ *
+ * We send it back to the Linux network stack.
+ */
+static void nss_ifb_data_cb(struct net_device *netdev, struct sk_buff *skb, struct napi_struct *napi)
+{
+	struct nss_ifb_dev_private *dp = netdev_priv(netdev);
+
+	skb->protocol = eth_type_trans(skb, dp->nss_src_dev);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	napi_gro_receive(napi, skb);
+}
+
+/*
+ * Virtual interface ingress packet callback.
+ *
+ * We just send it back to the NSS firmware to let the shaper work on it.
+ */
+static void nss_ifb_xmit_cb(struct net_device *netdev, struct sk_buff *skb)
+{
+	struct nss_ifb_dev_private *dp = netdev_priv(netdev);
+	int ret;
+
+	ret = nss_virt_if_tx_buf(dp->nssctx, skb);
+	if (unlikely(ret)) {
+		pr_warn("Failed [%d] to send skb [len: %d, protocol: 0x%X] to NSS!\n",
+			ret, skb->len, ntohs(skb->protocol));
+	}
+}
+
+static void nss_ifb_stats64(struct net_device *dev,
+			struct rtnl_link_stats64 *stats)
+{
+
+}
+
+static int nss_ifb_dev_init(struct net_device *dev)
+{
+	struct nss_ifb_dev_private *dp =  netdev_priv(dev);
+
+	dp->nssctx = nss_virt_if_create_sync_nexthop(dev, NSS_ETH_RX_INTERFACE, NSS_ETH_RX_INTERFACE);
+	if (!dp->nssctx) {
+		dp->nssctx = NULL;
+		pr_warn("Could not create a NSS virtual interface for dev [%s]\n",
+			dev->name);
+
+		return -ENODEV;
+	}
+	pr_info("Created a NSS virtual interface for dev [%s]\n", dev->name);
+
+	nss_virt_if_register(dp->nssctx, nss_ifb_data_cb, dev);
+	pr_info("NSS IFB data callback registered\n");
+
+	nss_virt_if_xmit_callback_register(dp->nssctx, nss_ifb_xmit_cb);
+	pr_info("NSS IFB transmit callback registered\n");
+
+	return 0;
+}
+
+static void nss_ifb_dev_uninit(struct net_device *dev)
+{
+	struct nss_ifb_dev_private *dp = netdev_priv(dev);
+	int ret;
+
+	nss_virt_if_xmit_callback_unregister(dp->nssctx);
+	pr_info("NSS IFB transmit callback unregistered\n");
+
+	ret = nss_virt_if_destroy_sync(dp->nssctx);
+	if (ret == NSS_TX_SUCCESS) {
+		pr_info("NSS virtual interface destroyed for dev [%s]\n", dev->name);
+	}
+	else {
+		pr_warn("Unable to destroy NSS virtual interface for dev [%s], error[%d]\n",
+		dev->name, ret);
+	}
+	dp->nssctx = NULL;
+}
+
+static netdev_tx_t nss_ifb_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	return NETDEV_TX_OK;
+}
+
+static int nss_ifb_close(struct net_device *dev)
+{
+	struct nss_ifb_dev_private *dp = netdev_priv(dev);
+	struct nss_ctx_instance *nss_ctx;
+	struct net_device *src_dev;
+	uint32_t src_if_num;
+	int ret;
+
+	nss_ctx = dp->nssctx->nss_ctx;
+	src_dev = dp->nss_src_dev;
+	src_if_num = dp->nss_src_if_num;
+
+	ret = nss_phys_if_set_nexthop(nss_ctx, src_if_num, NSS_ETH_RX_INTERFACE);
+	if (ret != NSS_TX_SUCCESS) {
+		pr_warn("%p: Failed to reset next hop for net device [%s].\n",
+			nss_ctx, src_dev->name);
+	}
+	else {
+		pr_info("%p: Reset nexthop successful for net device [%s].\n",
+			nss_ctx, src_dev->name);
+	}
+
+	dev_put(src_dev);
+	dp->nss_src_dev = NULL;
+	dp->nss_src_if_num = -1;
+
+	return 0;
+}
+
+static int nss_ifb_open(struct net_device *dev)
+{
+	struct nss_ifb_dev_private *dp = netdev_priv(dev);
+	struct net_device *src_dev;
+	uint32_t src_if_num;
+	uint32_t nh_if_num;
+	nss_tx_status_t nss_tx_status;
+	struct nss_ctx_instance *nss_ctx;
+
+	nss_ctx = dp->nssctx->nss_ctx;
+	nh_if_num = dp->nssctx->if_num_n2h;
+
+	strcpy(dp->nss_src_dev_name, nss_dev_name);
+
+	src_dev = dev_get_by_name(&init_net, dp->nss_src_dev_name);
+	if (!src_dev) {
+		pr_warn("%p: Cannot find the net device [%s]\n",
+			nss_ctx, dp->nss_src_dev_name);
+
+		return -ENODEV;
+	}
+	pr_info("%p: Found net device [%s]\n", nss_ctx, dp->nss_src_dev_name);
+
+	src_if_num = nss_cmn_get_interface_number_by_dev(src_dev);
+	if (src_if_num < 0) {
+		pr_warn("%p: Invalid interface number:%d\n", nss_ctx, src_if_num);
+		dev_put(src_dev);
+
+		return -ENODEV;
+	}
+	pr_info("%p: Net device [%s] has NSS intf_num [%d]\n",
+		nss_ctx, dp->nss_src_dev_name, src_if_num);
+
+	nss_tx_status = nss_phys_if_set_nexthop(nss_ctx, src_if_num, nh_if_num);
+	if (nss_tx_status != NSS_TX_SUCCESS) {
+		pr_warn("%p: Sending message failed, cannot change nexthop for [%s]\n",
+			nss_ctx, dp->nss_src_dev_name);
+	}
+	else {
+		pr_info("Nexthop successfully set for [%s] to [%s]\n",
+			dp->nss_src_dev_name, dev->name);
+	}
+
+	dp->nss_src_dev = src_dev;
+	dp->nss_src_if_num = src_if_num;
+
+	return 0;
+}
+
+static const struct net_device_ops nss_ifb_netdev_ops = {
+	.ndo_open	= nss_ifb_open,
+	.ndo_stop	= nss_ifb_close,
+	.ndo_get_stats64 = nss_ifb_stats64,
+	.ndo_start_xmit	= nss_ifb_xmit,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_init	= nss_ifb_dev_init,
+	.ndo_uninit	= nss_ifb_dev_uninit,
+};
+
+#define IFB_FEATURES (NETIF_F_HW_CSUM | NETIF_F_SG  | NETIF_F_FRAGLIST	| \
+		      NETIF_F_TSO_ECN | NETIF_F_TSO | NETIF_F_TSO6	| \
+		      NETIF_F_GSO_ENCAP_ALL 				| \
+		      NETIF_F_HIGHDMA | NETIF_F_HW_VLAN_CTAG_TX		| \
+		      NETIF_F_HW_VLAN_STAG_TX)
+
+static void nss_ifb_dev_free(struct net_device *dev)
+{
+
+}
+
+static void nss_ifb_setup(struct net_device *dev)
+{
+	/* Initialize the device structure. */
+	dev->netdev_ops = &nss_ifb_netdev_ops;
+
+	/* Fill in device structure with ethernet-generic values. */
+	ether_setup(dev);
+	dev->tx_queue_len = TX_Q_LIMIT;
+
+	dev->features |= IFB_FEATURES;
+	dev->hw_features |= dev->features;
+	dev->hw_enc_features |= dev->features;
+	dev->vlan_features |= IFB_FEATURES & ~(NETIF_F_HW_VLAN_CTAG_TX |
+					       NETIF_F_HW_VLAN_STAG_TX);
+
+	dev->flags |= IFF_NOARP;
+	dev->flags &= ~IFF_MULTICAST;
+	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+	netif_keep_dst(dev);
+	eth_hw_addr_random(dev);
+	dev->needs_free_netdev = true;
+	dev->priv_destructor = nss_ifb_dev_free;
+
+	dev->min_mtu = 0;
+	dev->max_mtu = 0;
+}
+
+static int nss_ifb_validate(struct nlattr *tb[], struct nlattr *data[],
+			struct netlink_ext_ack *extack)
+{
+	if (tb[IFLA_ADDRESS]) {
+		if (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)
+			return -EINVAL;
+		if (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))
+			return -EADDRNOTAVAIL;
+	}
+	return 0;
+}
+
+static struct rtnl_link_ops nss_ifb_link_ops __read_mostly = {
+	.kind		= "nss_ifb",
+	.priv_size	= sizeof(struct nss_ifb_dev_private),
+	.setup		= nss_ifb_setup,
+	.validate	= nss_ifb_validate,
+};
+
+static int __init nss_ifb_init_module(void)
+{
+	struct net_device *dev;
+	int err;
+
+	down_write(&pernet_ops_rwsem);
+	rtnl_lock();
+	err = __rtnl_link_register(&nss_ifb_link_ops);
+	if (err < 0)
+		goto out;
+
+	dev = alloc_netdev(sizeof(struct nss_ifb_dev_private), "nssifb",
+			NET_NAME_UNKNOWN, nss_ifb_setup);
+
+	if (dev) {
+		dev->rtnl_link_ops = &nss_ifb_link_ops;
+		err = register_netdevice(dev);
+	}
+	else {
+		err = -ENOMEM;
+	}
+
+	if (err)
+		__rtnl_link_unregister(&nss_ifb_link_ops);
+
+out:
+	rtnl_unlock();
+	up_write(&pernet_ops_rwsem);
+
+	if (!err)
+		pr_info("NSS IFB module loaded.\n");
+	else
+		pr_warn("Failed to load NSS IFB module.\n");
+
+	return err;
+}
+
+static void __exit nss_ifb_cleanup_module(void)
+{
+	rtnl_link_unregister(&nss_ifb_link_ops);
+
+	pr_info("NSS IFB module unloaded.\n");
+}
+
+module_init(nss_ifb_init_module);
+module_exit(nss_ifb_cleanup_module);
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_RTNL_LINK("nss_ifb");
diff --git a/package/qca/qca-nss-cfi/Makefile b/package/qca/qca-nss-cfi/Makefile
new file mode 100644
index 0000000000..4efce71514
--- /dev/null
+++ b/package/qca/qca-nss-cfi/Makefile
@@ -0,0 +1,98 @@
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=qca-nss-cfi
+PKG_RELEASE:=2
+
+PKG_SOURCE_URL:=https://source.codeaurora.org/quic/qsdk/oss/lklm/nss-cfi
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_VERSION:=8035a8ddefdcc8a2f06c96b2a82618ca6ce6406d
+
+include $(INCLUDE_DIR)/package.mk
+
+ifeq ($(CONFIG_TARGET_ipq),y)
+subtarget:=$(SUBTARGET)
+else
+subtarget:=$(CONFIG_TARGET_BOARD)
+endif
+
+# v1.0 is for Akronite
+# v2.0 is for Hawkeye/Cypress/Maple
+ifneq (, $(findstring $(subtarget), "ipq807x" "ipq807x_64" "ipq60xx" "ipq60xx_64"))
+  CFI_OCF_DIR:=ocf/v2.0
+  CFI_CRYPTOAPI_DIR:=cryptoapi/v2.0
+else
+  CFI_CRYPTOAPI_DIR:=cryptoapi/v1.1
+  CFI_OCF_DIR:=ocf/v1.0
+  CFI_IPSEC_DIR:=ipsec/v1.0
+endif
+
+define KernelPackage/qca-nss-cfi-cryptoapi
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  DEPENDS:=@TARGET_ipq806x||TARGET_ipq_ipq806x||TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq807x||TARGET_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64 \
+		+kmod-qca-nss-crypto +kmod-crypto-authenc @!LINUX_3_18
+  TITLE:=Kernel driver for NSS cfi
+  FILES:=$(PKG_BUILD_DIR)/$(CFI_CRYPTOAPI_DIR)/qca-nss-cfi-cryptoapi.ko
+  AUTOLOAD:=$(call AutoLoad,59,qca-nss-cfi-cryptoapi)
+endef
+
+# OCF should be dropped
+# define KernelPackage/qca-nss-cfi-ocf
+#   SECTION:=kernel
+#   CATEGORY:=Kernel modules
+#   SUBMENU:=Network Devices
+#   DEPENDS:=@TARGET_ipq806x||TARGET_ipq_ipq806x||TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq807x||TARGET_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64 \
+# 		+kmod-qca-nss-crypto +PACKAGE_kmod-crypto-ocf:kmod-crypto-ocf @!LINUX_3_18
+#   TITLE:=Kernel driver for NSS cfi
+#   FILES:=$(PKG_BUILD_DIR)/$(CFI_OCF_DIR)/qca-nss-cfi-ocf.ko
+
+# ifdef CFI_IPSEC_DIR
+#   FILES+=$(PKG_BUILD_DIR)/$(CFI_IPSEC_DIR)/qca-nss-ipsec.ko
+#   AUTOLOAD:=$(call AutoLoad,61,qca-nss-cfi-ocf qca-nss-ipsec)
+# else
+#   AUTOLOAD:=$(call AutoLoad,61,qca-nss-cfi-ocf)
+# endif
+# endef
+
+define Build/InstallDev/qca-nss-cfi
+	$(INSTALL_DIR) $(1)/usr/include/qca-nss-cfi
+	$(CP) $(PKG_BUILD_DIR)/$(CFI_CRYPTOAPI_DIR)/../exports/* $(1)/usr/include/qca-nss-cfi
+	$(CP) $(PKG_BUILD_DIR)/include/* $(1)/usr/include/qca-nss-cfi
+endef
+
+define Build/InstallDev
+	$(call Build/InstallDev/qca-nss-cfi,$(1))
+endef
+
+define KernelPackage/qca-nss-cfi/Description
+This package contains a NSS cfi driver for QCA chipset
+endef
+
+EXTRA_CFLAGS+= \
+	-DCONFIG_NSS_DEBUG_LEVEL=4 \
+	-I$(LINUX_DIR)/crypto/ocf \
+	-I$(STAGING_DIR)/usr/include/qca-nss-crypto \
+	-I$(STAGING_DIR)/usr/include/crypto \
+	-I$(STAGING_DIR)/usr/include/qca-nss-drv
+
+ifneq (, $(findstring $(subtarget), "ipq807x" "ipq807x_64" "ipq60xx" "ipq60xx_64"))
+EXTRA_CFLAGS+= -I$(STAGING_DIR)/usr/include/qca-nss-clients
+endif
+
+define Build/Compile
+	$(MAKE) $(PKG_JOBS) -C "$(LINUX_DIR)" \
+		$(KERNEL_MAKE_FLAGS) \
+		$(PKG_MAKE_FLAGS) \
+		M="$(PKG_BUILD_DIR)" \
+		EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
+		CFI_CRYPTOAPI_DIR=$(CFI_CRYPTOAPI_DIR) \
+		CFI_OCF_DIR=$(CFI_OCF_DIR) \
+		CFI_IPSEC_DIR=$(CFI_IPSEC_DIR) \
+		SoC=$(subtarget) \
+		modules
+endef
+
+$(eval $(call KernelPackage,qca-nss-cfi-cryptoapi))
+#$(eval $(call KernelPackage,qca-nss-cfi-ocf))
diff --git a/package/qca/qca-nss-cfi/patches/0001-compile-only-cryptoapi.patch b/package/qca/qca-nss-cfi/patches/0001-compile-only-cryptoapi.patch
new file mode 100644
index 0000000000..00968f5fe3
--- /dev/null
+++ b/package/qca/qca-nss-cfi/patches/0001-compile-only-cryptoapi.patch
@@ -0,0 +1,30 @@
+From a8a573c5ce83bdddca9a60c62161638a5fd906d4 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Sat, 13 Jun 2020 12:57:14 +0200
+Subject: [PATCH 1/3] compile only cryptoapi
+
+---
+ Makefile | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/Makefile b/Makefile
+index c42adca..36a9d3f 100644
+--- a/Makefile
++++ b/Makefile
+@@ -4,9 +4,9 @@
+ 
+ export BUILD_ID = \"Build Id: $(shell date +'%m/%d/%y, %H:%M:%S')\"
+ 
+-obj-m += $(CFI_OCF_DIR)/
++# obj-m += $(CFI_OCF_DIR)/
+ obj-m += $(CFI_CRYPTOAPI_DIR)/
+ 
+-ifeq ($(SoC),$(filter $(SoC),ipq806x))
+-obj-m += $(CFI_IPSEC_DIR)/
+-endif
++# ifeq ($(SoC),$(filter $(SoC),ipq806x))
++# obj-m += $(CFI_IPSEC_DIR)/
++# endif
+-- 
+2.27.0.rc0
+
diff --git a/package/qca/qca-nss-cfi/patches/0002-wip-support-5.4.patch b/package/qca/qca-nss-cfi/patches/0002-wip-support-5.4.patch
new file mode 100644
index 0000000000..d68fc939b9
--- /dev/null
+++ b/package/qca/qca-nss-cfi/patches/0002-wip-support-5.4.patch
@@ -0,0 +1,78 @@
+From 202f57bae49947a04301ac8ac9bdc00f28f09355 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Sat, 13 Jun 2020 12:58:26 +0200
+Subject: [PATCH 2/3] wip: support 5.4
+
+---
+ cryptoapi/v1.1/nss_cryptoapi.c      |  1 -
+ cryptoapi/v1.1/nss_cryptoapi_ablk.c | 12 ++++++------
+ cryptoapi/v1.1/nss_cryptoapi_aead.c |  2 +-
+ 3 files changed, 7 insertions(+), 8 deletions(-)
+
+diff --git a/cryptoapi/v1.1/nss_cryptoapi.c b/cryptoapi/v1.1/nss_cryptoapi.c
+index d1a7313..a10590e 100644
+--- a/cryptoapi/v1.1/nss_cryptoapi.c
++++ b/cryptoapi/v1.1/nss_cryptoapi.c
+@@ -231,7 +231,6 @@ static struct crypto_alg cryptoapi_ablkcipher_algs[] = {
+ 		.cra_u          = {
+ 			.ablkcipher = {
+ 				.ivsize         = CTR_RFC3686_IV_SIZE,
+-				.geniv          = "seqiv",
+ 				.min_keysize    = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+ 				.max_keysize    = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+ 				.setkey         = nss_cryptoapi_ablk_aes_setkey,
+diff --git a/cryptoapi/v1.1/nss_cryptoapi_ablk.c b/cryptoapi/v1.1/nss_cryptoapi_ablk.c
+index 223591c..9b6c65e 100644
+--- a/cryptoapi/v1.1/nss_cryptoapi_ablk.c
++++ b/cryptoapi/v1.1/nss_cryptoapi_ablk.c
+@@ -108,7 +108,7 @@ EXPORT_SYMBOL(nss_cryptoapi_skcipher_ctx2session);
+ int nss_cryptoapi_ablkcipher_init(struct crypto_tfm *tfm)
+ {
+ 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
+-	struct crypto_ablkcipher *sw_tfm;
++	struct crypto_cipher *sw_tfm;
+ 
+ 	nss_cfi_assert(ctx);
+ 
+@@ -122,20 +122,20 @@ int nss_cryptoapi_ablkcipher_init(struct crypto_tfm *tfm)
+ 
+ 	nss_cryptoapi_set_magic(ctx);
+ 
+-	if (!(crypto_tfm_alg_flags(tfm) & CRYPTO_ALG_NEED_FALLBACK))
++	if (!(crypto_tfm_alg_type(tfm) & CRYPTO_ALG_NEED_FALLBACK))
+ 		return 0;
+ 
+ 	/* Alloc fallback transform for future use */
+-	sw_tfm = crypto_alloc_ablkcipher(crypto_tfm_alg_name(tfm), 0, CRYPTO_ALG_ASYNC |
+-									CRYPTO_ALG_NEED_FALLBACK);
++	sw_tfm = crypto_alloc_cipher(crypto_tfm_alg_name(tfm), 0, CRYPTO_ALG_ASYNC |
++ 									CRYPTO_ALG_NEED_FALLBACK);
+ 	if (IS_ERR(sw_tfm)) {
+ 		nss_cfi_err("unable to alloc software crypto for %s\n", crypto_tfm_alg_name(tfm));
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* set this tfm reqsize same to fallback tfm */
+-	tfm->crt_ablkcipher.reqsize = crypto_ablkcipher_reqsize(sw_tfm);
+-	ctx->sw_tfm = crypto_ablkcipher_tfm(sw_tfm);
++	tfm->crt_ablkcipher.reqsize = sizeof(struct nss_cryptoapi_ctx);
++	ctx->sw_tfm = crypto_cipher_tfm(sw_tfm);
+ 
+ 	return 0;
+ }
+diff --git a/cryptoapi/v1.1/nss_cryptoapi_aead.c b/cryptoapi/v1.1/nss_cryptoapi_aead.c
+index 527936b..53e4bed 100644
+--- a/cryptoapi/v1.1/nss_cryptoapi_aead.c
++++ b/cryptoapi/v1.1/nss_cryptoapi_aead.c
+@@ -103,7 +103,7 @@ int nss_cryptoapi_aead_init(struct crypto_aead *aead)
+ 
+ 	nss_cryptoapi_set_magic(ctx);
+ 
+-	if (!(crypto_tfm_alg_flags(tfm) & CRYPTO_ALG_NEED_FALLBACK))
++	if (!(crypto_tfm_alg_type(tfm) & CRYPTO_ALG_NEED_FALLBACK))
+ 		return 0;
+ 
+ 	/* Alloc fallback transform for future use */
+-- 
+2.27.0.rc0
+
diff --git a/package/qca/qca-nss-cfi/patches/0003-Convert-ablkcipher-to-skcipher.patch b/package/qca/qca-nss-cfi/patches/0003-Convert-ablkcipher-to-skcipher.patch
new file mode 100644
index 0000000000..b4520a3d67
--- /dev/null
+++ b/package/qca/qca-nss-cfi/patches/0003-Convert-ablkcipher-to-skcipher.patch
@@ -0,0 +1,707 @@
+From e3a53a6d11b2c1770545a2820a58c117799bcb70 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Tue, 16 Jun 2020 18:12:34 +0200
+Subject: [PATCH 3/3] Convert ablkcipher to skcipher
+
+---
+ cryptoapi/v1.1/nss_cryptoapi.c         | 149 +++++++++++--------------
+ cryptoapi/v1.1/nss_cryptoapi_ablk.c    | 136 +++++++++++-----------
+ cryptoapi/v1.1/nss_cryptoapi_debugfs.c |   1 +
+ cryptoapi/v1.1/nss_cryptoapi_private.h |  16 +--
+ 4 files changed, 145 insertions(+), 157 deletions(-)
+
+diff --git a/cryptoapi/v1.1/nss_cryptoapi.c b/cryptoapi/v1.1/nss_cryptoapi.c
+index a10590e..3a835dc 100644
+--- a/cryptoapi/v1.1/nss_cryptoapi.c
++++ b/cryptoapi/v1.1/nss_cryptoapi.c
+@@ -66,7 +66,7 @@ struct aead_alg cryptoapi_aead_algs[] = {
+ 			.cra_name       = "echainiv(authenc(hmac(sha1),cbc(aes)))",
+ 			.cra_driver_name = "nss-hmac-sha1-cbc-aes",
+ 			.cra_priority   = 10000,
+-			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK,
++			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
+ 			.cra_blocksize  = AES_BLOCK_SIZE,
+ 			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+ 			.cra_alignmask  = 0,
+@@ -87,7 +87,7 @@ struct aead_alg cryptoapi_aead_algs[] = {
+ 			.cra_name       = "seqiv(authenc(hmac(sha1),rfc3686(ctr(aes))))",
+ 			.cra_driver_name = "nss-hmac-sha1-rfc3686-ctr-aes",
+ 			.cra_priority   = 10000,
+-			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK,
++			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
+ 			.cra_blocksize  = AES_BLOCK_SIZE,
+ 			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+ 			.cra_alignmask  = 0,
+@@ -108,7 +108,7 @@ struct aead_alg cryptoapi_aead_algs[] = {
+ 			.cra_name       = "echainiv(authenc(hmac(sha1),cbc(des3_ede)))",
+ 			.cra_driver_name = "nss-hmac-sha1-cbc-3des",
+ 			.cra_priority   = 300,
+-			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG,
++			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_KERN_DRIVER_ONLY,
+ 			.cra_blocksize  = DES3_EDE_BLOCK_SIZE,
+ 			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+ 			.cra_alignmask  = 0,
+@@ -129,7 +129,7 @@ struct aead_alg cryptoapi_aead_algs[] = {
+ 			.cra_name       = "echainiv(authenc(hmac(sha256),cbc(aes)))",
+ 			.cra_driver_name = "nss-hmac-sha256-cbc-aes",
+ 			.cra_priority   = 10000,
+-			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK,
++			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
+ 			.cra_blocksize  = AES_BLOCK_SIZE,
+ 			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+ 			.cra_alignmask  = 0,
+@@ -150,7 +150,7 @@ struct aead_alg cryptoapi_aead_algs[] = {
+ 			.cra_name       = "seqiv(authenc(hmac(sha256),rfc3686(ctr(aes))))",
+ 			.cra_driver_name = "nss-hmac-sha256-rfc3686-ctr-aes",
+ 			.cra_priority   = 10000,
+-			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK,
++			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
+ 			.cra_blocksize  = AES_BLOCK_SIZE,
+ 			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+ 			.cra_alignmask  = 0,
+@@ -171,7 +171,7 @@ struct aead_alg cryptoapi_aead_algs[] = {
+ 			.cra_name       = "echainiv(authenc(hmac(sha256),cbc(des3_ede)))",
+ 			.cra_driver_name = "nss-hmac-sha256-cbc-3des",
+ 			.cra_priority   = 300,
+-			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG,
++			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_KERN_DRIVER_ONLY,
+ 			.cra_blocksize  = DES3_EDE_BLOCK_SIZE,
+ 			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+ 			.cra_alignmask  = 0,
+@@ -192,75 +192,66 @@ struct aead_alg cryptoapi_aead_algs[] = {
+ /*
+  * ABLK cipher algorithms
+  */
+-static struct crypto_alg cryptoapi_ablkcipher_algs[] = {
++static struct skcipher_alg cryptoapi_skcipher_algs[] = {
+ 	{
+-		.cra_name       = "cbc(aes)",
+-		.cra_driver_name = "nss-cbc-aes",
+-		.cra_priority   = 10000,
+-		.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,
+-		.cra_blocksize  = AES_BLOCK_SIZE,
+-		.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+-		.cra_alignmask  = 0,
+-		.cra_type       = &crypto_ablkcipher_type,
+-		.cra_module     = THIS_MODULE,
+-		.cra_init       = nss_cryptoapi_ablkcipher_init,
+-		.cra_exit       = nss_cryptoapi_ablkcipher_exit,
+-		.cra_u          = {
+-			.ablkcipher = {
+-				.ivsize         = AES_BLOCK_SIZE,
+-				.min_keysize    = AES_MIN_KEY_SIZE,
+-				.max_keysize    = AES_MAX_KEY_SIZE,
+-				.setkey         = nss_cryptoapi_ablk_aes_setkey,
+-				.encrypt        = nss_cryptoapi_ablk_aes_encrypt,
+-				.decrypt        = nss_cryptoapi_ablk_aes_decrypt,
+-			},
++		.base = {
++			.cra_name       = "cbc(aes)",
++			.cra_driver_name = "nss-cbc-aes",
++			.cra_priority   = 10000,
++			.cra_flags      = CRYPTO_ALG_TYPE_SKCIPHER | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
++			.cra_blocksize  = AES_BLOCK_SIZE,
++			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
++			.cra_alignmask  = 0,
++			.cra_module     = THIS_MODULE,
+ 		},
++		.init       = nss_cryptoapi_skcipher_init,
++		.exit       = nss_cryptoapi_skcipher_exit,
++		.ivsize         = AES_BLOCK_SIZE,
++		.min_keysize    = AES_MIN_KEY_SIZE,
++		.max_keysize    = AES_MAX_KEY_SIZE,
++		.setkey         = nss_cryptoapi_ablk_aes_setkey,
++		.encrypt        = nss_cryptoapi_ablk_aes_encrypt,
++		.decrypt        = nss_cryptoapi_ablk_aes_decrypt,
+ 	},
+ 	{
+-		.cra_name       = "rfc3686(ctr(aes))",
+-		.cra_driver_name = "nss-rfc3686-ctr-aes",
+-		.cra_priority   = 30000,
+-		.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,
+-		.cra_blocksize  = AES_BLOCK_SIZE,
+-		.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+-		.cra_alignmask  = 0,
+-		.cra_type       = &crypto_ablkcipher_type,
+-		.cra_module     = THIS_MODULE,
+-		.cra_init       = nss_cryptoapi_ablkcipher_init,
+-		.cra_exit       = nss_cryptoapi_ablkcipher_exit,
+-		.cra_u          = {
+-			.ablkcipher = {
+-				.ivsize         = CTR_RFC3686_IV_SIZE,
+-				.min_keysize    = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+-				.max_keysize    = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+-				.setkey         = nss_cryptoapi_ablk_aes_setkey,
+-				.encrypt        = nss_cryptoapi_ablk_aes_encrypt,
+-				.decrypt        = nss_cryptoapi_ablk_aes_decrypt,
+-			},
++		.base = {
++			.cra_name       = "rfc3686(ctr(aes))",
++			.cra_driver_name = "nss-rfc3686-ctr-aes",
++			.cra_priority   = 30000,
++			.cra_flags      = CRYPTO_ALG_TYPE_SKCIPHER | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
++			.cra_blocksize  = AES_BLOCK_SIZE,
++			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
++			.cra_alignmask  = 0,
++			.cra_module     = THIS_MODULE,
+ 		},
++		.init       = nss_cryptoapi_skcipher_init,
++		.exit       = nss_cryptoapi_skcipher_exit,
++		.ivsize         = CTR_RFC3686_IV_SIZE,
++		.min_keysize    = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
++		.max_keysize    = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
++		.setkey         = nss_cryptoapi_ablk_aes_setkey,
++		.encrypt        = nss_cryptoapi_ablk_aes_encrypt,
++		.decrypt        = nss_cryptoapi_ablk_aes_decrypt,
+ 	},
+ 	{
+-		.cra_name       = "cbc(des3_ede)",
+-		.cra_driver_name = "nss-cbc-3des",
+-		.cra_priority   = 1000,
+-		.cra_flags      = CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_ASYNC,
+-		.cra_blocksize  = DES3_EDE_BLOCK_SIZE,
+-		.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
+-		.cra_alignmask  = 0,
+-		.cra_type       = &crypto_ablkcipher_type,
+-		.cra_module     = THIS_MODULE,
+-		.cra_init       = nss_cryptoapi_ablkcipher_init,
+-		.cra_exit       = nss_cryptoapi_ablkcipher_exit,
+-		.cra_u          = {
+-			.ablkcipher = {
+-				.ivsize         = DES3_EDE_BLOCK_SIZE,
+-				.min_keysize    = DES3_EDE_KEY_SIZE,
+-				.max_keysize    = DES3_EDE_KEY_SIZE,
+-				.setkey         = nss_cryptoapi_3des_cbc_setkey,
+-				.encrypt        = nss_cryptoapi_3des_cbc_encrypt,
+-				.decrypt        = nss_cryptoapi_3des_cbc_decrypt,
+-			},
++		.base = {
++			.cra_name       = "cbc(des3_ede)",
++			.cra_driver_name = "nss-cbc-3des",
++			.cra_priority   = 1000,
++			.cra_flags      = CRYPTO_ALG_TYPE_SKCIPHER | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY,
++			.cra_blocksize  = DES3_EDE_BLOCK_SIZE,
++			.cra_ctxsize    = sizeof(struct nss_cryptoapi_ctx),
++			.cra_alignmask  = 0,
++			.cra_module     = THIS_MODULE,
+ 		},
++		.init       = nss_cryptoapi_skcipher_init,
++		.exit       = nss_cryptoapi_skcipher_exit,
++		.ivsize         = DES3_EDE_BLOCK_SIZE,
++		.min_keysize    = DES3_EDE_KEY_SIZE,
++		.max_keysize    = DES3_EDE_KEY_SIZE,
++		.setkey         = nss_cryptoapi_3des_cbc_setkey,
++		.encrypt        = nss_cryptoapi_3des_cbc_encrypt,
++		.decrypt        = nss_cryptoapi_3des_cbc_decrypt,
+ 	},
+ };
+ 
+@@ -277,14 +268,14 @@ static nss_crypto_user_ctx_t nss_cryptoapi_register(nss_crypto_handle_t crypto)
+ 
+ 	sc->crypto = crypto;
+ 
+-	for (i = 0; i < ARRAY_SIZE(cryptoapi_ablkcipher_algs); i++) {
+-		rc = crypto_register_alg(&cryptoapi_ablkcipher_algs[i]);
++	for (i = 0; i < ARRAY_SIZE(cryptoapi_skcipher_algs); i++) {
++		rc = crypto_register_skcipher(&cryptoapi_skcipher_algs[i]);
+ 		if (rc) {
+-			nss_cfi_trace("Ablk registration failed, algo: %s\n", cryptoapi_ablkcipher_algs[i].cra_name);
+-			cryptoapi_ablkcipher_algs[i].cra_flags = 0;
++			nss_cfi_trace("Ablk registration failed, algo: %s\n", cryptoapi_skcipher_algs[i].base.cra_name);
++			cryptoapi_skcipher_algs[i].base.cra_flags = 0;
+ 			continue;
+ 		}
+-		nss_cfi_info("Ablk registration succeeded, algo: %s\n", cryptoapi_ablkcipher_algs[i].cra_name);
++		nss_cfi_info("Ablk registration succeeded, algo: %s\n", cryptoapi_skcipher_algs[i].base.cra_name);
+ 	}
+ 
+ 	for (i = 0; i < ARRAY_SIZE(cryptoapi_aead_algs); i++) {
+@@ -317,7 +308,7 @@ static nss_crypto_user_ctx_t nss_cryptoapi_register(nss_crypto_handle_t crypto)
+ static void nss_cryptoapi_unregister(nss_crypto_user_ctx_t cfi)
+ {
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+-	int i, ret = 0;
++	int i;
+ 
+ 	nss_cfi_info("unregister nss_cryptoapi\n");
+ 
+@@ -326,16 +317,12 @@ static void nss_cryptoapi_unregister(nss_crypto_user_ctx_t cfi)
+ 	 */
+ 	atomic_set(&gbl_ctx.registered, 0);
+ 
+-	for (i = 0; i < ARRAY_SIZE(cryptoapi_ablkcipher_algs); i++) {
+-		if (!cryptoapi_ablkcipher_algs[i].cra_flags) {
+-			continue;
+-		}
+-		ret = crypto_unregister_alg(&cryptoapi_ablkcipher_algs[i]);
+-		if (ret) {
+-			nss_cfi_err("Ablk unregister failed, algo: %s\n", cryptoapi_ablkcipher_algs[i].cra_name);
++	for (i = 0; i < ARRAY_SIZE(cryptoapi_skcipher_algs); i++) {
++		if (!cryptoapi_skcipher_algs[i].base.cra_flags) {
+ 			continue;
+ 		}
+-		nss_cfi_info("Ablk unregister succeeded, algo: %s\n", cryptoapi_ablkcipher_algs[i].cra_name);
++		crypto_unregister_skcipher(&cryptoapi_skcipher_algs[i]);
++		nss_cfi_info("Ablk unregister succeeded, algo: %s\n", cryptoapi_skcipher_algs[i].base.cra_name);
+ 	}
+ 
+ 	for (i = 0; i < ARRAY_SIZE(cryptoapi_aead_algs); i++) {
+diff --git a/cryptoapi/v1.1/nss_cryptoapi_ablk.c b/cryptoapi/v1.1/nss_cryptoapi_ablk.c
+index 9b6c65e..913e9cc 100644
+--- a/cryptoapi/v1.1/nss_cryptoapi_ablk.c
++++ b/cryptoapi/v1.1/nss_cryptoapi_ablk.c
+@@ -102,12 +102,12 @@ int nss_cryptoapi_skcipher_ctx2session(struct crypto_skcipher *sk, uint32_t *sid
+ EXPORT_SYMBOL(nss_cryptoapi_skcipher_ctx2session);
+ 
+ /*
+- * nss_cryptoapi_ablkcipher_init()
+- * 	Cryptoapi ablkcipher init function.
++ * nss_cryptoapi_skcipher_init()
++ * 	Cryptoapi skcipher init function.
+  */
+-int nss_cryptoapi_ablkcipher_init(struct crypto_tfm *tfm)
++int nss_cryptoapi_skcipher_init(struct crypto_skcipher  *tfm)
+ {
+-	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
++	struct nss_cryptoapi_ctx *ctx = crypto_skcipher_ctx(tfm);
+ 	struct crypto_cipher *sw_tfm;
+ 
+ 	nss_cfi_assert(ctx);
+@@ -122,31 +122,31 @@ int nss_cryptoapi_ablkcipher_init(struct crypto_tfm *tfm)
+ 
+ 	nss_cryptoapi_set_magic(ctx);
+ 
+-	if (!(crypto_tfm_alg_type(tfm) & CRYPTO_ALG_NEED_FALLBACK))
++	if (!(crypto_tfm_alg_type(&tfm->base) & CRYPTO_ALG_NEED_FALLBACK))
+ 		return 0;
+ 
+ 	/* Alloc fallback transform for future use */
+-	sw_tfm = crypto_alloc_cipher(crypto_tfm_alg_name(tfm), 0, CRYPTO_ALG_ASYNC |
++	sw_tfm = crypto_alloc_cipher(crypto_tfm_alg_name(&tfm->base), 0, CRYPTO_ALG_ASYNC |
+  									CRYPTO_ALG_NEED_FALLBACK);
+ 	if (IS_ERR(sw_tfm)) {
+-		nss_cfi_err("unable to alloc software crypto for %s\n", crypto_tfm_alg_name(tfm));
++		nss_cfi_err("unable to alloc software crypto for %s\n", crypto_tfm_alg_name(&tfm->base));
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* set this tfm reqsize same to fallback tfm */
+-	tfm->crt_ablkcipher.reqsize = sizeof(struct nss_cryptoapi_ctx);
++	crypto_skcipher_set_reqsize(tfm, sizeof(struct nss_cryptoapi_ctx));
+ 	ctx->sw_tfm = crypto_cipher_tfm(sw_tfm);
+ 
+ 	return 0;
+ }
+ 
+ /*
+- * nss_cryptoapi_ablkcipher_exit()
+- * 	Cryptoapi ablkcipher exit function.
++ * nss_cryptoapi_skcipher_exit()
++ * 	Cryptoapi skcipher exit function.
+  */
+-void nss_cryptoapi_ablkcipher_exit(struct crypto_tfm *tfm)
++void nss_cryptoapi_skcipher_exit(struct crypto_skcipher *tfm)
+ {
+-	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
++	struct nss_cryptoapi_ctx *ctx = crypto_skcipher_ctx(tfm);
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+ 	nss_crypto_status_t status;
+ 
+@@ -158,7 +158,7 @@ void nss_cryptoapi_ablkcipher_exit(struct crypto_tfm *tfm)
+ 	}
+ 
+ 	if (ctx->sw_tfm) {
+-		crypto_free_ablkcipher(__crypto_ablkcipher_cast(ctx->sw_tfm));
++		crypto_free_skcipher(__crypto_skcipher_cast(ctx->sw_tfm));
+ 		ctx->sw_tfm = NULL;
+ 	}
+ 
+@@ -183,9 +183,9 @@ void nss_cryptoapi_ablkcipher_exit(struct crypto_tfm *tfm)
+  * nss_cryptoapi_ablk_aes_setkey()
+  * 	Cryptoapi setkey routine for aes.
+  */
+-int nss_cryptoapi_ablk_aes_setkey(struct crypto_ablkcipher *cipher, const u8 *key, unsigned int keylen)
++int nss_cryptoapi_ablk_aes_setkey(struct crypto_skcipher *cipher, const u8 *key, unsigned int keylen)
+ {
+-	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);
++	struct crypto_tfm *tfm = crypto_skcipher_tfm(cipher);
+ 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+ 	struct nss_crypto_key cip;
+@@ -255,10 +255,10 @@ int nss_cryptoapi_ablk_aes_setkey(struct crypto_ablkcipher *cipher, const u8 *ke
+ 
+ 		/* set flag to fallback tfm */
+ 		crypto_tfm_clear_flags(ctx->sw_tfm, CRYPTO_TFM_REQ_MASK);
+-		crypto_tfm_set_flags(ctx->sw_tfm, crypto_ablkcipher_get_flags(cipher) & CRYPTO_TFM_REQ_MASK);
++		crypto_tfm_set_flags(ctx->sw_tfm, crypto_skcipher_get_flags(cipher) & CRYPTO_TFM_REQ_MASK);
+ 
+ 		 /* Set key to the fallback tfm */
+-		ret = crypto_ablkcipher_setkey(__crypto_ablkcipher_cast(ctx->sw_tfm), key, keylen);
++		ret = crypto_skcipher_setkey(__crypto_skcipher_cast(ctx->sw_tfm), key, keylen);
+ 		if (ret) {
+ 			nss_cfi_err("Failed to set key to the sw crypto");
+ 
+@@ -266,7 +266,7 @@ int nss_cryptoapi_ablk_aes_setkey(struct crypto_ablkcipher *cipher, const u8 *ke
+ 			 * Set back the fallback tfm flag to the original flag one after
+ 			 * doing setkey
+ 			 */
+-			crypto_ablkcipher_set_flags(cipher, crypto_tfm_get_flags(ctx->sw_tfm));
++			crypto_skcipher_set_flags(cipher, crypto_tfm_get_flags(ctx->sw_tfm));
+ 		}
+ 		return ret;
+ 	default:
+@@ -289,23 +289,23 @@ int nss_cryptoapi_ablk_aes_setkey(struct crypto_ablkcipher *cipher, const u8 *ke
+ 	return 0;
+ 
+ fail:
+-	crypto_ablkcipher_set_flags(cipher, flag);
++	crypto_skcipher_set_flags(cipher, flag);
+ 	return -EINVAL;
+ }
+ 
+ /*
+- * nss_cryptoapi_ablkcipher_done()
++ * nss_cryptoapi_skcipher_done()
+  * 	Cipher operation completion callback function
+  */
+-void nss_cryptoapi_ablkcipher_done(struct nss_crypto_buf *buf)
++void nss_cryptoapi_skcipher_done(struct nss_crypto_buf *buf)
+ {
+ 	struct nss_cryptoapi_ctx *ctx;
+-	struct ablkcipher_request *req;
++	struct skcipher_request *req;
+ 	int err = 0;
+ 
+ 	nss_cfi_assert(buf);
+ 
+-	req = (struct ablkcipher_request *)nss_crypto_get_cb_ctx(buf);
++	req = (struct skcipher_request *)nss_crypto_get_cb_ctx(buf);
+ 
+ 	/*
+ 	 * check cryptoapi context magic number.
+@@ -319,7 +319,7 @@ void nss_cryptoapi_ablkcipher_done(struct nss_crypto_buf *buf)
+ 	nss_crypto_buf_free(gbl_ctx.crypto, buf);
+ 
+ 	nss_cfi_dbg("after transformation\n");
+-	nss_cfi_dbg_data(sg_virt(req->dst), req->nbytes, ' ');
++	nss_cfi_dbg_data(sg_virt(req->dst), req->cryptlen, ' ');
+ 
+ 	/*
+ 	 * Passing always pass in case of encrypt.
+@@ -337,7 +337,7 @@ void nss_cryptoapi_ablkcipher_done(struct nss_crypto_buf *buf)
+  * 	Cryptoapi: obtain sg to virtual address mapping.
+  * 	Check for multiple sg in src and dst
+  */
+-int nss_cryptoapi_ablk_checkaddr(struct ablkcipher_request *req)
++int nss_cryptoapi_ablk_checkaddr(struct skcipher_request *req)
+ {
+ 	/*
+ 	 * Currently only single sg is supported
+@@ -356,7 +356,7 @@ int nss_cryptoapi_ablk_checkaddr(struct ablkcipher_request *req)
+ 	/*
+ 	 * If the size of data is more than 65K reject transformation
+ 	 */
+-	if (req->nbytes > NSS_CRYPTOAPI_MAX_DATA_LEN) {
++	if (req->cryptlen > NSS_CRYPTOAPI_MAX_DATA_LEN) {
+ 		nss_cfi_err("Buffer length exceeded limit\n");
+ 		return -EINVAL;
+ 	}
+@@ -368,10 +368,10 @@ int nss_cryptoapi_ablk_checkaddr(struct ablkcipher_request *req)
+  * nss_cryptoapi_ablk_transform()
+  * 	Crytoapi common routine for encryption and decryption operations.
+  */
+-struct nss_crypto_buf *nss_cryptoapi_ablk_transform(struct ablkcipher_request *req, struct nss_cryptoapi_ablk_info *info)
++struct nss_crypto_buf *nss_cryptoapi_ablk_transform(struct skcipher_request *req, struct nss_cryptoapi_ablk_info *info)
+ {
+-	struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);
+-	struct nss_cryptoapi_ctx *ctx = crypto_ablkcipher_ctx(cipher);
++	struct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);
++	struct nss_cryptoapi_ctx *ctx = crypto_skcipher_ctx(cipher);
+ 	struct nss_crypto_buf *buf;
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+ 	nss_crypto_status_t status;
+@@ -382,7 +382,7 @@ struct nss_crypto_buf *nss_cryptoapi_ablk_transform(struct ablkcipher_request *r
+ 	nss_cfi_assert(ctx);
+ 
+ 	nss_cfi_dbg("src_vaddr: 0x%p, dst_vaddr: 0x%p, iv: 0x%p\n",
+-			sg_virt(req->src), sg_virt(req->dst), req->info);
++			sg_virt(req->src), sg_virt(req->dst), req->iv);
+ 
+ 	info->params->cipher_skip = 0;
+ 	info->params->auth_skip = 0;
+@@ -419,19 +419,19 @@ struct nss_crypto_buf *nss_cryptoapi_ablk_transform(struct ablkcipher_request *r
+ 	/*
+ 	 * Get IV location and memcpy the IV
+ 	 */
+-	iv_size = crypto_ablkcipher_ivsize(cipher);
++	iv_size = crypto_skcipher_ivsize(cipher);
+ 	iv_addr = nss_crypto_get_ivaddr(buf);
+ 
+ 	switch (ctx->cip_alg) {
+ 	case NSS_CRYPTO_CIPHER_AES_CBC:
+ 	case NSS_CRYPTO_CIPHER_DES:
+-		memcpy(iv_addr, req->info, iv_size);
++		memcpy(iv_addr, req->iv, iv_size);
+ 		break;
+ 
+ 	case NSS_CRYPTO_CIPHER_AES_CTR:
+ 		((uint32_t *)iv_addr)[0] = ctx->ctx_iv[0];
+-		((uint32_t *)iv_addr)[1] = ((uint32_t *)req->info)[0];
+-		((uint32_t *)iv_addr)[2] = ((uint32_t *)req->info)[1];
++		((uint32_t *)iv_addr)[1] = ((uint32_t *)req->iv)[0];
++		((uint32_t *)iv_addr)[2] = ((uint32_t *)req->iv)[1];
+ 		((uint32_t *)iv_addr)[3] = ctx->ctx_iv[3];
+ 		break;
+ 
+@@ -446,7 +446,7 @@ struct nss_crypto_buf *nss_cryptoapi_ablk_transform(struct ablkcipher_request *r
+ 	/*
+ 	 * Fill Cipher and Auth len
+ 	 */
+-	cipher_len = req->nbytes;
++	cipher_len = req->cryptlen;
+ 	auth_len = 0;
+ 
+ 	nss_crypto_set_data(buf, sg_virt(req->src), sg_virt(req->dst), cipher_len);
+@@ -463,12 +463,12 @@ struct nss_crypto_buf *nss_cryptoapi_ablk_transform(struct ablkcipher_request *r
+ }
+ 
+ /*
+- * nss_cryptoapi_ablkcipher_fallback()
+- *	Cryptoapi fallback for ablkcipher algorithm.
++ * nss_cryptoapi_skcipher_fallback()
++ *	Cryptoapi fallback for skcipher algorithm.
+  */
+-int nss_cryptoapi_ablkcipher_fallback(struct nss_cryptoapi_ctx *ctx, struct ablkcipher_request *req, int type)
++int nss_cryptoapi_skcipher_fallback(struct nss_cryptoapi_ctx *ctx, struct skcipher_request *req, int type)
+ {
+-	struct crypto_ablkcipher *orig_tfm = crypto_ablkcipher_reqtfm(req);
++	struct crypto_skcipher *orig_tfm = crypto_skcipher_reqtfm(req);
+ 	int err;
+ 
+ 	if (!ctx->sw_tfm) {
+@@ -476,16 +476,16 @@ int nss_cryptoapi_ablkcipher_fallback(struct nss_cryptoapi_ctx *ctx, struct ablk
+ 	}
+ 
+ 	/* Set new fallback tfm to the request */
+-	ablkcipher_request_set_tfm(req, __crypto_ablkcipher_cast(ctx->sw_tfm));
++	skcipher_request_set_tfm(req, __crypto_skcipher_cast(ctx->sw_tfm));
+ 
+ 	ctx->queued++;
+ 
+ 	switch (type) {
+ 	case NSS_CRYPTOAPI_ENCRYPT:
+-		err = crypto_ablkcipher_encrypt(req);
++		err = crypto_skcipher_encrypt(req);
+ 		break;
+ 	case NSS_CRYPTOAPI_DECRYPT:
+-		err = crypto_ablkcipher_decrypt(req);
++		err = crypto_skcipher_decrypt(req);
+ 		break;
+ 	default:
+ 		err = -EINVAL;
+@@ -495,7 +495,7 @@ int nss_cryptoapi_ablkcipher_fallback(struct nss_cryptoapi_ctx *ctx, struct ablk
+ 		ctx->completed++;
+ 
+ 	/* Set original tfm to the request */
+-	ablkcipher_request_set_tfm(req, orig_tfm);
++	skcipher_request_set_tfm(req, orig_tfm);
+ 
+ 	return err;
+ }
+@@ -504,13 +504,13 @@ int nss_cryptoapi_ablkcipher_fallback(struct nss_cryptoapi_ctx *ctx, struct ablk
+  * nss_cryptoapi_ablk_aes_encrypt()
+  * 	Crytoapi encrypt for aes(aes-cbc/rfc3686-aes-ctr) algorithms.
+  */
+-int nss_cryptoapi_ablk_aes_encrypt(struct ablkcipher_request *req)
++int nss_cryptoapi_ablk_aes_encrypt(struct skcipher_request *req)
+ {
+ 	struct nss_crypto_params params = { .req_type = NSS_CRYPTO_REQ_TYPE_ENCRYPT };
+-	struct nss_cryptoapi_ablk_info info = {.cb_fn = nss_cryptoapi_ablkcipher_done,
++	struct nss_cryptoapi_ablk_info info = {.cb_fn = nss_cryptoapi_skcipher_done,
+ 						.params = &params};
+-	struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);
+-	struct nss_cryptoapi_ctx *ctx = crypto_ablkcipher_ctx(cipher);
++	struct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);
++	struct nss_cryptoapi_ctx *ctx = crypto_skcipher_ctx(cipher);
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+ 	struct nss_crypto_buf *buf;
+ 
+@@ -520,7 +520,7 @@ int nss_cryptoapi_ablk_aes_encrypt(struct ablkcipher_request *req)
+ 	nss_cryptoapi_verify_magic(ctx);
+ 
+ 	if (ctx->fallback_req)
+-		return nss_cryptoapi_ablkcipher_fallback(ctx, req, NSS_CRYPTOAPI_ENCRYPT);
++		return nss_cryptoapi_skcipher_fallback(ctx, req, NSS_CRYPTOAPI_ENCRYPT);
+ 
+ 	/*
+ 	 * Check if previous call to setkey couldn't allocate session with core crypto.
+@@ -539,9 +539,9 @@ int nss_cryptoapi_ablk_aes_encrypt(struct ablkcipher_request *req)
+ 	 * According to RFC3686, AES-CTR algo need not be padded if the
+ 	 * plaintext or ciphertext is unaligned to block size boundary.
+ 	 */
+-	if (nss_cryptoapi_check_unalign(req->nbytes, AES_BLOCK_SIZE) && (ctx->cip_alg != NSS_CRYPTO_CIPHER_AES_CTR)) {
++	if (nss_cryptoapi_check_unalign(req->cryptlen, AES_BLOCK_SIZE) && (ctx->cip_alg != NSS_CRYPTO_CIPHER_AES_CTR)) {
+ 		nss_cfi_err("Invalid cipher len - Not aligned to algo blocksize\n");
+-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
++		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -571,13 +571,13 @@ int nss_cryptoapi_ablk_aes_encrypt(struct ablkcipher_request *req)
+  * nss_cryptoapi_ablk_aes_decrypt()
+  * 	Crytoapi decrypt for aes(aes-cbc/rfc3686-aes-ctr) algorithms.
+  */
+-int nss_cryptoapi_ablk_aes_decrypt(struct ablkcipher_request *req)
++int nss_cryptoapi_ablk_aes_decrypt(struct skcipher_request *req)
+ {
+ 	struct nss_crypto_params params = { .req_type = NSS_CRYPTO_REQ_TYPE_DECRYPT };
+-	struct nss_cryptoapi_ablk_info info = {.cb_fn = nss_cryptoapi_ablkcipher_done,
++	struct nss_cryptoapi_ablk_info info = {.cb_fn = nss_cryptoapi_skcipher_done,
+ 						.params = &params};
+-	struct crypto_ablkcipher *cipher = crypto_ablkcipher_reqtfm(req);
+-	struct nss_cryptoapi_ctx *ctx = crypto_ablkcipher_ctx(cipher);
++	struct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);
++	struct nss_cryptoapi_ctx *ctx = crypto_skcipher_ctx(cipher);
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+ 	struct nss_crypto_buf *buf;
+ 
+@@ -587,7 +587,7 @@ int nss_cryptoapi_ablk_aes_decrypt(struct ablkcipher_request *req)
+ 	nss_cryptoapi_verify_magic(ctx);
+ 
+ 	if (ctx->fallback_req)
+-		return nss_cryptoapi_ablkcipher_fallback(ctx, req, NSS_CRYPTOAPI_DECRYPT);
++		return nss_cryptoapi_skcipher_fallback(ctx, req, NSS_CRYPTOAPI_DECRYPT);
+ 
+ 	/*
+ 	 * Check if previous call to setkey couldn't allocate session with core crypto.
+@@ -606,9 +606,9 @@ int nss_cryptoapi_ablk_aes_decrypt(struct ablkcipher_request *req)
+ 	 * According to RFC3686, AES-CTR algo need not be padded if the
+ 	 * plaintext or ciphertext is unaligned to block size boundary.
+ 	 */
+-	if (nss_cryptoapi_check_unalign(req->nbytes, AES_BLOCK_SIZE) && (ctx->cip_alg != NSS_CRYPTO_CIPHER_AES_CTR)) {
++	if (nss_cryptoapi_check_unalign(req->cryptlen, AES_BLOCK_SIZE) && (ctx->cip_alg != NSS_CRYPTO_CIPHER_AES_CTR)) {
+ 		nss_cfi_err("Invalid cipher len - Not aligned to algo blocksize\n");
+-		crypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
++		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -638,9 +638,9 @@ int nss_cryptoapi_ablk_aes_decrypt(struct ablkcipher_request *req)
+  * nss_cryptoapi_3des_cbc_setkey()
+  * 	Cryptoapi DES3 CBC setkey function.
+  */
+-int nss_cryptoapi_3des_cbc_setkey(struct crypto_ablkcipher *cipher, const u8 *key, unsigned int keylen)
++int nss_cryptoapi_3des_cbc_setkey(struct crypto_skcipher *cipher, const u8 *key, unsigned int keylen)
+ {
+-	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);
++	struct crypto_tfm *tfm = crypto_skcipher_tfm(cipher);
+ 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(tfm);
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+ 	struct nss_crypto_key cip = { .algo = NSS_CRYPTO_CIPHER_DES };
+@@ -693,7 +693,7 @@ int nss_cryptoapi_3des_cbc_setkey(struct crypto_ablkcipher *cipher, const u8 *ke
+ 	return 0;
+ 
+ fail:
+-	crypto_ablkcipher_set_flags(cipher, flag);
++	crypto_skcipher_set_flags(cipher, flag);
+ 	return -EINVAL;
+ }
+ 
+@@ -701,7 +701,7 @@ fail:
+  * nss_cryptoapi_3des_cbc_encrypt()
+  * 	Cryptoapi DES3 CBC encrypt function.
+  */
+-int nss_cryptoapi_3des_cbc_encrypt(struct ablkcipher_request *req)
++int nss_cryptoapi_3des_cbc_encrypt(struct skcipher_request *req)
+ {
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+ 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+@@ -727,14 +727,14 @@ int nss_cryptoapi_3des_cbc_encrypt(struct ablkcipher_request *req)
+ 		return -EINVAL;
+ 	}
+ 
+-	if (nss_cryptoapi_check_unalign(req->nbytes, DES3_EDE_BLOCK_SIZE)) {
++	if (nss_cryptoapi_check_unalign(req->cryptlen, DES3_EDE_BLOCK_SIZE)) {
+ 		nss_cfi_err("Invalid cipher len - Not aligned to algo blocksize\n");
+-		crypto_ablkcipher_set_flags(crypto_ablkcipher_reqtfm(req), CRYPTO_TFM_RES_BAD_BLOCK_LEN);
++		crypto_skcipher_set_flags(crypto_skcipher_reqtfm(req), CRYPTO_TFM_RES_BAD_BLOCK_LEN);
+ 		return -EINVAL;
+ 	}
+ 
+ 	info.params = &params;
+-	info.cb_fn = nss_cryptoapi_ablkcipher_done;
++	info.cb_fn = nss_cryptoapi_skcipher_done;
+ 
+ 	buf = nss_cryptoapi_ablk_transform(req, &info);
+ 	if (!buf) {
+@@ -762,7 +762,7 @@ int nss_cryptoapi_3des_cbc_encrypt(struct ablkcipher_request *req)
+  * nss_cryptoapi_3des_cbc_decrypt()
+  * 	Cryptoapi DES3 CBC decrypt function.
+  */
+-int nss_cryptoapi_3des_cbc_decrypt(struct ablkcipher_request *req)
++int nss_cryptoapi_3des_cbc_decrypt(struct skcipher_request *req)
+ {
+ 	struct nss_cryptoapi *sc = &gbl_ctx;
+ 	struct nss_cryptoapi_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+@@ -788,14 +788,14 @@ int nss_cryptoapi_3des_cbc_decrypt(struct ablkcipher_request *req)
+ 		return -EINVAL;
+ 	}
+ 
+-	if (nss_cryptoapi_check_unalign(req->nbytes, DES3_EDE_BLOCK_SIZE)) {
++	if (nss_cryptoapi_check_unalign(req->cryptlen, DES3_EDE_BLOCK_SIZE)) {
+ 		nss_cfi_err("Invalid cipher len - Not aligned to algo blocksize\n");
+-		crypto_ablkcipher_set_flags(crypto_ablkcipher_reqtfm(req), CRYPTO_TFM_RES_BAD_BLOCK_LEN);
++		crypto_skcipher_set_flags(crypto_skcipher_reqtfm(req), CRYPTO_TFM_RES_BAD_BLOCK_LEN);
+ 		return -EINVAL;
+ 	}
+ 
+ 	info.params = &params;
+-	info.cb_fn = nss_cryptoapi_ablkcipher_done;
++	info.cb_fn = nss_cryptoapi_skcipher_done;
+ 
+ 	buf = nss_cryptoapi_ablk_transform(req, &info);
+ 	if (!buf) {
+diff --git a/cryptoapi/v1.1/nss_cryptoapi_debugfs.c b/cryptoapi/v1.1/nss_cryptoapi_debugfs.c
+index dff774c..cf4bc70 100644
+--- a/cryptoapi/v1.1/nss_cryptoapi_debugfs.c
++++ b/cryptoapi/v1.1/nss_cryptoapi_debugfs.c
+@@ -55,6 +55,7 @@
+  */
+ void nss_cryptoapi_debugfs_add_stats(struct dentry *parent, struct nss_cryptoapi_ctx *session_ctx)
+ {
++	pr_info("add stats");
+ 	debugfs_create_u64("queued", S_IRUGO, parent, &session_ctx->queued);
+ 	debugfs_create_u64("completed", S_IRUGO, parent, &session_ctx->completed);
+ 	debugfs_create_u64("queue_failed", S_IRUGO, parent, &session_ctx->queue_failed);
+diff --git a/cryptoapi/v1.1/nss_cryptoapi_private.h b/cryptoapi/v1.1/nss_cryptoapi_private.h
+index 5feb9e3..70c6714 100644
+--- a/cryptoapi/v1.1/nss_cryptoapi_private.h
++++ b/cryptoapi/v1.1/nss_cryptoapi_private.h
+@@ -141,16 +141,16 @@ int nss_cryptoapi_sha256_3des_encrypt(struct aead_request *req);
+ int nss_cryptoapi_sha256_3des_decrypt(struct aead_request *req);
+ 
+ /* ABLKCIPHER */
+-int nss_cryptoapi_ablkcipher_init(struct crypto_tfm *tfm);
+-void nss_cryptoapi_ablkcipher_exit(struct crypto_tfm *tfm);
+-int nss_cryptoapi_ablk_aes_setkey(struct crypto_ablkcipher *cipher, const u8 *key, unsigned int len);
+-int nss_cryptoapi_3des_cbc_setkey(struct crypto_ablkcipher *cipher, const u8 *key, unsigned int len);
++int nss_cryptoapi_skcipher_init(struct crypto_skcipher *tfm);
++void nss_cryptoapi_skcipher_exit(struct crypto_skcipher *tfm);
++int nss_cryptoapi_ablk_aes_setkey(struct crypto_skcipher *cipher, const u8 *key, unsigned int len);
++int nss_cryptoapi_3des_cbc_setkey(struct crypto_skcipher *cipher, const u8 *key, unsigned int len);
+ 
+-int nss_cryptoapi_ablk_aes_encrypt(struct ablkcipher_request *req);
+-int nss_cryptoapi_ablk_aes_decrypt(struct ablkcipher_request *req);
++int nss_cryptoapi_ablk_aes_encrypt(struct skcipher_request *req);
++int nss_cryptoapi_ablk_aes_decrypt(struct skcipher_request *req);
+ 
+-int nss_cryptoapi_3des_cbc_encrypt(struct ablkcipher_request *req);
+-int nss_cryptoapi_3des_cbc_decrypt(struct ablkcipher_request *req);
++int nss_cryptoapi_3des_cbc_encrypt(struct skcipher_request *req);
++int nss_cryptoapi_3des_cbc_decrypt(struct skcipher_request *req);
+ 
+ #endif /* __NSS_CRYPTOAPI_PRIVATE_H */
+ 
+-- 
+2.27.0.rc0
+
diff --git a/package/qca/qca-nss-clients/Makefile b/package/qca/qca-nss-clients/Makefile
new file mode 100644
index 0000000000..5099c5521d
--- /dev/null
+++ b/package/qca/qca-nss-clients/Makefile
@@ -0,0 +1,468 @@
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=qca-nss-clients
+PKG_RELEASE:=2
+
+PKG_SOURCE_URL:=https://source.codeaurora.org/quic/qsdk/oss/lklm/nss-clients
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_VERSION:=740d0102c518cd49f30c5580982b218b480006b1
+
+include $(INCLUDE_DIR)/package.mk
+
+# Keep default as ipq806x for branches that does not have subtarget framework
+ifeq ($(CONFIG_TARGET_ipq),y)
+subtarget:=$(SUBTARGET)
+else
+subtarget:=$(CONFIG_TARGET_BOARD)
+endif
+
+ifneq (, $(findstring $(subtarget), "ipq807x" "ipq807x_64" "ipq60xx" "ipq60xx_64"))
+# DTLS Manager v2.0 for Hawkeye/Cypress
+  DTLSMGR_DIR:=v2.0
+# IPsec Manager v2.0 for Hawkeye/Cypress
+  IPSECMGR_DIR:=v2.0
+# KLIPS plugin
+  IPSECMGR_KLIPS:= $(PKG_BUILD_DIR)/ipsecmgr/$(IPSECMGR_DIR)/plugins/klips/qca-nss-ipsec-klips.ko
+else
+# DTLS Manager v1.0 for Akronite.
+  DTLSMGR_DIR:=v1.0
+# IPsec Manager v1.0 for Akronite.
+  IPSECMGR_DIR:=v1.0
+# KLIPS plugin not needed
+  IPSECMGR_KLIPS:=
+endif
+
+define KernelPackage/qca-nss-drv-tun6rd
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (connection manager) - tun6rd
+  DEPENDS:=+kmod-qca-nss-drv +kmod-sit +6rd @!LINUX_3_18
+  FILES:=$(PKG_BUILD_DIR)/qca-nss-tun6rd.ko
+  AUTOLOAD:=$(call AutoLoad,60,qca-nss-tun6rd)
+endef
+
+define KernelPackage/qca-nss-drv-tun6rd/Description
+Kernel modules for NSS connection manager - Support for 6rd tunnel
+endef
+
+define KernelPackage/qca-nss-drv-dtlsmgr
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (connection manager) - dtlsmgr
+  DEPENDS:=+kmod-qca-nss-drv +kmod-qca-nss-cfi-cryptoapi @!LINUX_3_18
+  FILES:=$(PKG_BUILD_DIR)/dtls/$(DTLSMGR_DIR)/qca-nss-dtlsmgr.ko
+endef
+
+define KernelPackage/qca-nss-drv-dtls/Description
+Kernel modules for NSS connection manager - Support for DTLS sessions
+endef
+
+define KernelPackage/qca-nss-drv-l2tpv2
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (connection manager) - l2tp
+  DEPENDS:=+kmod-qca-nss-drv +kmod-ppp +kmod-l2tp @!LINUX_3_18
+  FILES:=$(PKG_BUILD_DIR)/l2tp/l2tpv2/qca-nss-l2tpv2.ko
+  KCONFIG:=CONFIG_L2TP=y
+  AUTOLOAD:=$(call AutoLoad,51,qca-nss-l2tpv2)
+endef
+
+define KernelPackage/qca-nss-drv-l2tp/Description
+Kernel modules for NSS connection manager - Support for l2tp tunnel
+endef
+
+define KernelPackage/qca-nss-drv-pptp
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (connection manager) - PPTP
+  DEPENDS:=+kmod-qca-nss-drv +kmod-pptp @!LINUX_3_18
+  FILES:=$(PKG_BUILD_DIR)/pptp/qca-nss-pptp.ko
+  AUTOLOAD:=$(call AutoLoad,51,qca-nss-pptp)
+endef
+
+define KernelPackage/qca-nss-drv-pptp/Description
+Kernel modules for NSS connection manager - Support for PPTP tunnel
+endef
+
+define KernelPackage/qca-nss-drv-pppoe
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (connection manager) - PPPoE
+  DEPENDS:=+kmod-qca-nss-drv +kmod-pppoe @!LINUX_3_18 \
+		+!(TARGET_ipq_ipq807x_QSDK_256||TARGET_ipq_ipq60xx_QSDK_256):kmod-bonding
+  FILES:=$(PKG_BUILD_DIR)/pppoe/qca-nss-pppoe.ko
+  AUTOLOAD:=$(call AutoLoad,51,qca-nss-pppoe)
+endef
+
+define KernelPackage/qca-nss-drv-pppoe/Description
+Kernel modules for NSS connection manager - Support for PPPoE
+endef
+
+define KernelPackage/qca-nss-drv-map-t
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (connection manager) - MAP-T
+  DEPENDS:=+kmod-qca-nss-drv +kmod-nat46 @!LINUX_3_18
+  FILES:=$(PKG_BUILD_DIR)/map/map-t/qca-nss-map-t.ko
+  AUTOLOAD:=$(call AutoLoad,51,qca-nss-map-t)
+endef
+
+define KernelPackage/qca-nss-drv-map-t/Description
+Kernel modules for NSS connection manager - Support for MAP-T
+endef
+
+define KernelPackage/qca-nss-drv-gre
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (connection manager) - GRE
+  DEPENDS:=@TARGET_ipq_ipq806x||TARGET_ipq806x||TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq807x||TARGET_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64||TARGET_ipq_ipq50xx||TARGET_ipq_ipq50xx_64 \
+	   +kmod-qca-nss-drv @!LINUX_3_18 +kmod-gre6
+  FILES:=$(PKG_BUILD_DIR)/gre/qca-nss-gre.ko $(PKG_BUILD_DIR)/gre/test/qca-nss-gre-test.ko
+  AUTOLOAD:=$(call AutoLoad,51,qca-nss-gre)
+endef
+
+define KernelPackage/qca-nss-drv-gre/Description
+Kernel modules for NSS connection manager - Support for GRE
+endef
+
+define KernelPackage/qca-nss-drv-tunipip6
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (connection manager) - DS-lite and ipip6 Tunnel
+  DEPENDS:=+kmod-qca-nss-drv +kmod-iptunnel6 +kmod-ip6-tunnel @!LINUX_3_18
+  FILES:=$(PKG_BUILD_DIR)/qca-nss-tunipip6.ko
+  AUTOLOAD:=$(call AutoLoad,60,qca-nss-tunipip6)
+endef
+
+define KernelPackage/qca-nss-drv-tunipip6/Description
+Kernel modules for NSS connection manager
+Add support for DS-lite and ipip6 tunnel
+endef
+
+define KernelPackage/qca-nss-drv-profile
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  DEPENDS:=+kmod-qca-nss-drv @!LINUX_3_18
+  TITLE:=Profiler for QCA NSS driver (IPQ806x)
+  FILES:=$(PKG_BUILD_DIR)/profiler/qca-nss-profile-drv.ko
+endef
+
+define KernelPackage/qca-nss-drv-profile/Description
+This package contains a NSS driver profiler for QCA chipset
+endef
+
+define KernelPackage/qca-nss-drv-ipsecmgr
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS (ipsec manager) - ipsecmgr
+  DEPENDS:=@TARGET_ipq806x||TARGET_ipq_ipq806x||TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq807x||TARGET_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64 \
+		+kmod-qca-nss-drv +kmod-qca-nss-ecm-standard +kmod-qca-nss-cfi-cryptoapi @!LINUX_3_18
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-l2tpv2),)
+  DEPENDS+=+kmod-qca-nss-drv-l2tpv2
+endif
+  FILES:=$(PKG_BUILD_DIR)/ipsecmgr/$(IPSECMGR_DIR)/qca-nss-ipsecmgr.ko	$(IPSECMGR_KLIPS)
+  AUTOLOAD:=$(call AutoLoad,60,qca-nss-ipsecmgr)
+endef
+
+define KernelPackage/qca-nss-drv-ipsecmgr/Description
+Kernel module for NSS IPsec offload manager
+endef
+
+define KernelPackage/qca-nss-drv-capwapmgr
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  DEPENDS:=+kmod-qca-nss-drv +kmod-qca-nss-drv-dtlsmgr @!LINUX_3_18
+  TITLE:=NSS CAPWAP Manager for QCA NSS driver (IPQ806x)
+  FILES:=$(PKG_BUILD_DIR)/capwapmgr/qca-nss-capwapmgr.ko
+endef
+
+define KernelPackage/qca-nss-drv-capwapmgr/Description
+This package contains a NSS CAPWAP Manager
+endef
+
+define KernelPackage/qca-nss-drv-bridge-mgr
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS bridge manager
+  DEPENDS:=@TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq807x||TARGET_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64 \
+		+TARGET_ipq_ipq807x:kmod-qca-nss-drv-vlan-mgr \
+		+TARGET_ipq_ipq807x_64:kmod-qca-nss-drv-vlan-mgr \
+		+TARGET_ipq807x:kmod-qca-nss-drv-vlan-mgr \
+		+TARGET_ipq807x_64:kmod-qca-nss-drv-vlan-mgr \
+		+TARGET_ipq_ipq60xx:kmod-qca-nss-drv-vlan-mgr \
+		+TARGET_ipq_ipq60xx_64:kmod-qca-nss-drv-vlan-mgr @!LINUX_3_18 \
+		+!(TARGET_ipq_ipq807x_QSDK_256||TARGET_ipq_ipq60xx_QSDK_256):kmod-bonding
+  FILES:=$(PKG_BUILD_DIR)/bridge/qca-nss-bridge-mgr.ko
+  AUTOLOAD:=$(call AutoLoad,51,qca-nss-bridge-mgr)
+endef
+
+define KernelPackage/qca-nss-drv-bridge-mgr/Description
+Kernel modules for NSS bridge manager
+endef
+
+define KernelPackage/qca-nss-drv-vlan-mgr
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS vlan manager
+  DEPENDS:=@TARGET_ipq806x||TARGET_ipq807x +kmod-qca-nss-drv @!LINUX_3_18 \
+		+!(TARGET_ipq_ipq807x_QSDK_256||TARGET_ipq_ipq60xx_QSDK_256):kmod-bonding
+  FILES:=$(PKG_BUILD_DIR)/vlan/qca-nss-vlan.ko
+  AUTOLOAD:=$(call AutoLoad,51,qca-nss-vlan)
+endef
+
+define KernelPackage/qca-nss-drv-vlan-mgr/Description
+Kernel modules for NSS vlan manager
+endef
+
+define KernelPackage/qca-nss-drv-qdisc
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Support
+  TITLE:=Qdisc for configuring shapers in NSS
+  DEPENDS:=+kmod-qca-nss-drv @!LINUX_3_18
+  FILES:=$(PKG_BUILD_DIR)/nss_qdisc/qca-nss-qdisc.ko
+  KCONFIG:=CONFIG_NET_CLS_ACT=y
+  AUTOLOAD:=$(call AutoLoad,58,qca-nss-qdisc)
+endef
+
+define KernelPackage/qca-nss-drv-qdisc/Description
+Linux qdisc that aids in configuring shapers in the NSS
+endef
+
+define KernelPackage/qca-nss-drv-lag-mgr
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS LAG manager
+  DEPENDS:=+kmod-qca-nss-drv  @!LINUX_3_18 \
+	   +TARGET_ipq_ipq807x:kmod-qca-nss-drv-vlan-mgr \
+	   +TARGET_ipq_ipq807x_64:kmod-qca-nss-drv-vlan-mgr @!LINUX_3_18 \
+	   +TARGET_ipq807x:kmod-qca-nss-drv-vlan-mgr \
+	   +TARGET_ipq807x_64:kmod-qca-nss-drv-vlan-mgr @!LINUX_3_18 \
+	   +TARGET_ipq_ipq60xx:kmod-qca-nss-drv-vlan-mgr @!LINUX_3_18 \
+	   +TARGET_ipq_ipq60xx_64:kmod-qca-nss-drv-vlan-mgr @!LINUX_3_18 \
+	   +kmod-bonding
+  FILES:=$(PKG_BUILD_DIR)/lag/qca-nss-lag-mgr.ko
+  AUTOLOAD:=$(call AutoLoad,51,qca-nss-lag-mgr)
+endef
+
+define KernelPackage/qca-nss-drv-lag-mgr/Description
+Kernel modules for NSS LAG manager
+endef
+
+define KernelPackage/qca-nss-drv-netlink
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  DEPENDS:=@TARGET_ipq807x||TARGET_ipq_ipq807x||TARGET_ipq807x_64||TARGET_ipq_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64||TARGET_ipq_ipq50xx||TARGET_ipq_ipq50xx_64 \
+		+kmod-qca-nss-drv @!LINUX_3_18 \
+		+PACKAGE_kmod-qca-nss-drv-ipsecmgr:kmod-qca-nss-drv-ipsecmgr \
+		+PACKAGE_kmod-qca-nss-drv-dtlsmgr:kmod-qca-nss-drv-dtlsmgr \
+		+PACKAGE_kmod-qca-nss-drv-capwapmgr:kmod-qca-nss-drv-capwapmgr @!LINUX_3_18
+  TITLE:=NSS NETLINK Manager for QCA NSS driver
+  FILES:=$(PKG_BUILD_DIR)/netlink/qca-nss-netlink.ko
+endef
+
+define KernelPackage/qca-nss-drv-netlink/Description
+Kernel module for NSS netlink manager
+endef
+
+define KernelPackage/qca-nss-drv-ovpn-mgr
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for NSS OpenVPN manager
+  DEPENDS:=+kmod-qca-nss-drv +kmod-qca-nss-cfi-cryptoapi +kmod-tun +kmod-ipt-conntrack @!LINUX_3_18 \
+	  @TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64
+  FILES:=$(PKG_BUILD_DIR)/openvpn/src/qca-nss-ovpn-mgr.ko
+endef
+
+define KernelPackage/qca-nss-drv-ovpn-mgr/Description
+Kernel module for NSS OpenVPN manager
+endef
+
+define KernelPackage/qca-nss-drv-ovpn-link
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  TITLE:=Kernel driver for interfacing NSS OpenVPN manager with ECM
+  DEPENDS:=+kmod-qca-nss-drv-ovpn-mgr +@PACKAGE_kmod-qca-nss-ecm-premium @!LINUX_3_18 \
+	  @TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64
+  FILES:=$(PKG_BUILD_DIR)/openvpn/plugins/qca-nss-ovpn-link.ko
+endef
+
+define KernelPackage/qca-nss-drv-ovpn-link/Description
+This module registers with ECM and communicates with NSS OpenVPN manager for supporting OpenVPN offload.
+endef
+
+define KernelPackage/qca-nss-drv-pvxlanmgr
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  DEPENDS:=+kmod-qca-nss-drv @!LINUX_3_18
+  TITLE:=NSS PVXLAN Manager for QCA NSS driver
+  FILES:=$(PKG_BUILD_DIR)/pvxlanmgr/qca-nss-pvxlanmgr.ko
+endef
+
+define KernelPackage/qca-nss-drv-pvxlanmgr/Description
+Kernel module for managing NSS PVxLAN
+endef
+
+define Build/InstallDev/qca-nss-clients
+	$(INSTALL_DIR) $(1)/usr/include/qca-nss-clients
+	$(CP) $(PKG_BUILD_DIR)/netlink/include/* $(1)/usr/include/qca-nss-clients/
+	$(CP) $(PKG_BUILD_DIR)/exports/* $(1)/usr/include/qca-nss-clients/
+endef
+
+define Build/InstallDev
+	$(call Build/InstallDev/qca-nss-clients,$(1))
+endef
+
+define KernelPackage/qca-nss-drv-ovpn-mgr/install
+	$(INSTALL_DIR) $(1)/etc/init.d
+	$(INSTALL_BIN) ./files/qca-nss-ovpn.init $(1)/etc/init.d/qca-nss-ovpn
+endef
+
+define KernelPackage/qca-nss-drv-ipsecmgr/install
+	$(INSTALL_DIR) $(1)/etc/init.d
+	$(INSTALL_BIN) ./files/qca-nss-ipsec $(1)/etc/init.d/qca-nss-ipsec
+endef
+
+
+EXTRA_CFLAGS+= \
+	-I$(STAGING_DIR)/usr/include/qca-nss-drv \
+	-I$(STAGING_DIR)/usr/include/qca-nss-crypto \
+	-I$(STAGING_DIR)/usr/include/qca-nss-cfi \
+	-I$(STAGING_DIR)/usr/include/qca-nss-gmac \
+	-I$(STAGING_DIR)/usr/include/qca-nss-ecm \
+	-I$(STAGING_DIR)/usr/include/qca-ssdk \
+	-I$(STAGING_DIR)/usr/include/qca-ssdk/fal \
+	-I$(STAGING_DIR)/usr/include/nat46
+
+# Build individual packages if selected
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-profile),)
+MAKE_OPTS+=profile=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-capwapmgr),)
+MAKE_OPTS+=capwapmgr=y
+EXTRA_CFLAGS += -DNSS_CAPWAPMGR_ONE_NETDEV
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-tun6rd),)
+MAKE_OPTS+=tun6rd=m
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-dtlsmgr),)
+MAKE_OPTS+=dtlsmgr=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-l2tpv2),)
+MAKE_OPTS+=l2tpv2=y
+EXTRA_CFLAGS += -DNSS_L2TPV2_ENABLED
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-pptp),)
+MAKE_OPTS+=pptp=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-map-t),)
+MAKE_OPTS+=map-t=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-tunipip6),)
+MAKE_OPTS+=tunipip6=m
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-qdisc),)
+MAKE_OPTS+=qdisc=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-ipsecmgr),)
+EXTRA_CFLAGS+= -I$(PKG_BUILD_DIR)/exports \
+		-I$(STAGING_DIR)/usr/include/qca-nss-ecm
+MAKE_OPTS+=ipsecmgr=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-bridge-mgr),)
+MAKE_OPTS+=bridge-mgr=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-vlan-mgr),)
+MAKE_OPTS+=vlan-mgr=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-lag-mgr),)
+MAKE_OPTS+=lag-mgr=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-gre),)
+EXTRA_CFLAGS+= -I$(PKG_BUILD_DIR)/exports
+MAKE_OPTS+=gre=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-pppoe),)
+MAKE_OPTS+=pppoe=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-netlink),)
+MAKE_OPTS+=netlink=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-ovpn-mgr),)
+MAKE_OPTS+=ovpn-mgr=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-ovpn-link),)
+MAKE_OPTS+=ovpn-link=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-pvxlanmgr),)
+MAKE_OPTS+=pvxlanmgr=y
+endif
+
+define Build/Compile
+	$(MAKE) $(PKG_JOBS) -C "$(LINUX_DIR)" $(strip $(MAKE_OPTS)) \
+		$(KERNEL_MAKE_FLAGS) \
+		$(PKG_MAKE_FLAGS) \
+		M="$(PKG_BUILD_DIR)" \
+		EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
+		SoC="$(subtarget)" \
+		DTLSMGR_DIR="$(DTLSMGR_DIR)" \
+		IPSECMGR_DIR="$(IPSECMGR_DIR)" \
+		modules
+endef
+
+$(eval $(call KernelPackage,qca-nss-drv-profile))
+$(eval $(call KernelPackage,qca-nss-drv-capwapmgr))
+$(eval $(call KernelPackage,qca-nss-drv-tun6rd))
+$(eval $(call KernelPackage,qca-nss-drv-dtlsmgr))
+$(eval $(call KernelPackage,qca-nss-drv-l2tpv2))
+$(eval $(call KernelPackage,qca-nss-drv-pptp))
+$(eval $(call KernelPackage,qca-nss-drv-pppoe))
+$(eval $(call KernelPackage,qca-nss-drv-map-t))
+$(eval $(call KernelPackage,qca-nss-drv-tunipip6))
+$(eval $(call KernelPackage,qca-nss-drv-qdisc))
+$(eval $(call KernelPackage,qca-nss-drv-netlink))
+$(eval $(call KernelPackage,qca-nss-drv-ipsecmgr))
+$(eval $(call KernelPackage,qca-nss-drv-bridge-mgr))
+$(eval $(call KernelPackage,qca-nss-drv-vlan-mgr))
+$(eval $(call KernelPackage,qca-nss-drv-lag-mgr))
+$(eval $(call KernelPackage,qca-nss-drv-gre))
+$(eval $(call KernelPackage,qca-nss-drv-ovpn-mgr))
+$(eval $(call KernelPackage,qca-nss-drv-ovpn-link))
+$(eval $(call KernelPackage,qca-nss-drv-pvxlanmgr))
diff --git a/package/qca/qca-nss-clients/files/qca-nss-ipsec b/package/qca/qca-nss-clients/files/qca-nss-ipsec
new file mode 100644
index 0000000000..bb202e8e7e
--- /dev/null
+++ b/package/qca/qca-nss-clients/files/qca-nss-ipsec
@@ -0,0 +1,92 @@
+#!/bin/sh  /etc/rc.common
+#
+# Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+NSS_IPSEC_LOG_FILE=/tmp/.nss_ipsec_log
+NSS_IPSEC_LOG_STR_ECM="ECM_Loaded"
+
+ecm_load () {
+	if [ ! -d /sys/module/ecm ]; then
+		/etc/init.d/qca-nss-ecm start
+		if [ -d /sys/module/ecm ]; then
+			echo ${NSS_IPSEC_LOG_STR_ECM} >> ${NSS_IPSEC_LOG_FILE}
+		fi
+	fi
+}
+
+ecm_unload () {
+	if [ -f /tmp/.nss_ipsec_log ]; then
+		str=`grep ${NSS_IPSEC_LOG_STR_ECM} ${NSS_IPSEC_LOG_FILE}`
+		if [[ $str == ${NSS_IPSEC_LOG_STR_ECM} ]]; then
+			/etc/init.d/qca-nss-ecm stop
+			`sed 's/${NSS_IPSEC_LOG_STR_ECM}/ /g' $NSS_IPSEC_LOG_FILE >  $NSS_IPSEC_LOG_FILE`
+		fi
+	fi
+}
+
+ecm_disable() {
+
+	if [ ! -d /sys/module/ecm ]; then
+		return;
+	fi
+
+	echo 1 > /sys/kernel/debug/ecm/front_end_ipv4_stop
+	echo 1 > /sys/kernel/debug/ecm/front_end_ipv6_stop
+	echo 1 > /sys/kernel/debug/ecm/ecm_db/defunct_all
+	sleep 2
+}
+
+ecm_enable() {
+	if [ ! -d /sys/module/ecm ]; then
+		return;
+	fi
+
+	echo 0 > /sys/kernel/debug/ecm/ecm_db/defunct_all
+	echo 0 > /sys/kernel/debug/ecm/front_end_ipv4_stop
+	echo 0 > /sys/kernel/debug/ecm/front_end_ipv6_stop
+}
+
+start() {
+	ecm_load
+
+	local kernel_version=$(uname -r)
+
+	insmod /lib/modules/${kernel_version}/qca-nss-ipsec-klips.ko
+	if [ "$?" -gt 0 ]; then
+		echo "Failed to load plugin. Please start ecm if not done already"
+		ecm_enable
+		return
+	fi
+
+	/etc/init.d/ipsec start
+	sleep 2
+	ipsec eroute
+
+	ecm_enable
+}
+
+stop() {
+	ecm_disable
+
+	/etc/init.d/ipsec stop
+	rmmod qca-nss-ipsec-klips
+
+	ecm_unload
+}
+
+restart() {
+	stop
+	start
+}
diff --git a/package/qca/qca-nss-clients/files/qca-nss-mirred.init b/package/qca/qca-nss-clients/files/qca-nss-mirred.init
new file mode 100644
index 0000000000..1f931f0903
--- /dev/null
+++ b/package/qca/qca-nss-clients/files/qca-nss-mirred.init
@@ -0,0 +1,28 @@
+#!/bin/sh /etc/rc.common
+
+###########################################################################
+# Copyright (c) 2019, The Linux Foundation. All rights reserved.
+# Permission to use, copy, modify, and/or distribute this software for
+# any purpose with or without fee is hereby granted, provided that the
+# above copyright notice and this permission notice appear in all copies.
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+###########################################################################
+
+restart() {
+	rmmod act_nssmirred.ko
+	insmod act_nssmirred.ko
+}
+
+start() {
+	insmod act_nssmirred.ko
+}
+
+stop() {
+	rmmod act_nssmirred.ko
+}
diff --git a/package/qca/qca-nss-clients/files/qca-nss-ovpn.init b/package/qca/qca-nss-clients/files/qca-nss-ovpn.init
new file mode 100644
index 0000000000..622e295eee
--- /dev/null
+++ b/package/qca/qca-nss-clients/files/qca-nss-ovpn.init
@@ -0,0 +1,69 @@
+#!/bin/sh /etc/rc.common
+
+###########################################################################
+# Copyright (c) 2019, The Linux Foundation. All rights reserved.
+# Permission to use, copy, modify, and/or distribute this software for
+# any purpose with or without fee is hereby granted, provided that the
+# above copyright notice and this permission notice appear in all copies.
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+###########################################################################
+
+ecm_disable() {
+	if [ ! -d /sys/module/ecm ]; then
+	   return
+	fi
+
+	echo 1 > /sys/kernel/debug/ecm/front_end_ipv4_stop
+	echo 1 > /sys/kernel/debug/ecm/front_end_ipv6_stop
+	echo 1 > /sys/kernel/debug/ecm/ecm_db/defunct_all
+	sleep 2
+}
+
+ecm_enable() {
+	if [ ! -d /sys/module/ecm ]; then
+	   return
+	fi
+
+	echo 0 > /sys/kernel/debug/ecm/ecm_db/defunct_all
+	echo 0 > /sys/kernel/debug/ecm/front_end_ipv4_stop
+	echo 0 > /sys/kernel/debug/ecm/front_end_ipv6_stop
+}
+
+restart() {
+	ecm_disable
+
+	/etc/init.d/openvpn stop
+	rmmod qca-nss-ovpn-link
+	rmmod qca-nss-ovpn-mgr
+
+	insmod qca-nss-ovpn-mgr
+	insmod qca-nss-ovpn-link
+
+	if [ "$?" -gt 0 ]; then
+		echo "Failed to load plugin. Please start ecm if not done already"
+		ecm_enable
+		return
+	fi
+
+	ecm_enable
+}
+
+start() {
+	restart
+}
+
+stop() {
+	ecm_disable
+
+	/etc/init.d/openvpn stop
+	rmmod qca-nss-ovpn-link
+	rmmod qca-nss-ovpn-mgr
+
+	ecm_enable
+}
diff --git a/package/qca/qca-nss-clients/patches/100-kernel-5.4-support-qdisc.patch b/package/qca/qca-nss-clients/patches/100-kernel-5.4-support-qdisc.patch
new file mode 100644
index 0000000000..0ec8d766ec
--- /dev/null
+++ b/package/qca/qca-nss-clients/patches/100-kernel-5.4-support-qdisc.patch
@@ -0,0 +1,1145 @@
+--- a/nss_qdisc/nss_qdisc.h
++++ b/nss_qdisc/nss_qdisc.h
+@@ -338,7 +340,7 @@ extern void nss_qdisc_destroy(struct nss
+  *	Initializes a shaper in NSS, based on the position of this qdisc (child or root)
+  *	and if its a normal interface or a bridge interface.
+  */
+-extern int nss_qdisc_init(struct Qdisc *sch, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode);
++extern int nss_qdisc_init(struct Qdisc *sch, struct netlink_ext_ack *extack, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode);
+ 
+ /*
+  * nss_qdisc_start_basic_stats_polling()
+--- a/nss_qdisc/nss_bf.c
++++ b/nss_qdisc/nss_bf.c
+@@ -69,7 +69,7 @@ static inline struct nss_bf_class_data *
+  *	Configures a new class.
+  */
+ static int nss_bf_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
+-		  struct nlattr **tca, unsigned long *arg)
++		  struct nlattr **tca, unsigned long *arg, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_bf_sched_data *q = qdisc_priv(sch);
+ 	struct nss_bf_class_data *cl = (struct nss_bf_class_data *)*arg;
+@@ -121,7 +121,7 @@ static int nss_bf_change_class(struct Qd
+ 		 * that is registered to Linux. Therefore we initialize the NSSBF_GROUP shaper
+ 		 * here.
+ 		 */
+-		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_BF_GROUP, classid, accel_mode) < 0) {
++		if (nss_qdisc_init(sch, extack, &cl->nq, NSS_SHAPER_NODE_TYPE_BF_GROUP, classid, accel_mode) < 0) {
+ 			nss_qdisc_error("Nss init for class %u failed\n", classid);
+ 			kfree(cl);
+ 			return -EINVAL;
+@@ -260,7 +260,7 @@ static void nss_bf_destroy_class(struct
+ 	/*
+ 	 * And now we destroy the child.
+ 	 */
+-	qdisc_destroy(cl->qdisc);
++	qdisc_put(cl->qdisc);
+ 
+ 	/*
+ 	 * Stop the stats polling timer and free class
+@@ -325,7 +325,7 @@ static int nss_bf_delete_class(struct Qd
+  *	Replaces the qdisc attached to the provided class.
+  */
+ static int nss_bf_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
+-								 struct Qdisc **old)
++			 	struct Qdisc **old, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_bf_sched_data *q = qdisc_priv(sch);
+ 	struct nss_bf_class_data *cl = (struct nss_bf_class_data *)arg;
+@@ -432,24 +432,6 @@ static unsigned long nss_bf_get_class(st
+ }
+ 
+ /*
+- * nss_bf_put_class()
+- *	Reduces reference count for this class.
+- */
+-static void nss_bf_put_class(struct Qdisc *sch, unsigned long arg)
+-{
+-	struct nss_bf_class_data *cl = (struct nss_bf_class_data *)arg;
+-	nss_qdisc_info("bf put class for %p\n", cl);
+-
+-	/*
+-	 * We are safe to destroy the qdisc if the reference count
+-	 * goes down to 0.
+-	 */
+-	if (atomic_sub_return(1, &cl->nq.refcnt) == 0) {
+-		nss_bf_destroy_class(sch, cl);
+-	}
+-}
+-
+-/*
+  * nss_bf_dump_class()
+  *	Dumps all configurable parameters pertaining to this class.
+  */
+@@ -538,7 +520,7 @@ static void nss_bf_walk(struct Qdisc *sc
+  * nss_bf_change_qdisc()
+  *	Can be used to configure a nssbf qdisc.
+  */
+-static int nss_bf_change_qdisc(struct Qdisc *sch, struct nlattr *opt)
++static int nss_bf_change_qdisc(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_bf_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nssbf_qopt *qopt;
+@@ -684,7 +666,7 @@ static void nss_bf_destroy_qdisc(struct
+  * nss_bf_init_qdisc()
+  *	Initializes the nssbf qdisc.
+  */
+-static int nss_bf_init_qdisc(struct Qdisc *sch, struct nlattr *opt)
++static int nss_bf_init_qdisc(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_bf_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nssbf_qopt *qopt;
+@@ -720,7 +702,7 @@ static int nss_bf_init_qdisc(struct Qdis
+ 	/*
+ 	 * Initialize the NSSBF shaper in NSS
+ 	 */
+-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_BF, 0, accel_mode) < 0) {
++	if (nss_qdisc_init(sch, extack, &q->nq, NSS_SHAPER_NODE_TYPE_BF, 0, accel_mode) < 0) {
+ 		return -EINVAL;
+ 	}
+ 
+@@ -729,7 +711,7 @@ static int nss_bf_init_qdisc(struct Qdis
+ 	/*
+ 	 * Tune nss_bf parameters.
+ 	 */
+-	if (nss_bf_change_qdisc(sch, opt) < 0) {
++	if (nss_bf_change_qdisc(sch, opt, NULL) < 0) {
+ 		nss_qdisc_destroy(&q->nq);
+ 		return -EINVAL;
+ 	}
+@@ -772,7 +754,7 @@ nla_put_failure:
+  * nss_bf_enqueue()
+  *	Enqueues a skb to nssbf qdisc.
+  */
+-static int nss_bf_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_bf_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -787,18 +769,6 @@ static struct sk_buff *nss_bf_dequeue(st
+ }
+ 
+ /*
+- * nss_bf_drop()
+- *	Drops a single skb from linux queue, if not empty.
+- *
+- * Does not drop packets that are queued in the NSS.
+- */
+-static unsigned int nss_bf_drop(struct Qdisc *sch)
+-{
+-	printk("In bf drop\n");
+-	return nss_qdisc_drop(sch);
+-}
+-
+-/*
+  * Registration structure for nssbf class
+  */
+ const struct Qdisc_class_ops nss_bf_class_ops = {
+@@ -807,9 +777,8 @@ const struct Qdisc_class_ops nss_bf_clas
+ 	.graft		= nss_bf_graft_class,
+ 	.leaf		= nss_bf_leaf_class,
+ 	.qlen_notify	= nss_bf_qlen_notify,
+-	.get		= nss_bf_get_class,
+-	.put		= nss_bf_put_class,
++	.find		= nss_bf_get_class,
+ 	.dump		= nss_bf_dump_class,
+ 	.dump_stats	= nss_bf_dump_class_stats,
+ 	.walk		= nss_bf_walk
+ };
+@@ -830,7 +798,6 @@ struct Qdisc_ops nss_bf_qdisc_ops __read
+ 	.enqueue	= nss_bf_enqueue,
+ 	.dequeue	= nss_bf_dequeue,
+ 	.peek		= qdisc_peek_dequeued,
+-	.drop		= nss_bf_drop,
+ 	.cl_ops		= &nss_bf_class_ops,
+ 	.priv_size	= sizeof(struct nss_bf_sched_data),
+ 	.owner		= THIS_MODULE
+--- a/nss_qdisc/nss_blackhole.c
++++ b/nss_qdisc/nss_blackhole.c
+@@ -35,7 +35,7 @@ static struct nla_policy nss_blackhole_p
+  * nss_blackhole_enqueue()
+  *	Enqueue API for nss blackhole qdisc.
+  */
+-static int nss_blackhole_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_blackhole_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -50,18 +50,6 @@ static struct sk_buff *nss_blackhole_deq
+ }
+ 
+ /*
+- * nss_blackhole_drop()
+- *	The following function drops a packet from HLOS queue.
+- *
+- * Note, this does not drop packets from queues in the NSS. We do not support that.
+- */
+-static unsigned int nss_blackhole_drop(struct Qdisc *sch)
+-{
+-	nss_qdisc_info("qdisc %x dropping\n", sch->handle);
+-	return nss_qdisc_drop(sch);
+-}
+-
+-/*
+  * nss_blackhole_reset()
+  *	Resets the nss blackhole qdisc.
+  */
+@@ -92,7 +80,7 @@ static void nss_blackhole_destroy(struct
+  * nss_blackhole_change()
+  *	Function call used to configure the parameters of the nss blackhole qdisc.
+  */
+-static int nss_blackhole_change(struct Qdisc *sch, struct nlattr *opt)
++static int nss_blackhole_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_blackhole_sched_data *q;
+ 	struct tc_nssblackhole_qopt *qopt;
+@@ -154,7 +142,7 @@ static int nss_blackhole_change(struct Q
+  * nss_blackhole_init()
+  *	Initializes a nss blackhole qdisc.
+  */
+-static int nss_blackhole_init(struct Qdisc *sch, struct nlattr *opt)
++static int nss_blackhole_init(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_qdisc *nq = qdisc_priv(sch);
+ 	struct tc_nssblackhole_qopt *qopt;
+@@ -176,12 +164,12 @@ static int nss_blackhole_init(struct Qdi
+ 	nss_qdisc_info("qdisc %x initializing\n", sch->handle);
+ 	nss_blackhole_reset(sch);
+ 
+-	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_FIFO, 0, accel_mode) < 0) {
++	if (nss_qdisc_init(sch, extack, nq, NSS_SHAPER_NODE_TYPE_FIFO, 0, accel_mode) < 0) {
+ 		return -EINVAL;
+ 	}
+ 
+ 	nss_qdisc_info("qdisc %x initialized with parent %x\n", sch->handle, sch->parent);
+-	if (nss_blackhole_change(sch, opt) < 0) {
++	if (nss_blackhole_change(sch, opt, NULL) < 0) {
+ 		nss_qdisc_destroy(nq);
+ 		return -EINVAL;
+ 	}
+@@ -251,7 +239,6 @@ struct Qdisc_ops nss_blackhole_qdisc_ops
+ 	.enqueue	=	nss_blackhole_enqueue,
+ 	.dequeue	=	nss_blackhole_dequeue,
+ 	.peek		=	nss_blackhole_peek,
+-	.drop		=	nss_blackhole_drop,
+ 	.init		=	nss_blackhole_init,
+ 	.reset		=	nss_blackhole_reset,
+ 	.destroy	=	nss_blackhole_destroy,
+--- a/nss_qdisc/nss_codel.c
++++ b/nss_qdisc/nss_codel.c
+@@ -76,7 +76,7 @@ static struct nla_policy nss_codel_polic
+  * nss_codel_enqueue()
+  *	Enqueue a packet into nss_codel queue in NSS firmware (bounce).
+  */
+-static int nss_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -91,17 +91,6 @@ static struct sk_buff *nss_codel_dequeue
+ }
+ 
+ /*
+- * nss_codel_drop()
+- *	Drops a packet from the bounce complete queue.
+- *
+- * Note: this does not drop packets from the NSS queues.
+- */
+-static unsigned int nss_codel_drop(struct Qdisc *sch)
+-{
+-	return nss_qdisc_drop(sch);
+-}
+-
+-/*
+  * nss_codel_reset()
+  *	Resets nss_codel qdisc.
+  */
+@@ -234,7 +223,7 @@ static int nss_codel_mem_sz_get(struct Q
+  * nss_codel_change()
+  *	Used to configure the nss_codel queue in NSS firmware.
+  */
+-static int nss_codel_change(struct Qdisc *sch, struct nlattr *opt)
++static int nss_codel_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_codel_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nsscodel_qopt *qopt;
+@@ -381,7 +370,7 @@ fail:
+  * nss_codel_init()
+  *	Initializes the nss_codel qdisc.
+  */
+-static int nss_codel_init(struct Qdisc *sch, struct nlattr *opt)
++static int nss_codel_init(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_qdisc *nq = qdisc_priv(sch);
+ 	struct tc_nsscodel_qopt *qopt;
+@@ -404,7 +393,7 @@ static int nss_codel_init(struct Qdisc *
+ 	nss_qdisc_register_configure_callback(nq, nss_codel_configure_callback);
+ 	nss_qdisc_register_stats_callback(nq, nss_codel_stats_callback);
+ 
+-	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_CODEL, 0, qopt->accel_mode) < 0) {
++	if (nss_qdisc_init(sch, extack, nq, NSS_SHAPER_NODE_TYPE_CODEL, 0, qopt->accel_mode) < 0) {
+ 		return -EINVAL;
+ 	}
+ 
+@@ -412,7 +401,7 @@ static int nss_codel_init(struct Qdisc *
+ 		return -EINVAL;
+ 	}
+ 
+-	if (nss_codel_change(sch, opt) < 0) {
++	if (nss_codel_change(sch, opt, NULL) < 0) {
+ 		nss_qdisc_destroy(nq);
+ 		return -EINVAL;
+ 	}
+@@ -511,7 +500,6 @@ struct Qdisc_ops nss_codel_qdisc_ops __r
+ 	.enqueue	=	nss_codel_enqueue,
+ 	.dequeue	=	nss_codel_dequeue,
+ 	.peek		=	nss_codel_peek,
+-	.drop		=	nss_codel_drop,
+ 	.init		=	nss_codel_init,
+ 	.reset		=	nss_codel_reset,
+ 	.destroy	=	nss_codel_destroy,
+@@ -530,7 +518,6 @@ struct Qdisc_ops nss_fq_codel_qdisc_ops
+ 	.enqueue	=	nss_codel_enqueue,
+ 	.dequeue	=	nss_codel_dequeue,
+ 	.peek		=	nss_codel_peek,
+-	.drop		=	nss_codel_drop,
+ 	.init		=	nss_codel_init,
+ 	.reset		=	nss_codel_reset,
+ 	.destroy	=	nss_codel_destroy,
+--- a/nss_qdisc/nss_fifo.c
++++ b/nss_qdisc/nss_fifo.c
+@@ -29,7 +29,7 @@ static struct nla_policy nss_fifo_policy
+ 	[TCA_NSSFIFO_PARMS] = { .len = sizeof(struct tc_nssfifo_qopt) },
+ };
+ 
+-static int nss_fifo_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_fifo_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -39,12 +39,6 @@ static struct sk_buff *nss_fifo_dequeue(
+ 	return nss_qdisc_dequeue(sch);
+ }
+ 
+-static unsigned int nss_fifo_drop(struct Qdisc *sch)
+-{
+-	nss_qdisc_info("nss_fifo dropping");
+-	return nss_qdisc_drop(sch);
+-}
+-
+ static void nss_fifo_reset(struct Qdisc *sch)
+ {
+ 	nss_qdisc_info("nss_fifo resetting!");
+@@ -158,7 +152,7 @@ fail:
+ }
+ #endif
+ 
+-static int nss_fifo_change(struct Qdisc *sch, struct nlattr *opt)
++static int nss_fifo_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_fifo_sched_data *q = qdisc_priv(sch);
+ 	struct nss_qdisc *nq = &q->nq;
+@@ -208,7 +202,7 @@ static int nss_fifo_change(struct Qdisc
+ 	return 0;
+ }
+ 
+-static int nss_fifo_init(struct Qdisc *sch, struct nlattr *opt)
++static int nss_fifo_init(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_qdisc *nq = qdisc_priv(sch);
+ 	struct tc_nssfifo_qopt *qopt;
+@@ -226,13 +220,13 @@ static int nss_fifo_init(struct Qdisc *s
+ 		return -EINVAL;
+ 	}
+ 
+-	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_FIFO, 0, qopt->accel_mode) < 0) {
++	if (nss_qdisc_init(sch, extack, nq, NSS_SHAPER_NODE_TYPE_FIFO, 0, qopt->accel_mode) < 0) {
+ 		nss_qdisc_warning("Fifo %x init failed", sch->handle);
+ 		return -EINVAL;
+ 	}
+ 
+ 	nss_qdisc_info("NSS fifo initialized - handle %x parent %x\n", sch->handle, sch->parent);
+-	if (nss_fifo_change(sch, opt) < 0) {
++	if (nss_fifo_change(sch, opt, NULL) < 0) {
+ 		nss_qdisc_destroy(nq);
+ 		return -EINVAL;
+ 	}
+@@ -290,7 +284,6 @@ struct Qdisc_ops nss_pfifo_qdisc_ops __r
+ 	.enqueue	=	nss_fifo_enqueue,
+ 	.dequeue	=	nss_fifo_dequeue,
+ 	.peek		=	nss_fifo_peek,
+-	.drop		=	nss_fifo_drop,
+ 	.init		=	nss_fifo_init,
+ 	.reset		=	nss_fifo_reset,
+ 	.destroy	=	nss_fifo_destroy,
+@@ -305,7 +298,6 @@ struct Qdisc_ops nss_bfifo_qdisc_ops __r
+ 	.enqueue	=	nss_fifo_enqueue,
+ 	.dequeue	=	nss_fifo_dequeue,
+ 	.peek		=	nss_fifo_peek,
+-	.drop		=	nss_fifo_drop,
+ 	.init		=	nss_fifo_init,
+ 	.reset		=	nss_fifo_reset,
+ 	.destroy	=	nss_fifo_destroy,
+--- a/nss_qdisc/nss_htb.c
++++ b/nss_qdisc/nss_htb.c
+@@ -267,7 +267,7 @@ static int nss_htb_ppe_change_class(stru
+  *	Configures a new class.
+  */
+ static int nss_htb_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
+-		  struct nlattr **tca, unsigned long *arg)
++		  struct nlattr **tca, unsigned long *arg, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_htb_sched_data *q = qdisc_priv(sch);
+ 	struct nss_htb_class_data *cl = (struct nss_htb_class_data *)*arg;
+@@ -332,7 +332,7 @@ static int nss_htb_change_class(struct Q
+ 		 * here.
+ 		 */
+ 		cl->nq.parent = nq_parent;
+-		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_HTB_GROUP, classid, accel_mode) < 0) {
++		if (nss_qdisc_init(sch, extack, &cl->nq, NSS_SHAPER_NODE_TYPE_HTB_GROUP, classid, accel_mode) < 0) {
+ 			nss_qdisc_error("nss_init for htb class %x failed\n", classid);
+ 			goto failure;
+ 		}
+@@ -478,7 +478,7 @@ static void nss_htb_destroy_class(struct
+ 	/*
+ 	 * And now we destroy the child.
+ 	 */
+-	qdisc_destroy(cl->qdisc);
++	qdisc_put(cl->qdisc);
+ 
+ 	/*
+ 	 * Stop the stats polling timer and free class
+@@ -577,7 +577,8 @@ static int nss_htb_delete_class(struct Q
+  * nss_htb_graft_class()
+  *	Replaces the qdisc attached to the provided class.
+  */
+-static int nss_htb_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new, struct Qdisc **old)
++static int nss_htb_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new, struct Qdisc **old,
++				struct netlink_ext_ack *extack)
+ {
+ 	struct nss_htb_class_data *cl = (struct nss_htb_class_data *)arg;
+ 	struct nss_if_msg nim_detach;
+@@ -682,25 +683,6 @@ static unsigned long nss_htb_get_class(s
+ }
+ 
+ /*
+- * nss_htb_put_class()
+- *	Reduces reference count for this class.
+- */
+-static void nss_htb_put_class(struct Qdisc *sch, unsigned long arg)
+-{
+-	struct nss_htb_class_data *cl = (struct nss_htb_class_data *)arg;
+-	nss_qdisc_trace("executing put on htb class %x in qdisc %x\n",
+-			cl->nq.qos_tag, sch->handle);
+-
+-	/*
+-	 * We are safe to destroy the qdisc if the reference count
+-	 * goes down to 0.
+-	 */
+-	if (atomic_sub_return(1, &cl->nq.refcnt) == 0) {
+-		nss_htb_destroy_class(sch, cl);
+-	}
+-}
+-
+-/*
+  * nss_htb_dump_class()
+  *	Dumps all configurable parameters pertaining to this class.
+  */
+@@ -795,7 +777,7 @@ static void nss_htb_walk(struct Qdisc *s
+  * nss_htb_change_qdisc()
+  *	Can be used to configure a htb qdisc.
+  */
+-static int nss_htb_change_qdisc(struct Qdisc *sch, struct nlattr *opt)
++static int nss_htb_change_qdisc(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_htb_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nsshtb_qopt *qopt;
+@@ -945,7 +927,7 @@ static void nss_htb_destroy_qdisc(struct
+  * nss_htb_init_qdisc()
+  *	Initializes the htb qdisc.
+  */
+-static int nss_htb_init_qdisc(struct Qdisc *sch, struct nlattr *opt)
++static int nss_htb_init_qdisc(struct Qdisc *sch, struct nlattr *opt,struct netlink_ext_ack *extack)
+ {
+ 	struct nss_htb_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nsshtb_qopt *qopt;
+@@ -977,7 +959,7 @@ static int nss_htb_init_qdisc(struct Qdi
+ 	/*
+ 	 * Initialize the NSSHTB shaper in NSS
+ 	 */
+-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_HTB, 0, accel_mode) < 0) {
++	if (nss_qdisc_init(sch, extack, &q->nq, NSS_SHAPER_NODE_TYPE_HTB, 0, accel_mode) < 0) {
+ 		nss_qdisc_error("failed to initialize htb qdisc %x in nss", sch->handle);
+ 		return -EINVAL;
+ 	}
+@@ -987,7 +969,7 @@ static int nss_htb_init_qdisc(struct Qdi
+ 	/*
+ 	 * Tune HTB parameters
+ 	 */
+-	if (nss_htb_change_qdisc(sch, opt) < 0) {
++	if (nss_htb_change_qdisc(sch, opt, NULL) < 0) {
+ 		nss_qdisc_destroy(&q->nq);
+ 		return -EINVAL;
+ 	}
+@@ -1032,7 +1014,7 @@ static int nss_htb_dump_qdisc(struct Qdi
+  * nss_htb_enqueue()
+  *	Enqueues a skb to htb qdisc.
+  */
+-static int nss_htb_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_htb_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -1047,18 +1029,6 @@ static struct sk_buff *nss_htb_dequeue(s
+ }
+ 
+ /*
+- * nss_htb_drop()
+- *	Drops a single skb from linux queue, if not empty.
+- *
+- * Does not drop packets that are queued in the NSS.
+- */
+-static unsigned int nss_htb_drop(struct Qdisc *sch)
+-{
+-	nss_qdisc_trace("drop called on htb qdisc %x\n", sch->handle);
+-	return nss_qdisc_drop(sch);
+-}
+-
+-/*
+  * Registration structure for htb class
+  */
+ const struct Qdisc_class_ops nss_htb_class_ops = {
+@@ -1067,9 +1037,8 @@ const struct Qdisc_class_ops nss_htb_cla
+ 	.graft		= nss_htb_graft_class,
+ 	.leaf		= nss_htb_leaf_class,
+ 	.qlen_notify	= nss_htb_qlen_notify,
+-	.get		= nss_htb_get_class,
+-	.put		= nss_htb_put_class,
++	.find		= nss_htb_get_class,
+ 	.dump		= nss_htb_dump_class,
+ 	.dump_stats	= nss_htb_dump_class_stats,
+ 	.walk		= nss_htb_walk
+ };
+@@ -1090,7 +1058,6 @@ struct Qdisc_ops nss_htb_qdisc_ops __rea
+ 	.enqueue	= nss_htb_enqueue,
+ 	.dequeue	= nss_htb_dequeue,
+ 	.peek		= qdisc_peek_dequeued,
+-	.drop		= nss_htb_drop,
+ 	.cl_ops		= &nss_htb_class_ops,
+ 	.priv_size	= sizeof(struct nss_htb_sched_data),
+ 	.owner		= THIS_MODULE
+--- a/nss_qdisc/nss_prio.c
++++ b/nss_qdisc/nss_prio.c
+@@ -37,7 +37,7 @@ static struct nla_policy nss_prio_policy
+  * nss_prio_enqueue()
+  *	Enqueues a skb to nssprio qdisc.
+  */
+-static int nss_prio_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_prio_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -52,17 +52,6 @@ static struct sk_buff *nss_prio_dequeue(
+ }
+ 
+ /*
+- * nss_prio_drop()
+- *	Drops a single skb from linux queue, if not empty.
+- *
+- * Does not drop packets that are queued in the NSS.
+- */
+-static unsigned int nss_prio_drop(struct Qdisc *sch)
+-{
+-	return nss_qdisc_drop(sch);
+-}
+-
+-/*
+  * nss_prio_peek()
+  *	Peeks the first packet in queue for this qdisc.
+  */
+@@ -117,7 +106,7 @@ static void nss_prio_destroy(struct Qdis
+ 		/*
+ 		 * We can now destroy it
+ 		 */
+-		qdisc_destroy(q->queues[i]);
++		qdisc_put(q->queues[i]);
+ 	}
+ 
+ 	/*
+@@ -157,7 +146,7 @@ static int nss_prio_get_max_bands(struct
+  * nss_prio_change()
+  *	Function call to configure the nssprio parameters
+  */
+-static int nss_prio_change(struct Qdisc *sch, struct nlattr *opt)
++static int nss_prio_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_prio_sched_data *q;
+ 	struct tc_nssprio_qopt *qopt;
+@@ -209,7 +198,7 @@ static int nss_prio_change(struct Qdisc
+  * nss_prio_init()
+  *	Initializes the nssprio qdisc
+  */
+-static int nss_prio_init(struct Qdisc *sch, struct nlattr *opt)
++static int nss_prio_init(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_prio_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nssprio_qopt *qopt;
+@@ -230,14 +219,14 @@ static int nss_prio_init(struct Qdisc *s
+ 		accel_mode = qopt->accel_mode;
+ 	}
+ 
+-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_PRIO, 0, accel_mode) < 0) {
++	if (nss_qdisc_init(sch, extack, &q->nq, NSS_SHAPER_NODE_TYPE_PRIO, 0, accel_mode) < 0) {
+ 		return -EINVAL;
+ 	}
+ 
+ 	nss_qdisc_info("Nssprio initialized - handle %x parent %x\n",
+ 			sch->handle, sch->parent);
+ 
+-	if (nss_prio_change(sch, opt) < 0) {
++	if (nss_prio_change(sch, opt, NULL) < 0) {
+ 		nss_qdisc_destroy(&q->nq);
+ 		return -EINVAL;
+ 	}
+@@ -280,7 +269,7 @@ nla_put_failure:
+  *	Replaces existing child qdisc with the new qdisc that is passed.
+  */
+ static int nss_prio_graft(struct Qdisc *sch, unsigned long arg,
+-				struct Qdisc *new, struct Qdisc **old)
++				struct Qdisc *new, struct Qdisc **old, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_prio_sched_data *q = qdisc_priv(sch);
+ 	struct nss_qdisc *nq_new = qdisc_priv(new);
+@@ -383,15 +372,6 @@ static unsigned long nss_prio_get(struct
+ }
+ 
+ /*
+- * nss_prio_put()
+- *	Unused API.
+- */
+-static void nss_prio_put(struct Qdisc *sch, unsigned long arg)
+-{
+-	nss_qdisc_info("Inside prio put\n");
+-}
+-
+-/*
+  * nss_prio_walk()
+  *	Walks the priority band.
+  */
+@@ -460,9 +440,8 @@ static int nss_prio_dump_class_stats(str
+ const struct Qdisc_class_ops nss_prio_class_ops = {
+ 	.graft		=	nss_prio_graft,
+ 	.leaf		=	nss_prio_leaf,
+-	.get		=	nss_prio_get,
+-	.put		=	nss_prio_put,
++	.find		=	nss_prio_get,
+ 	.walk		=	nss_prio_walk,
+ 	.dump		=	nss_prio_dump_class,
+ 	.dump_stats	=	nss_prio_dump_class_stats,
+ };
+@@ -481,7 +459,6 @@ struct Qdisc_ops nss_prio_qdisc_ops __re
+ 	.enqueue	=	nss_prio_enqueue,
+ 	.dequeue	=	nss_prio_dequeue,
+ 	.peek		=	nss_prio_peek,
+-	.drop		=	nss_prio_drop,
+ 	.init		=	nss_prio_init,
+ 	.reset		=	nss_prio_reset,
+ 	.destroy	=	nss_prio_destroy,
+--- a/nss_qdisc/nss_qdisc.c
++++ b/nss_qdisc/nss_qdisc.c
+@@ -929,7 +929,7 @@ static inline void nss_qdisc_add_to_tail
+ 	 * We do not use the qdisc_enqueue_tail() API here in order
+ 	 * to prevent stats from getting updated by the API.
+ 	 */
+-	__skb_queue_tail(&sch->q, skb);
++	__qdisc_enqueue_tail(skb, &sch->q);
+ 
+ 	spin_unlock_bh(&nq->bounce_protection_lock);
+ };
+@@ -944,7 +944,7 @@ static inline void nss_qdisc_add_to_tail
+ 	 * We do not use the qdisc_enqueue_tail() API here in order
+ 	 * to prevent stats from getting updated by the API.
+ 	 */
+-	__skb_queue_tail(&sch->q, skb);
++	__qdisc_enqueue_tail(skb, &sch->q);
+ };
+ 
+ /*
+@@ -966,7 +966,7 @@ static inline struct sk_buff *nss_qdisc_
+ 	 * We use __skb_dequeue() to ensure that
+ 	 * stats don't get updated twice.
+ 	 */
+-	skb = __skb_dequeue(&sch->q);
++	skb = __qdisc_dequeue_head(&sch->q);
+ 
+ 	spin_unlock_bh(&nq->bounce_protection_lock);
+ 
+@@ -983,7 +983,7 @@ static inline struct sk_buff *nss_qdisc_
+ 	 * We use __skb_dequeue() to ensure that
+ 	 * stats don't get updated twice.
+ 	 */
+-	return __skb_dequeue(&sch->q);
++	return __qdisc_dequeue_head(&sch->q);
+ };
+ 
+ /*
+@@ -1064,14 +1064,19 @@ struct Qdisc *nss_qdisc_replace(struct Q
+ void *nss_qdisc_qopt_get(struct nlattr *opt, struct nla_policy *policy,
+ 				uint32_t tca_max, uint32_t tca_params)
+ {
+-	struct nlattr *na[tca_max + 1];
++	struct nlattr *na[8];
+ 	int err;
+ 
++	if (tca_max > 8) {
++		pr_warn("nss_qdisc_qopt_get(): Too many options!\n");
++		return NULL;
++	}
++
+ 	if (!opt) {
+ 		return NULL;
+ 	}
+ 
+-	err = nla_parse_nested(na, tca_max, opt, policy);
++	err = nla_parse_nested_deprecated(na, tca_max, opt, policy, NULL);
+ 	if (err < 0)
+ 		return NULL;
+ 
+@@ -1104,10 +1109,10 @@ struct sk_buff *nss_qdisc_peek(struct Qd
+ 	struct sk_buff *skb;
+ 
+ 	if (!nq->is_virtual) {
+-		skb = skb_peek(&sch->q);
++		skb = qdisc_peek_head(sch);
+ 	} else {
+ 		spin_lock_bh(&nq->bounce_protection_lock);
+-		skb = skb_peek(&sch->q);
++		skb = qdisc_peek_head(sch);
+ 		spin_unlock_bh(&nq->bounce_protection_lock);
+ 	}
+ 
+@@ -1122,15 +1127,16 @@ unsigned int nss_qdisc_drop(struct Qdisc
+ {
+ 	struct nss_qdisc *nq = qdisc_priv(sch);
+ 	unsigned int ret;
++	struct sk_buff *to_free = qdisc_peek_head(sch);
+ 
+ 	if (!nq->is_virtual) {
+-		ret = __qdisc_queue_drop_head(sch, &sch->q);
++		ret = __qdisc_queue_drop_head(sch, &sch->q, &to_free);
+ 	} else {
+ 		spin_lock_bh(&nq->bounce_protection_lock);
+ 		/*
+ 		 * This function is safe to call within locks
+ 		 */
+-		ret = __qdisc_queue_drop_head(sch, &sch->q);
++		ret = __qdisc_queue_drop_head(sch, &sch->q, &to_free);
+ 		spin_unlock_bh(&nq->bounce_protection_lock);
+ 	}
+ 
+@@ -1958,7 +1964,7 @@ void nss_qdisc_destroy(struct nss_qdisc
+  *	Initializes a shaper in NSS, based on the position of this qdisc (child or root)
+  *	and if its a normal interface or a bridge interface.
+  */
+-int nss_qdisc_init(struct Qdisc *sch, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode)
++int nss_qdisc_init(struct Qdisc *sch, struct netlink_ext_ack *extack, struct nss_qdisc *nq, nss_shaper_node_type_t type, uint32_t classid, uint32_t accel_mode)
+ {
+ 	struct Qdisc *root;
+ 	u32 parent;
+@@ -2471,6 +2481,8 @@ static void nss_qdisc_basic_stats_callba
+ 	struct gnet_stats_queue *qstats;
+ 	struct nss_shaper_node_stats_response *response;
+ 	atomic_t *refcnt;
++	refcount_t *refcnt_new;
++	bool is_refcnt_zero = false;
+ 
+ 	if (nim->cm.response != NSS_CMN_RESPONSE_ACK) {
+ 		nss_qdisc_warning("Qdisc %p (type %d): Receive stats FAILED - "
+@@ -2494,7 +2506,7 @@ static void nss_qdisc_basic_stats_callba
+ 	} else {
+ 		bstats = &qdisc->bstats;
+ 		qstats = &qdisc->qstats;
+-		refcnt = &qdisc->refcnt;
++		refcnt_new = &qdisc->refcnt;
+ 		qdisc->q.qlen = response->sn_stats.qlen_packets;
+ 	}
+ 
+@@ -2533,11 +2545,20 @@ static void nss_qdisc_basic_stats_callba
+ 	 * All access to nq fields below do not need lock protection. They
+ 	 * do not get manipulated on different thread contexts.
+ 	 */
+-	if (atomic_read(refcnt) == 0) {
++	if (nq->is_class) {
++		if (atomic_read(refcnt) == 0)
++			is_refcnt_zero = true;
++	}
++	else {
++		if (refcount_read(refcnt_new) == 0)
++			is_refcnt_zero = true;
++	}
++	if (is_refcnt_zero) {
+ 		atomic_sub(1, &nq->pending_stat_requests);
+ 		wake_up(&nq->wait_queue);
+ 		return;
+ 	}
++			
+ 
+ 	/*
+ 	 * Requests for stats again, after 1 sec.
+@@ -2555,9 +2576,9 @@ static void nss_qdisc_basic_stats_callba
+  * nss_qdisc_get_stats_timer_callback()
+  *	Invoked periodically to get updated stats
+  */
+-static void nss_qdisc_get_stats_timer_callback(unsigned long int data)
++static void nss_qdisc_get_stats_timer_callback(struct timer_list *arg)
+ {
+-	struct nss_qdisc *nq = (struct nss_qdisc *)data;
++	struct nss_qdisc *nq = (struct nss_qdisc *)arg->cust_data;
+ 	nss_tx_status_t rc;
+ 	struct nss_if_msg nim;
+ 	int msg_type;
+@@ -2604,9 +2625,8 @@ void nss_qdisc_start_basic_stats_polling
+ 		return;
+ 	}
+ 
+-	init_timer(&nq->stats_get_timer);
+-	nq->stats_get_timer.function = nss_qdisc_get_stats_timer_callback;
+-	nq->stats_get_timer.data = (unsigned long)nq;
++	timer_setup(&nq->stats_get_timer, nss_qdisc_get_stats_timer_callback, 0);
++	nq->stats_get_timer.cust_data = (unsigned long)nq;
+ 	nq->stats_get_timer.expires = jiffies + HZ;
+ 	atomic_set(&nq->pending_stat_requests, 1);
+ 	add_timer(&nq->stats_get_timer);
+@@ -2650,7 +2670,7 @@ int nss_qdisc_gnet_stats_copy_basic(stru
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 18, 0))
+ 	return gnet_stats_copy_basic(d, b);
+ #else
+-	return gnet_stats_copy_basic(d, NULL, b);
++	return gnet_stats_copy_basic(NULL, d, NULL, b);
+ #endif
+ }
+ 
+--- a/nss_qdisc/nss_tbl.c
++++ b/nss_qdisc/nss_tbl.c
+@@ -29,7 +29,7 @@ static struct nla_policy nss_tbl_policy[
+ 	[TCA_NSSTBL_PARMS] = { .len = sizeof(struct tc_nsstbl_qopt) },
+ };
+ 
+-static int nss_tbl_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_tbl_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -39,11 +39,6 @@ static struct sk_buff *nss_tbl_dequeue(s
+ 	return nss_qdisc_dequeue(sch);
+ }
+ 
+-static unsigned int nss_tbl_drop(struct Qdisc *sch)
+-{
+-	return nss_qdisc_drop(sch);
+-}
+-
+ static struct sk_buff *nss_tbl_peek(struct Qdisc *sch)
+ {
+ 	return nss_qdisc_peek(sch);
+@@ -77,7 +72,7 @@ static void nss_tbl_destroy(struct Qdisc
+ 	/*
+ 	 * Now we can destroy our child qdisc
+ 	 */
+-	qdisc_destroy(q->qdisc);
++	qdisc_put(q->qdisc);
+ 
+ 	/*
+ 	 * Stop the polling of basic stats and destroy qdisc.
+@@ -132,7 +127,7 @@ fail:
+ }
+ #endif
+ 
+-static int nss_tbl_change(struct Qdisc *sch, struct nlattr *opt)
++static int nss_tbl_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_tbl_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nsstbl_qopt *qopt;
+@@ -216,7 +211,7 @@ static int nss_tbl_change(struct Qdisc *
+ 	return 0;
+ }
+ 
+-static int nss_tbl_init(struct Qdisc *sch, struct nlattr *opt)
++static int nss_tbl_init(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_tbl_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nsstbl_qopt *qopt;
+@@ -232,10 +227,10 @@ static int nss_tbl_init(struct Qdisc *sc
+ 		return -EINVAL;
+ 	}
+ 
+-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_TBL, 0, qopt->accel_mode) < 0)
++	if (nss_qdisc_init(sch, extack, &q->nq, NSS_SHAPER_NODE_TYPE_TBL, 0, qopt->accel_mode) < 0)
+ 		return -EINVAL;
+ 
+-	if (nss_tbl_change(sch, opt) < 0) {
++	if (nss_tbl_change(sch, opt, NULL) < 0) {
+ 		nss_qdisc_info("Failed to configure tbl\n");
+ 		nss_qdisc_destroy(&q->nq);
+ 		return -EINVAL;
+@@ -287,7 +282,7 @@ static int nss_tbl_dump_class(struct Qdi
+ }
+ 
+ static int nss_tbl_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
+-			struct Qdisc **old)
++			struct Qdisc **old, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_tbl_sched_data *q = qdisc_priv(sch);
+ 	struct nss_qdisc *nq_new = (struct nss_qdisc *)qdisc_priv(new);
+@@ -344,10 +339,6 @@ static unsigned long nss_tbl_get(struct
+ 	return 1;
+ }
+ 
+-static void nss_tbl_put(struct Qdisc *sch, unsigned long arg)
+-{
+-}
+-
+ static void nss_tbl_walk(struct Qdisc *sch, struct qdisc_walker *walker)
+ {
+ 	nss_qdisc_info("Nsstbl walk called");
+@@ -364,9 +355,8 @@ static void nss_tbl_walk(struct Qdisc *s
+ const struct Qdisc_class_ops nss_tbl_class_ops = {
+ 	.graft		=	nss_tbl_graft,
+ 	.leaf		=	nss_tbl_leaf,
+-	.get		=	nss_tbl_get,
+-	.put		=	nss_tbl_put,
++	.find		=	nss_tbl_get,
+ 	.walk		=	nss_tbl_walk,
+ 	.dump		=	nss_tbl_dump_class,
+ };
+ 
+@@ -381,7 +370,6 @@ struct Qdisc_ops nss_tbl_qdisc_ops __rea
+ 	.enqueue	=	nss_tbl_enqueue,
+ 	.dequeue	=	nss_tbl_dequeue,
+ 	.peek		=	nss_tbl_peek,
+-	.drop		=	nss_tbl_drop,
+ 	.init		=	nss_tbl_init,
+ 	.reset		=	nss_tbl_reset,
+ 	.destroy	=	nss_tbl_destroy,
+--- a/nss_qdisc/nss_wred.c
++++ b/nss_qdisc/nss_wred.c
+@@ -55,7 +55,7 @@ static struct nla_policy nss_wred_policy
+  * nss_wred_enqueue()
+  *	Enqueue API for nsswred qdisc
+  */
+-static int nss_wred_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_wred_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -70,16 +70,6 @@ static struct sk_buff *nss_wred_dequeue(
+ }
+ 
+ /*
+- * nss_wred_drop()
+- *	Drops a packet from HLOS queue.
+- */
+-static unsigned int nss_wred_drop(struct Qdisc *sch)
+-{
+-	nss_qdisc_info("nsswred dropping");
+-	return nss_qdisc_drop(sch);
+-}
+-
+-/*
+  * nss_wred_reset()
+  *	Reset the nsswred qdisc
+  */
+@@ -171,7 +161,7 @@ fail:
+  * nss_wred_change()
+  *	Function call to configure the nsswred parameters
+  */
+-static int nss_wred_change(struct Qdisc *sch, struct nlattr *opt)
++static int nss_wred_change(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_wred_sched_data *q = qdisc_priv(sch);
+ 	struct tc_nsswred_qopt *qopt;
+@@ -298,7 +288,7 @@ static int nss_wred_change(struct Qdisc
+  * nss_wred_init()
+  *	Init the nsswred qdisc
+  */
+-static int nss_wred_init(struct Qdisc *sch, struct nlattr *opt)
++static int nss_wred_init(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_qdisc *nq = qdisc_priv(sch);
+ 	struct tc_nsswred_qopt *qopt;
+@@ -315,11 +305,11 @@ static int nss_wred_init(struct Qdisc *s
+ 	nss_qdisc_info("Initializing Wred - type %d\n", NSS_SHAPER_NODE_TYPE_WRED);
+ 	nss_wred_reset(sch);
+ 
+-	if (nss_qdisc_init(sch, nq, NSS_SHAPER_NODE_TYPE_WRED, 0, qopt->accel_mode) < 0)
++	if (nss_qdisc_init(sch, extack, nq, NSS_SHAPER_NODE_TYPE_WRED, 0, qopt->accel_mode) < 0)
+ 		return -EINVAL;
+ 
+ 	nss_qdisc_info("NSS wred initialized - handle %x parent %x\n", sch->handle, sch->parent);
+-	if (nss_wred_change(sch, opt) < 0) {
++	if (nss_wred_change(sch, opt, NULL) < 0) {
+ 		nss_qdisc_destroy(nq);
+ 		return -EINVAL;
+ 	}
+@@ -405,7 +395,6 @@ struct Qdisc_ops nss_red_qdisc_ops __rea
+ 	.enqueue	=	nss_wred_enqueue,
+ 	.dequeue	=	nss_wred_dequeue,
+ 	.peek		=	nss_wred_peek,
+-	.drop		=	nss_wred_drop,
+ 	.init		=	nss_wred_init,
+ 	.reset		=	nss_wred_reset,
+ 	.destroy	=	nss_wred_destroy,
+@@ -423,7 +412,6 @@ struct Qdisc_ops nss_wred_qdisc_ops __re
+ 	.enqueue	=	nss_wred_enqueue,
+ 	.dequeue	=	nss_wred_dequeue,
+ 	.peek		=	nss_wred_peek,
+-	.drop		=	nss_wred_drop,
+ 	.init		=	nss_wred_init,
+ 	.reset		=	nss_wred_reset,
+ 	.destroy	=	nss_wred_destroy,
+--- a/nss_qdisc/nss_wrr.c
++++ b/nss_qdisc/nss_wrr.c
+@@ -84,7 +84,7 @@ static void nss_wrr_destroy_class(struct
+ 	/*
+ 	 * And now we destroy the child.
+ 	 */
+-	qdisc_destroy(cl->qdisc);
++	qdisc_put(cl->qdisc);
+ 
+ 	/*
+ 	 * Stop the stats polling timer and free class
+@@ -219,7 +219,7 @@ static int nss_wrr_ppe_change_class(stru
+ #endif
+ 
+ static int nss_wrr_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
+-		  struct nlattr **tca, unsigned long *arg)
++		  struct nlattr **tca, unsigned long *arg, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_wrr_sched_data *q = qdisc_priv(sch);
+ 	struct nss_wrr_class_data *cl = (struct nss_wrr_class_data *)*arg;
+@@ -286,7 +286,7 @@ static int nss_wrr_change_class(struct Q
+ 		 * here.
+ 		 */
+ 		cl->nq.parent = &q->nq;
+-		if (nss_qdisc_init(sch, &cl->nq, NSS_SHAPER_NODE_TYPE_WRR_GROUP, classid, accel_mode) < 0) {
++		if (nss_qdisc_init(sch, extack, &cl->nq, NSS_SHAPER_NODE_TYPE_WRR_GROUP, classid, accel_mode) < 0) {
+ 			nss_qdisc_error("Nss init for class %u failed\n", classid);
+ 			return -EINVAL;
+ 		}
+@@ -422,7 +422,7 @@ static int nss_wrr_delete_class(struct Q
+ }
+ 
+ static int nss_wrr_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,
+-								 struct Qdisc **old)
++				struct Qdisc **old, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_wrr_sched_data *q = qdisc_priv(sch);
+ 	struct nss_wrr_class_data *cl = (struct nss_wrr_class_data *)arg;
+@@ -517,20 +517,6 @@ static unsigned long nss_wrr_get_class(s
+ 	return (unsigned long)cl;
+ }
+ 
+-static void nss_wrr_put_class(struct Qdisc *sch, unsigned long arg)
+-{
+-	struct nss_wrr_class_data *cl = (struct nss_wrr_class_data *)arg;
+-	nss_qdisc_info("nss_wrr put class for %p\n", cl);
+-
+-	/*
+-	 * We are safe to destroy the qdisc if the reference count
+-	 * goes down to 0.
+-	 */
+-	if (atomic_sub_return(1, &cl->nq.refcnt) == 0) {
+-		nss_wrr_destroy_class(sch, cl);
+-	}
+-}
+-
+ static int nss_wrr_dump_class(struct Qdisc *sch, unsigned long arg, struct sk_buff *skb,
+ 		struct tcmsg *tcm)
+ {
+@@ -600,7 +586,7 @@ static void nss_wrr_walk(struct Qdisc *s
+ 	}
+ }
+ 
+-static int nss_wrr_init_qdisc(struct Qdisc *sch, struct nlattr *opt)
++static int nss_wrr_init_qdisc(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_wrr_sched_data *q = qdisc_priv(sch);
+ 	int err;
+@@ -629,7 +615,7 @@ static int nss_wrr_init_qdisc(struct Qdi
+ 	/*
+ 	 * Initialize the NSSWRR shaper in NSS
+ 	 */
+-	if (nss_qdisc_init(sch, &q->nq, NSS_SHAPER_NODE_TYPE_WRR, 0, qopt->accel_mode) < 0) {
++	if (nss_qdisc_init(sch, extack, &q->nq, NSS_SHAPER_NODE_TYPE_WRR, 0, qopt->accel_mode) < 0) {
+ 		nss_qdisc_warning("Failed init nss_wrr qdisc");
+ 		return -EINVAL;
+ 	}
+@@ -669,7 +655,7 @@ static int nss_wrr_init_qdisc(struct Qdi
+ 	return 0;
+ }
+ 
+-static int nss_wrr_change_qdisc(struct Qdisc *sch, struct nlattr *opt)
++static int nss_wrr_change_qdisc(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack)
+ {
+ 	struct nss_wrr_sched_data *q;
+ 	struct tc_nsswrr_qopt *qopt;
+@@ -809,7 +795,7 @@ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
+-static int nss_wrr_enqueue(struct sk_buff *skb, struct Qdisc *sch)
++static int nss_wrr_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free)
+ {
+ 	return nss_qdisc_enqueue(skb, sch);
+ }
+@@ -819,21 +805,14 @@ static struct sk_buff *nss_wrr_dequeue(s
+ 	return nss_qdisc_dequeue(sch);
+ }
+ 
+-static unsigned int nss_wrr_drop(struct Qdisc *sch)
+-{
+-	nss_qdisc_info("Nsswrr drop\n");
+-	return nss_qdisc_drop(sch);
+-}
+-
+ const struct Qdisc_class_ops nss_wrr_class_ops = {
+ 	.change		= nss_wrr_change_class,
+ 	.delete		= nss_wrr_delete_class,
+ 	.graft		= nss_wrr_graft_class,
+ 	.leaf		= nss_wrr_leaf_class,
+ 	.qlen_notify	= nss_wrr_qlen_notify,
+-	.get		= nss_wrr_get_class,
+-	.put		= nss_wrr_put_class,
++	.find		= nss_wrr_get_class,
+ 	.dump		= nss_wrr_dump_class,
+ 	.dump_stats	= nss_wrr_dump_class_stats,
+ 	.walk		= nss_bf_walk
+ };
+@@ -851,7 +829,6 @@ struct Qdisc_ops nss_wrr_qdisc_ops __rea
+ 	.enqueue	= nss_wrr_enqueue,
+ 	.dequeue	= nss_wrr_dequeue,
+ 	.peek		= qdisc_peek_dequeued,
+-	.drop		= nss_wrr_drop,
+ 	.cl_ops		= &nss_wrr_class_ops,
+ 	.priv_size	= sizeof(struct nss_wrr_sched_data),
+ 	.owner		= THIS_MODULE
+@@ -863,9 +840,8 @@ const struct Qdisc_class_ops nss_wfq_cla
+ 	.graft		= nss_wrr_graft_class,
+ 	.leaf		= nss_wrr_leaf_class,
+ 	.qlen_notify	= nss_wrr_qlen_notify,
+-	.get		= nss_wrr_get_class,
+-	.put		= nss_wrr_put_class,
++	.find		= nss_wrr_get_class,
+ 	.dump		= nss_wrr_dump_class,
+ 	.dump_stats	= nss_wrr_dump_class_stats,
+ 	.walk		= nss_wrr_walk
+ };
+@@ -883,7 +858,6 @@ struct Qdisc_ops nss_wfq_qdisc_ops __rea
+ 	.enqueue	= nss_wrr_enqueue,
+ 	.dequeue	= nss_wrr_dequeue,
+ 	.peek		= qdisc_peek_dequeued,
+-	.drop		= nss_wrr_drop,
+ 	.cl_ops		= &nss_wrr_class_ops,
+ 	.priv_size	= sizeof(struct nss_wrr_sched_data),
+ 	.owner		= THIS_MODULE
diff --git a/package/qca/qca-nss-clients/patches/101-kernel-5.4-support-gre.patch b/package/qca/qca-nss-clients/patches/101-kernel-5.4-support-gre.patch
new file mode 100644
index 0000000000..705ceabe60
--- /dev/null
+++ b/package/qca/qca-nss-clients/patches/101-kernel-5.4-support-gre.patch
@@ -0,0 +1,106 @@
+From 7c89187ab2d165ccffed627742e7cb72cce375ef Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Sun, 12 Jul 2020 22:49:30 +0200
+Subject: [PATCH] kernel-5.4-support-gre
+
+---
+ gre/nss_connmgr_gre.c    | 16 +++++++---------
+ gre/nss_connmgr_gre_v6.c |  4 ++--
+ 2 files changed, 9 insertions(+), 11 deletions(-)
+
+diff --git a/gre/nss_connmgr_gre.c b/gre/nss_connmgr_gre.c
+index 52203b1..6de8f6e 100644
+--- a/gre/nss_connmgr_gre.c
++++ b/gre/nss_connmgr_gre.c
+@@ -88,7 +88,7 @@ static int nss_connmgr_gre_dev_init(struct net_device *dev)
+ 		u64_stats_init(&stats->syncp);
+ 	}
+ 
+-	if ((dev->priv_flags & IFF_GRE_V4_TAP) || (dev->type == ARPHRD_IPGRE)) {
++	if ((dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V4_TAP) || (dev->type == ARPHRD_IPGRE)) {
+ 		dev->needed_headroom = sizeof(struct iphdr) + sizeof(struct ethhdr) + MAX_WIFI_HEADROOM + append;
+ 		dev->mtu = ETH_DATA_LEN - sizeof(struct iphdr) - append;
+ 		dev->features |= NETIF_F_NETNS_LOCAL | NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA;
+@@ -169,7 +169,7 @@ fail:
+  * nss_connmgr_gre_dev_stats64()
+  *	Netdev ops function to retrieve stats.
+  */
+-struct rtnl_link_stats64 *nss_connmgr_gre_dev_stats64(struct net_device *dev,
++void nss_connmgr_gre_dev_stats64(struct net_device *dev,
+ 						struct rtnl_link_stats64 *tot)
+ {
+ 	uint64_t rx_packets, rx_bytes, tx_packets, tx_bytes;
+@@ -202,8 +202,6 @@ struct rtnl_link_stats64 *nss_connmgr_gre_dev_stats64(struct net_device *dev,
+ 		tot->rx_dropped = dev->stats.rx_dropped;
+ 		tot->tx_dropped = dev->stats.tx_dropped;
+ 	}
+-
+-	return tot;
+ }
+ 
+ /*
+@@ -390,7 +388,7 @@ static int32_t nss_connmgr_gre_prepare_config_cmd(struct net_device *dev,
+ {
+ 	struct nss_gre_config_msg *cmsg = &req->msg.cmsg;
+ 
+-	if ((dev->type == ARPHRD_ETHER) && (dev->priv_flags & IFF_GRE_V4_TAP)) {
++	if ((dev->type == ARPHRD_ETHER) && (dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V4_TAP)) {
+ 		cmsg->mode = NSS_GRE_MODE_TAP;
+ 		cmsg->ip_type = NSS_GRE_IP_IPV4;
+ 		if (enable_unalign) {
+@@ -399,7 +397,7 @@ static int32_t nss_connmgr_gre_prepare_config_cmd(struct net_device *dev,
+ 		return nss_connmgr_gre_v4_get_config(dev, req, next_dev, hold);
+ 	}
+ 
+-	if ((dev->type == ARPHRD_ETHER) && (dev->priv_flags & IFF_GRE_V6_TAP)) {
++	if ((dev->type == ARPHRD_ETHER) && (dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V6_TAP)) {
+ 		cmsg->mode = NSS_GRE_MODE_TAP;
+ 		cmsg->ip_type = NSS_GRE_IP_IPV6;
+ 		if (enable_unalign) {
+@@ -605,7 +603,7 @@ static bool nss_connmgr_gre_is_gre(struct net_device *dev)
+ {
+ 	if ((dev->type == ARPHRD_IPGRE) ||
+ 	      (dev->type == ARPHRD_IP6GRE) || ((dev->type == ARPHRD_ETHER) &&
+-	      (dev->priv_flags & (IFF_GRE_V4_TAP | IFF_GRE_V6_TAP)))) {
++	      (dev->priv_flags_qca_ecm & (IFF_QCA_ECM_GRE_V4_TAP | IFF_QCA_ECM_GRE_V6_TAP)))) {
+ 		return true;
+ 	}
+ 
+@@ -692,10 +690,10 @@ static struct net_device *__nss_connmgr_gre_create_interface(struct nss_connmgr_
+ 		nss_connmgr_gre_tap_setup(dev);
+ 
+ 		if (cfg->is_ipv6) {
+-			dev->priv_flags |= IFF_GRE_V6_TAP;
++			dev->priv_flags_qca_ecm |= IFF_QCA_ECM_GRE_V6_TAP;
+ 			ret = nss_connmgr_gre_v6_set_config(dev, cfg);
+ 		} else {
+-			dev->priv_flags |= IFF_GRE_V4_TAP;
++			dev->priv_flags_qca_ecm |= IFF_QCA_ECM_GRE_V4_TAP;
+ 			ret = nss_connmgr_gre_v4_set_config(dev, cfg);
+ 		}
+ 		break;
+diff --git a/gre/nss_connmgr_gre_v6.c b/gre/nss_connmgr_gre_v6.c
+index f9a8e58..e93c7e4 100644
+--- a/gre/nss_connmgr_gre_v6.c
++++ b/gre/nss_connmgr_gre_v6.c
+@@ -46,7 +46,7 @@ static struct net_device *nss_connmgr_gre_v6_get_tx_dev(uint8_t *dest_ip)
+ 	struct net_device *dev;
+ 
+ 	memcpy(ipv6_addr.s6_addr, dest_ip, 16);
+-	rt = rt6_lookup(&init_net, &ipv6_addr, NULL, 0, 0);
++	rt = rt6_lookup(&init_net, &ipv6_addr, NULL, 0, NULL, 0);
+ 	if (!rt) {
+ 		return NULL;
+ 	}
+@@ -92,7 +92,7 @@ static int nss_connmgr_gre_v6_get_mac_address(uint8_t *src_ip, uint8_t *dest_ip,
+ 	 * Find dest MAC address
+ 	 */
+ 	memcpy(ipv6_addr.s6_addr, dest_ip, 16);
+-	rt = rt6_lookup(&init_net, &ipv6_addr, NULL, 0, 0);
++	rt = rt6_lookup(&init_net, &ipv6_addr, NULL, 0, NULL, 0);
+ 	if (!rt) {
+ 		return GRE_ERR_NEIGH_LOOKUP;
+ 	}
+-- 
+2.27.0
+
diff --git a/package/qca/qca-nss-clients/patches/102-kernel-5.4-support-ipsec.patch b/package/qca/qca-nss-clients/patches/102-kernel-5.4-support-ipsec.patch
new file mode 100644
index 0000000000..de43b4d01d
--- /dev/null
+++ b/package/qca/qca-nss-clients/patches/102-kernel-5.4-support-ipsec.patch
@@ -0,0 +1,29 @@
+--- a/ipsecmgr/v1.0/nss_ipsecmgr.c
++++ b/ipsecmgr/v1.0/nss_ipsecmgr.c
+@@ -377,7 +377,7 @@ free:
+  * nss_ipsecmgr_tunnel_stats()
+  * 	get tunnel statistics
+  */
+-static struct rtnl_link_stats64 *nss_ipsecmgr_tunnel_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
++void nss_ipsecmgr_tunnel_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)
+ {
+ 	struct nss_ipsecmgr_priv *priv = netdev_priv(dev);
+ 
+@@ -389,8 +389,6 @@ static struct rtnl_link_stats64 *nss_ips
+ 	read_lock_bh(&ipsecmgr_ctx->lock);
+ 	memcpy(stats, &priv->stats, sizeof(struct rtnl_link_stats64));
+ 	read_unlock_bh(&ipsecmgr_ctx->lock);
+-
+-	return stats;
+ }
+ 
+ /*
+@@ -442,7 +440,7 @@ static void nss_ipsecmgr_tunnel_setup(st
+ 	dev->header_ops = NULL;
+ 	dev->netdev_ops = &nss_ipsecmgr_tunnel_ops;
+ 
+-	dev->destructor = nss_ipsecmgr_tunnel_free;
++	dev->priv_destructor = nss_ipsecmgr_tunnel_free;
+ 
+ 	/*
+ 	 * get the MAC address from the ethernet device
diff --git a/package/qca/qca-nss-clients/patches/103-kernel-5.4-support-dtls.patch b/package/qca/qca-nss-clients/patches/103-kernel-5.4-support-dtls.patch
new file mode 100644
index 0000000000..ae9c914701
--- /dev/null
+++ b/package/qca/qca-nss-clients/patches/103-kernel-5.4-support-dtls.patch
@@ -0,0 +1,11 @@
+--- a/dtls/v1.0/nss_connmgr_dtls_netdev.c
++++ b/dtls/v1.0/nss_connmgr_dtls_netdev.c
+@@ -160,7 +160,7 @@ static void nss_dtlsmgr_dev_setup(struct
+ 	dev->ethtool_ops = NULL;
+ 	dev->header_ops = NULL;
+ 	dev->netdev_ops = &nss_dtlsmgr_session_ops;
+-	dev->destructor = NULL;
++	dev->priv_destructor = NULL;
+ 
+ 	memcpy(dev->dev_addr, "\xaa\xbb\xcc\xdd\xee\xff", dev->addr_len);
+ 	memset(dev->broadcast, 0xff, dev->addr_len);
diff --git a/package/qca/qca-nss-clients/patches/104-kernel-5.4-support-l2tp.patch b/package/qca/qca-nss-clients/patches/104-kernel-5.4-support-l2tp.patch
new file mode 100644
index 0000000000..c637235cc8
--- /dev/null
+++ b/package/qca/qca-nss-clients/patches/104-kernel-5.4-support-l2tp.patch
@@ -0,0 +1,64 @@
+--- a/l2tp/l2tpv2/nss_connmgr_l2tpv2.h
++++ b/l2tp/l2tpv2/nss_connmgr_l2tpv2.h
+@@ -30,10 +30,10 @@
+ 
+ #define L2TP_V_2 2
+ 
+-#define tunnel_hold(tunnel) atomic_inc(&tunnel->ref_count)
+-#define tunnel_put(tunnel)  atomic_dec(&tunnel->ref_count)
+-#define session_hold(session) atomic_inc(&session->ref_count)
+-#define session_put(session)  atomic_dec(&session->ref_count)
++#define tunnel_hold(tunnel) refcount_inc(&tunnel->ref_count)
++#define tunnel_put(tunnel)  refcount_dec(&tunnel->ref_count)
++#define session_hold(session) refcount_inc(&session->ref_count)
++#define session_put(session)  refcount_dec(&session->ref_count)
+ 
+  /*
+   *		----------------------------------------------------------------------------------
+--- a/l2tp/l2tpv2/nss_connmgr_l2tpv2.c
++++ b/l2tp/l2tpv2/nss_connmgr_l2tpv2.c
+@@ -244,7 +244,7 @@ static struct nss_connmgr_l2tpv2_session
+ 	 */
+ 	data->l2tpv2.session.session_id = session->session_id;
+ 	data->l2tpv2.session.peer_session_id = session->peer_session_id;
+-	data->l2tpv2.session.offset = session->offset;
++	data->l2tpv2.session.offset = 0;
+ 	data->l2tpv2.session.hdr_len = session->hdr_len;
+ 	data->l2tpv2.session.reorder_timeout = session->reorder_timeout;
+ 	data->l2tpv2.session.recv_seq = session->recv_seq;
+@@ -253,7 +253,7 @@ static struct nss_connmgr_l2tpv2_session
+ 	nss_connmgr_l2tpv2_info("sess %u, peer=%u nr=%u ns=%u off=%u  hdr_len=%u timeout=%x"
+ 	       " recv_seq=%x send_seq=%x\n",
+ 	       session->session_id,  session->peer_session_id, session->nr,
+-	       session->ns,  session->offset, session->hdr_len,
++	       session->ns, 0, session->hdr_len,
+ 	       session->reorder_timeout, session->recv_seq,
+ 	       session->send_seq);
+ 
+--- a/l2tp/l2tpv2/nss_l2tpv2_stats.c
++++ b/l2tp/l2tpv2/nss_l2tpv2_stats.c
+@@ -21,6 +21,7 @@
+  */
+ 
+ #include <linux/types.h>
++#include <linux/netdevice.h>
+ #include <linux/ppp_channel.h>
+ #include <nss_api_if.h>
+ #include <nss_dynamic_interface.h>
+@@ -103,14 +104,14 @@ void nss_l2tpv2_update_dev_stats(struct
+ 	/*
+ 	 * Update tunnel & session stats
+ 	 */
+-	tunnel = l2tp_tunnel_find(dev_net(dev), data.l2tpv2.tunnel.tunnel_id);
++	tunnel = l2tp_tunnel_get(dev_net(dev), data.l2tpv2.tunnel.tunnel_id);
+ 	if (!tunnel) {
+ 		dev_put(dev);
+ 		return;
+ 	}
+ 	tunnel_hold(tunnel);
+ 
+-	session = l2tp_session_find(dev_net(dev), tunnel, data.l2tpv2.session.session_id);
++	session = l2tp_session_get(dev_net(dev), data.l2tpv2.session.session_id);
+ 	if (!session) {
+ 		tunnel_put(tunnel);
+ 		dev_put(dev);
diff --git a/package/qca/qca-nss-clients/patches/200-qdisc-fix-compile-error.patch b/package/qca/qca-nss-clients/patches/200-qdisc-fix-compile-error.patch
new file mode 100644
index 0000000000..4e147489b9
--- /dev/null
+++ b/package/qca/qca-nss-clients/patches/200-qdisc-fix-compile-error.patch
@@ -0,0 +1,14 @@
+--- a/nss_qdisc/nss_qdisc.c
++++ b/nss_qdisc/nss_qdisc.c
+@@ -2708,9 +2708,11 @@ static int nss_qdisc_if_event_cb(struct
+ 	case NETDEV_BR_JOIN:
+ 		nss_qdisc_info("Reveived NETDEV_BR_JOIN on interface %s\n",
+ 				dev->name);
++		goto fall_through;
+ 	case NETDEV_BR_LEAVE:
+ 		nss_qdisc_info("Reveived NETDEV_BR_LEAVE on interface %s\n",
+ 				dev->name);
++fall_through:
+ 		br = nss_qdisc_get_dev_master(dev);
+ 		if_num = nss_cmn_get_interface_number(nss_qdisc_ctx, dev);
+ 
diff --git a/package/qca/qca-nss-clients/patches/202-vlanmgr-fix-compile-error.patch b/package/qca/qca-nss-clients/patches/202-vlanmgr-fix-compile-error.patch
new file mode 100644
index 0000000000..53af319244
--- /dev/null
+++ b/package/qca/qca-nss-clients/patches/202-vlanmgr-fix-compile-error.patch
@@ -0,0 +1,48 @@
+--- a/vlan/nss_vlan_mgr.c
++++ b/vlan/nss_vlan_mgr.c
+@@ -820,8 +820,10 @@ static struct nss_vlan_pvt *nss_vlan_mgr
+  */
+ static void nss_vlan_mgr_instance_free(struct nss_vlan_pvt *v)
+ {
++#ifdef NSS_VLAN_MGR_PPE_SUPPORT
+ 	int32_t i;
+ 	int ret = 0;
++#endif
+ 
+ 	spin_lock(&vlan_mgr_ctx.lock);
+ 	BUG_ON(--v->refs);
+@@ -979,8 +981,11 @@ static int nss_vlan_mgr_register_event(s
+ 	int ret;
+ #endif
+ 	uint32_t vlan_tag;
++#ifdef NSS_VLAN_MGR_PPE_SUPPORT
+ 	struct net_device *slave;
+-	int32_t port, port_if;
++	int32_t port;
++#endif
++	int32_t port_if;
+ 	struct vlan_dev_priv *vlan;
+ 	struct net_device *real_dev;
+ 	bool is_bond_master = false;
+@@ -1354,8 +1359,10 @@ return_with_error:
+ int nss_vlan_mgr_join_bridge(struct net_device *dev, uint32_t bridge_vsi)
+ {
+ 	struct nss_vlan_pvt *v = nss_vlan_mgr_instance_find_and_ref(dev);
++#ifdef NSS_VLAN_MGR_PPE_SUPPORT
+ 	struct net_device *real_dev;
+ 	int ret;
++#endif
+ 
+ 	if (!v)
+ 		return 0;
+@@ -1415,8 +1422,10 @@ EXPORT_SYMBOL(nss_vlan_mgr_join_bridge);
+ int nss_vlan_mgr_leave_bridge(struct net_device *dev, uint32_t bridge_vsi)
+ {
+ 	struct nss_vlan_pvt *v = nss_vlan_mgr_instance_find_and_ref(dev);
++#ifdef NSS_VLAN_MGR_PPE_SUPPORT
+ 	struct net_device *real_dev;
+ 	int ret;
++#endif
+ 
+ 	if (!v)
+ 		return 0;
diff --git a/package/qca/qca-nss-crypto/Makefile b/package/qca/qca-nss-crypto/Makefile
new file mode 100644
index 0000000000..09a16232b6
--- /dev/null
+++ b/package/qca/qca-nss-crypto/Makefile
@@ -0,0 +1,74 @@
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=qca-nss-crypto
+PKG_RELEASE:=1
+
+PKG_SOURCE_URL:=https://source.codeaurora.org/quic/qsdk/oss/lklm/nss-crypto
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_VERSION:=e7651c2986d30b5e8ca5ad6b9a72c47febdf3cca
+
+include $(INCLUDE_DIR)/package.mk
+
+ifeq ($(CONFIG_TARGET_ipq),y)
+subtarget:=$(SUBTARGET)
+else
+subtarget:=$(CONFIG_TARGET_BOARD)
+endif
+
+# v1.0 is for Akronite
+# v2.0 is for Hawkeye/Cypress/Maple
+ifneq (, $(findstring $(subtarget), "ipq807x" "ipq807x_64" "ipq60xx" "ipq60xx_64" "ipq50xx" "ipq50xx_64"))
+NSS_CRYPTO_DIR:=v2.0
+else
+NSS_CRYPTO_DIR:=v1.0
+endif
+
+define KernelPackage/qca-nss-crypto/Default
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  DEPENDS:=@TARGET_ipq806x||TARGET_ipq_ipq806x||TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq807x||TARGET_ipq807x_64||TARGET_ipq_ipq50xx||TARGET_ipq_ipq50xx_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64 \
+		+kmod-qca-nss-drv @!LINUX_3_18
+endef
+
+define KernelPackage/qca-nss-crypto
+  $(call KernelPackage/qca-nss-crypto/Default)
+  TITLE:=Kernel driver for NSS crypto driver
+  FILES:=$(PKG_BUILD_DIR)/$(NSS_CRYPTO_DIR)/src/qca-nss-crypto.ko \
+	$(PKG_BUILD_DIR)/$(NSS_CRYPTO_DIR)/tool/qca-nss-crypto-tool.ko
+  AUTOLOAD:=$(call AutoLoad,52,qca-nss-crypto)
+endef
+
+define KernelPackage/qca-nss-crypto/Description
+This package contains a NSS crypto driver for QCA chipset
+endef
+
+define Build/InstallDev/qca-nss-crypto
+	$(INSTALL_DIR) $(1)/usr/include/qca-nss-crypto
+	$(CP) $(PKG_BUILD_DIR)/$(NSS_CRYPTO_DIR)/include/* $(1)/usr/include/qca-nss-crypto
+endef
+
+define Build/InstallDev
+	$(call Build/InstallDev/qca-nss-crypto,$(1))
+endef
+
+EXTRA_CFLAGS+= \
+	-DCONFIG_NSS_DEBUG_LEVEL=4 \
+	-I$(STAGING_DIR)/usr/include/qca-nss-crypto \
+	-I$(STAGING_DIR)/usr/include/qca-nss-drv \
+	-I$(PKG_BUILD_DIR)/$(NSS_CRYPTO_DIR)/include \
+	-I$(PKG_BUILD_DIR)/$(NSS_CRYPTO_DIR)/src
+
+define Build/Compile
+	$(MAKE) $(PKG_JOBS) -C "$(LINUX_DIR)" \
+		$(KERNEL_MAKE_FLAGS) \
+		$(PKG_MAKE_FLAGS) \
+		M="$(PKG_BUILD_DIR)" \
+		EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
+		NSS_CRYPTO_DIR=$(NSS_CRYPTO_DIR) \
+		SoC="$(subtarget)" \
+		modules
+endef
+
+$(eval $(call KernelPackage,qca-nss-crypto))
diff --git a/package/qca/qca-nss-crypto/patches/100-kernel-5.4-support.patch b/package/qca/qca-nss-crypto/patches/100-kernel-5.4-support.patch
new file mode 100644
index 0000000000..b9ef6191eb
--- /dev/null
+++ b/package/qca/qca-nss-crypto/patches/100-kernel-5.4-support.patch
@@ -0,0 +1,42 @@
+--- a/v1.0/tool/nss_crypto_bench.c
++++ b/v1.0/tool/nss_crypto_bench.c
+@@ -75,8 +75,8 @@ static DECLARE_WAIT_QUEUE_HEAD(tx_comp);
+ static DECLARE_WAIT_QUEUE_HEAD(tx_start);
+ static struct task_struct *tx_thread = NULL;
+ 
+-static struct timeval init_time;
+-static struct timeval comp_time;
++static struct timespec64 init_time;
++static struct timespec64 comp_time;
+ static spinlock_t op_lock;
+ static nss_crypto_handle_t crypto_hdl;
+ 
+@@ -782,7 +782,7 @@ static int crypto_bench_tx(void *arg)
+ 		crypto_bench_debug("#");
+ 
+ 		/* get start time */
+-		do_gettimeofday(&init_time);
++		ktime_get_real_ts64(&init_time);
+ 
+ 		/**
+ 		 * Request submission
+@@ -812,8 +812,8 @@ static int crypto_bench_tx(void *arg)
+ 		 * Calculate time and output the Mbps
+ 		 */
+ 
+-		init_usecs  = (init_time.tv_sec * 1000 * 1000) + init_time.tv_usec;
+-		comp_usecs  = (comp_time.tv_sec * 1000 * 1000) + comp_time.tv_usec;
++		init_usecs  = (init_time.tv_sec * 1000 * 1000) + (init_time.tv_nsec / NSEC_PER_USEC);
++		comp_usecs  = (comp_time.tv_sec * 1000 * 1000) + (comp_time.tv_nsec / NSEC_PER_USEC);
+ 		delta_usecs = comp_usecs - init_usecs;
+ 
+ 		reqs_completed = param.num_reqs - atomic_read(&tx_reqs);
+@@ -870,7 +870,7 @@ static void crypto_bench_done(struct nss
+ 	nss_crypto_buf_free(crypto_hdl, buf);
+ 
+ 	if (atomic_dec_and_test(&tx_reqs)) {
+-		do_gettimeofday(&comp_time);
++		ktime_get_real_ts64(&comp_time);
+ 
+ 		wake_up_interruptible(&tx_comp);
+ 		param.num_loops--;
diff --git a/package/qca/qca-nss-crypto/patches/200-fix-NULL-pointer-exception.patch b/package/qca/qca-nss-crypto/patches/200-fix-NULL-pointer-exception.patch
new file mode 100644
index 0000000000..6bd95109a7
--- /dev/null
+++ b/package/qca/qca-nss-crypto/patches/200-fix-NULL-pointer-exception.patch
@@ -0,0 +1,57 @@
+--- a/v1.0/src/nss_crypto_if.c
++++ b/v1.0/src/nss_crypto_if.c
+@@ -370,15 +370,16 @@ void nss_crypto_transform_done(struct ne
+ 	struct nss_crypto_buf *buf = (struct nss_crypto_buf *)skb->data;
+ 	struct nss_crypto_buf_node *entry;
+ 	void *addr;
++	struct device *cdev = gbl_crypto_ctrl.eng[0].dev;
+ 
+ 	if (likely(buf->data_in == buf->data_out)) {
+-		dma_unmap_single(NULL, buf->data_in, buf->data_len, DMA_BIDIRECTIONAL);
++		dma_unmap_single(cdev, buf->data_in, buf->data_len, DMA_BIDIRECTIONAL);
+ 	} else {
+-		dma_unmap_single(NULL, buf->data_in, buf->data_len, DMA_TO_DEVICE);
+-		dma_unmap_single(NULL, buf->data_out, buf->data_len, DMA_FROM_DEVICE);
++		dma_unmap_single(cdev, buf->data_in, buf->data_len, DMA_TO_DEVICE);
++		dma_unmap_single(cdev, buf->data_out, buf->data_len, DMA_FROM_DEVICE);
+ 	}
+ 
+-	dma_unmap_single(NULL, buf->iv_addr,  L1_CACHE_BYTES, DMA_BIDIRECTIONAL);
++	dma_unmap_single(cdev, buf->iv_addr,  L1_CACHE_BYTES, DMA_BIDIRECTIONAL);
+ 
+ 	addr = phys_to_virt(buf->iv_addr);
+ 	entry = container_of(addr, struct nss_crypto_buf_node, results);
+@@ -531,6 +532,7 @@ nss_crypto_status_t nss_crypto_transform
+ 	uint32_t paddr;
+ 	void *vaddr;
+ 	size_t len;
++	struct device *cdev = gbl_crypto_ctrl.eng[0].dev;
+ 
+ 	if (!buf->cb_fn) {
+ 		nss_crypto_warn("%p:no buffer(%p) callback present\n", crypto, buf);
+@@ -544,7 +546,7 @@ nss_crypto_status_t nss_crypto_transform
+ 	 */
+ 	vaddr = (void *)buf->data_in;
+ 	len = buf->data_len;
+-	paddr = dma_map_single(NULL, vaddr, len, DMA_TO_DEVICE);
++	paddr = dma_map_single(cdev, vaddr, len, DMA_TO_DEVICE);
+ 	buf->data_in = paddr;
+ 
+ 	if (vaddr == (void *)buf->data_out) {
+@@ -555,14 +557,14 @@ nss_crypto_status_t nss_crypto_transform
+ 		 */
+ 		vaddr = (void *)buf->data_out;
+ 		len = buf->data_len;
+-		paddr = dma_map_single(NULL, vaddr, len, DMA_FROM_DEVICE);
++		paddr = dma_map_single(cdev, vaddr, len, DMA_FROM_DEVICE);
+ 		buf->data_out = paddr;
+ 	}
+ 
+ 	/*
+ 	 * We need to map the results into IV
+ 	 */
+-	paddr = dma_map_single(NULL, entry->results, L1_CACHE_BYTES, DMA_BIDIRECTIONAL);
++	paddr = dma_map_single(cdev, entry->results, L1_CACHE_BYTES, DMA_BIDIRECTIONAL);
+ 	buf->hash_addr = paddr;
+ 	buf->iv_addr = paddr;
+ 
diff --git a/package/qca/qca-nss-drv/Makefile b/package/qca/qca-nss-drv/Makefile
new file mode 100644
index 0000000000..931697746c
--- /dev/null
+++ b/package/qca/qca-nss-drv/Makefile
@@ -0,0 +1,124 @@
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=qca-nss-drv
+PKG_RELEASE:=2
+
+PKG_SOURCE_URL:=https://source.codeaurora.org/quic/qsdk/oss/lklm/nss-drv
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_VERSION:=809a00deffe9f3d4ecd15965790a152757073437
+
+NSS_CLIENTS_DIR:=$(TOPDIR)/qca/src/qca-nss-clients
+
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/qca-nss-drv
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  DEPENDS:=@TARGET_ipq806x||TARGET_ipq_ipq806x||TARGET_ipq_ipq807x||TARGET_ipq_ipq807x_64||TARGET_ipq807x||TARGET_ipq807x_64||TARGET_ipq_ipq60xx||TARGET_ipq_ipq60xx_64||TARGET_ipq_ipq50xx||TARGET_ipq_ipq50xx_64 \
+		+PACKAGE_kmod-qca-nss-gmac:kmod-qca-nss-gmac @!LINUX_3_18
+  TITLE:=Kernel driver for NSS (core driver)
+  FILES:=$(PKG_BUILD_DIR)/qca-nss-drv.ko
+  AUTOLOAD:=$(call AutoLoad,32,qca-nss-drv)
+endef
+
+define KernelPackage/qca-nss-drv/install
+	$(INSTALL_DIR) $(1)/lib/debug
+	$(INSTALL_DIR) $(1)/etc/init.d
+	$(INSTALL_DIR) $(1)/etc/sysctl.d
+	$(INSTALL_DIR) $(1)/etc/hotplug.d/firmware
+	$(INSTALL_DIR) $(1)/etc/config
+	$(INSTALL_DIR) $(1)/lib/firmware
+
+	$(INSTALL_BIN) ./files/qca-nss-drv.debug $(1)/lib/debug/qca-nss-drv
+	$(INSTALL_BIN) ./files/qca-nss-drv.init $(1)/etc/init.d/qca-nss-drv
+	$(INSTALL_BIN) ./files/qca-nss-drv.sysctl $(1)/etc/sysctl.d/qca-nss-drv.conf
+	$(INSTALL_BIN) ./files/qca-nss-drv.hotplug $(1)/etc/hotplug.d/firmware/10-qca-nss-fw
+	$(INSTALL_BIN) ./files/qca-nss-drv.conf $(1)/etc/config/nss
+	$(INSTALL_BIN) ./files/nss-firmware/qca-nss0-retail.bin $(1)/lib/firmware/qca-nss0.bin
+	$(INSTALL_BIN) ./files/nss-firmware/qca-nss1-retail.bin $(1)/lib/firmware/qca-nss1.bin
+
+endef
+
+define KernelPackage/qca-nss-drv/Description
+This package contains a NSS driver for QCA chipset
+endef
+
+define Build/InstallDev
+	mkdir -p $(1)/usr/include/qca-nss-drv
+	$(CP) $(PKG_BUILD_DIR)/exports/* $(1)/usr/include/qca-nss-drv/
+ifneq (, $(findstring $(subtarget), "ipq807x" "ipq807x_64" "ipq60xx" "ipq60xx_64" "ipq50xx" "ipq50xx_64"))
+	$(RM) $(1)/usr/include/qca-nss-drv/nss_ipsecmgr.h
+	$(INSTALL_DIR) $(1)/usr/include/qca-nss-clients
+	$(CP) $(NSS_CLIENTS_DIR)/exports/nss_ipsecmgr.h $(1)/usr/include/qca-nss-clients/.
+endif
+endef
+
+EXTRA_CFLAGS+= -I$(STAGING_DIR)/usr/include/qca-nss-gmac
+
+# Keeping default as ipq806x for branches that does not have subtarget framework
+ifeq ($(CONFIG_TARGET_ipq),y)
+subtarget:=$(SUBTARGET)
+else
+subtarget:=$(CONFIG_TARGET_BOARD)
+endif
+
+ifeq ($(CONFIG_KERNEL_IPQ_MEM_PROFILE),256)
+EXTRA_CFLAGS+= -DNSS_MEM_PROFILE_LOW
+endif
+
+ifeq ($(CONFIG_KERNEL_IPQ_MEM_PROFILE),512)
+EXTRA_CFLAGS+= -DNSS_MEM_PROFILE_MEDIUM
+endif
+
+ifeq ($(CONFIG_KERNEL_SKB_FIXED_SIZE_2K),y)
+EXTRA_CFLAGS+= -DNSS_SKB_FIXED_SIZE_2K
+endif
+
+DRV_MAKE_OPTS:=
+ifeq ($(CONFIG_KERNEL_IPQ_MEM_PROFILE),256)
+DRV_MAKE_OPTS+=NSS_DRV_C2C_ENABLE=n \
+        NSS_DRV_CAPWAP_ENABLE=n \
+        NSS_DRV_CLMAP_ENABLE=n \
+        NSS_DRV_CRYPTO_ENABLE=n \
+        NSS_DRV_DTLS_ENABLE=n \
+        NSS_DRV_GRE_ENABLE=n \
+        NSS_DRV_GRE_REDIR_ENABLE=n \
+        NSS_DRV_GRE_TUNNEL_ENABLE=n \
+        NSS_DRV_IGS_ENABLE=n \
+        NSS_DRV_IPSEC_ENABLE=n \
+        NSS_DRV_LAG_ENABLE=n \
+        NSS_DRV_L2TP_ENABLE=n \
+        NSS_DRV_MAPT_ENABLE=n \
+        NSS_DRV_OAM_ENABLE=n \
+        NSS_DRV_PPTP_ENABLE=n \
+        NSS_DRV_PORTID_ENABLE=n \
+        NSS_DRV_PVXLAN_ENABLE=n \
+        NSS_DRV_QRFS_ENABLE=n \
+        NSS_DRV_QVPN_ENABLE=n \
+        NSS_DRV_RMNET_ENABLE=n \
+        NSS_DRV_SHAPER_ENABLE=n \
+        NSS_DRV_SJACK_ENABLE=n \
+        NSS_DRV_TLS_ENABLE=n \
+        NSS_DRV_TRUSTSEC_ENABLE=n \
+        NSS_DRV_TSTAMP_ENABLE=n \
+        NSS_DRV_TUN6RD_ENABLE=n \
+        NSS_DRV_TUNIPIP6_ENABLE=n \
+        NSS_DRV_VXLAN_ENABLE=n
+endif
+
+define Build/Configure
+	$(LN) arch/nss_$(subtarget).h $(PKG_BUILD_DIR)/exports/nss_arch.h
+endef
+
+define Build/Compile
+	$(MAKE)  $(PKG_JOBS) -C "$(LINUX_DIR)" $(strip $(DRV_MAKE_OPTS)) \
+		$(KERNEL_MAKE_FLAGS) \
+		$(PKG_MAKE_FLAGS) \
+		M="$(PKG_BUILD_DIR)" \
+		EXTRA_CFLAGS="$(EXTRA_CFLAGS)" SoC="$(subtarget)" \
+		modules
+endef
+
+$(eval $(call KernelPackage,qca-nss-drv))
diff --git a/package/qca/qca-nss-drv/files/nss-firmware/LICENSE.TXT b/package/qca/qca-nss-drv/files/nss-firmware/LICENSE.TXT
new file mode 100644
index 0000000000..41631989a0
--- /dev/null
+++ b/package/qca/qca-nss-drv/files/nss-firmware/LICENSE.TXT
@@ -0,0 +1,45 @@
+Copyright (c) 2014 Qualcomm Atheros, Inc.
+
+All rights reserved.
+
+Redistribution and use in binary forms, without
+modification, are permitted (subject to the limitations in the
+disclaimer below) provided that the following conditions are met:
+
+*Redistributions must reproduce the above copyright
+ notice, this list of conditions, and the following disclaimer in the
+ documentation and/or other materials provided with the distribution.
+
+*Neither the name of Qualcomm Atheros, Inc. nor the names of its
+ contributors may be used to endorse or promote products derived
+ from this software without specific prior written permission.
+
+*No Reverse engineering, decompiling, decrypting, or disassembling of this
+ software is permitted.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. NO LICENSES OR OTHER RIGHTS,
+WHETHER EXPRESS, IMPLIED, BASED ON ESTOPPEL OR OTHERWISE, ARE GRANTED
+TO ANY PARTY'S PATENTS, PATENT APPLICATIONS, OR PATENTABLE INVENTIONS
+BY VIRTUE OF THIS LICENSE OR THE DELIVERY OR PROVISION BY QUALCOMM
+ATHEROS, INC. OF THE SOFTWARE.
+
+IN NO EVENT SHALL THE COPYRIGHT OWNER OR ANY CONTRIBUTOR BE LIABLE FOR
+ANY INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND REGARDLESS OF ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+OTHERWISE) ARISING IN ANY WAY OUT OF OR RESULTING FROM THE USE OF THE
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY
+EVENT, THE TOTAL AGGREGATE LIABILITY THAT MAY BE IMPOSED ON QUALCOMM
+ATHEROS, INC. FOR ANY DIRECT DAMAGES ARISING UNDER OR RESULTING FROM
+THIS AGREEMENT OR IN CONNECTION WITH ANY USE OF THE SOFTWARE SHALL NOT
+EXCEED A TOTAL AMOUNT OF US$5.00.
+
+IF ANY OF THE ABOVE PROVISIONS ARE HELD TO BE VOID, INVALID,
+UNENFORCEABLE, OR ILLEGAL, THE OTHER PROVISIONS SHALL CONTINUE IN FULL
+FORCE AND EFFECT.
+
diff --git a/package/qca/qca-nss-drv/files/nss-firmware/NOTICE.TXT b/package/qca/qca-nss-drv/files/nss-firmware/NOTICE.TXT
new file mode 100644
index 0000000000..ab54aa019c
--- /dev/null
+++ b/package/qca/qca-nss-drv/files/nss-firmware/NOTICE.TXT
@@ -0,0 +1,217 @@
+=============================================================================
+
+This Notice.txt file contains certain notices of software components included
+with the software that Qualcomm Atheros, Inc. ("Qualcomm Atheros") is required
+to provide you. Except where prohibited by the open source license, the content
+of this notices file is only provided to satisfy Qualcomm Atheros's attribution
+and notice requirement; your use of these software components together with the
+Qualcomm Atheros software (Qualcomm Atheros software hereinafter referred to as
+"Software") is subject to the terms of your license from Qualcomm Atheros.
+Compliance with all copyright laws and software license agreements included in
+the notice section of this file are the responsibility of the user.  Except as
+may be granted by separate express written agreement, this file provides no
+license to any Qualcomm Atheros patents, trademarks, copyrights, or other
+intellectual property.
+
+Copyright (c) 2014 Qualcomm Atheros, Inc.  All rights reserved.
+
+Qualcomm is a trademark of Qualcomm Incorporated, registered in the United
+States and other countries.  All Qualcomm Incorporated trademarks are used with
+permission.  Atheros is a trademark of Qualcomm Atheros, Inc., registered in the
+United States and other countries.  Other products and brand names may be
+trademarks or registered trademarks of their respective owners.
+
+NOTICES:
+
+=============================================================================
+
+/*
+ * doprint.c
+ *      Formatted string print support.
+ *
+ * Copyright <A9> 2001-2012 Qualcomm Atheros, Inc.  All Rights Reserved.
+ *
+ * Qualcomm Atheros Confidential and Proprietary.
+ *
+ * This code originates with BSD Unix however it has been extensively
+ * modified.  The original copyright is reproduced below:
+ *
+ * Copyright (c) 1988 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted provided
+ * that: (1) source distributions retain this entire copyright notice and
+ * comment, and (2) distributions including binaries display the following
+ * acknowledgement:  ``This product includes software developed by the
+ * University of California, Berkeley and its contributors'' in the
+ * documentation or other materials provided with the distribution and in
+ * all advertising materials mentioning features or use of this software.
+ * Neither the name of the University nor the names of its contributors may
+ * be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/*
+ * math.c
+ *      Support for the standard C library.
+ *
+ * Copyright <A9> 2006-2012 Qualcomm Atheros, Inc.  All Rights Reserved.
+ *
+ * Qualcomm Atheros Confidential and Proprietary.
+ *
+ * Software contained within this file was originally released with the
+ * following
+ * copyright and license statement:
+ *
+ * ====================================================
+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
+ *
+ * Developed at SunPro, a Sun Microsystems, Inc. business.
+ * Permission to use, copy, modify, and distribute this
+ * software is freely granted, provided that this notice
+ * is preserved.
+ * ====================================================
+ */
+
+
+/*
+ * stdlib.c
+ *      Routines from stdlib.h.
+ *
+ * Copyright <A9> 2004-2012 Qualcomm Atheros, Inc.  All Rights Reserved.
+ *
+ * Qualcomm Atheros Confidential and Proprietary.
+ *
+ * The code for strtol() and strtoul() are also subject to the following:
+ *
+ * Copyright (c) 1990, 1993
+ *      The Regents of the University of California. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by the University of
+ *      California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+drr_alg_utils.h:
+/****************************************************************************/
+/*-
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+shaper_list_utils.h:
+/****************************************************************************/
+/*-
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+codel_alg_inv_sqrt.h
+/****************************************************************************/
+/*-
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
diff --git a/package/qca/qca-nss-drv/files/nss-firmware/README.md b/package/qca/qca-nss-drv/files/nss-firmware/README.md
new file mode 100644
index 0000000000..2d0b47508a
--- /dev/null
+++ b/package/qca/qca-nss-drv/files/nss-firmware/README.md
@@ -0,0 +1,10 @@
+NSS FIRMWARE
+============
+
+This repo contains firmware files to enable the NSS MAC on QCA IPQ806x SoC.
+
+This product includes software developed by the University of California,
+Berkeley and its contributors.
+
+NSS firmware extracted from Synology RT2600ac SRM 1.2 - Version: 1.2-7742-4
+
diff --git a/package/qca/qca-nss-drv/files/nss-firmware/qca-nss0-retail.bin b/package/qca/qca-nss-drv/files/nss-firmware/qca-nss0-retail.bin
new file mode 100644
index 0000000000..08f6efe6c8
Binary files /dev/null and b/package/qca/qca-nss-drv/files/nss-firmware/qca-nss0-retail.bin differ
diff --git a/package/qca/qca-nss-drv/files/nss-firmware/qca-nss1-retail.bin b/package/qca/qca-nss-drv/files/nss-firmware/qca-nss1-retail.bin
new file mode 100644
index 0000000000..e79510f34d
Binary files /dev/null and b/package/qca/qca-nss-drv/files/nss-firmware/qca-nss1-retail.bin differ
diff --git a/package/qca/qca-nss-drv/files/qca-nss-drv.conf b/package/qca/qca-nss-drv/files/qca-nss-drv.conf
new file mode 100644
index 0000000000..a8a1fbf406
--- /dev/null
+++ b/package/qca/qca-nss-drv/files/qca-nss-drv.conf
@@ -0,0 +1,6 @@
+config nss_firmware 'qca_nss_0'
+
+config nss_firmware 'qca_nss_1'
+
+config general
+	option enable_rps	'1'
diff --git a/package/qca/qca-nss-drv/files/qca-nss-drv.debug b/package/qca/qca-nss-drv/files/qca-nss-drv.debug
new file mode 100644
index 0000000000..5d435c3a76
--- /dev/null
+++ b/package/qca/qca-nss-drv/files/qca-nss-drv.debug
@@ -0,0 +1,26 @@
+#!/bin/sh /sbin/sysdebug
+#
+# Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+#
+
+log cat /sys/kernel/debug/qca-nss-drv/stats/pppoe
+log cat /sys/kernel/debug/qca-nss-drv/stats/n2h
+log cat /sys/kernel/debug/qca-nss-drv/stats/ipv6
+log cat /sys/kernel/debug/qca-nss-drv/stats/ipv4
+log cat /sys/kernel/debug/qca-nss-drv/stats/gmac
+log cat /sys/kernel/debug/qca-nss-drv/stats/drv
+log cat /sys/kernel/debug/qca-nss-drv/stats/wifi
+log cat /sys/kernel/debug/qca-nss-drv/stats/wifi_if
+log cat /sys/kernel/debug/qca-nss-drv/stats/eth_rx
diff --git a/package/qca/qca-nss-drv/files/qca-nss-drv.hotplug b/package/qca/qca-nss-drv/files/qca-nss-drv.hotplug
new file mode 100644
index 0000000000..1e4813838c
--- /dev/null
+++ b/package/qca/qca-nss-drv/files/qca-nss-drv.hotplug
@@ -0,0 +1,70 @@
+#!/bin/sh
+#
+# Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+#
+
+KERNEL=`uname -r`
+case "${KERNEL}" in
+	3.4*)
+		select_or_load=load_nss_fw
+		;;
+	*)
+		select_or_load=select_nss_fw
+		;;
+esac
+
+load_nss_fw () {
+	ls -l $1 | awk ' { print $9,$5 } '> /dev/console
+	echo 1 > /sys/class/firmware/$DEVICENAME/loading
+	cat $1 > /sys/class/firmware/$DEVICENAME/data
+	echo 0 > /sys/class/firmware/$DEVICENAME/loading
+}
+
+select_nss_fw () {
+	rm -f /lib/firmware/$DEVICENAME
+	ln -s $1 /lib/firmware/$DEVICENAME
+	ls -l /lib/firmware/$DEVICENAME | awk ' { print $9,$5 } '> /dev/console
+}
+
+[ "$ACTION" != "add" ] && exit
+
+# dev name for UCI, since it doesn't let you use . or -
+SDEVNAME=$(echo ${DEVICENAME} | sed s/[.-]/_/g)
+
+SELECTED_FW=$(uci get nss.${SDEVNAME}.firmware 2>/dev/null)
+[ -e "${SELECTED_FW}" ] && {
+	$select_or_load ${SELECTED_FW}
+	exit
+}
+
+case $DEVICENAME in
+        qca-nss0* | qca-nss.0*)
+                if [ -e /lib/firmware/qca-nss0-enterprise.bin ] ; then
+                        $select_or_load /lib/firmware/qca-nss0-enterprise.bin
+                else
+                        $select_or_load /lib/firmware/qca-nss0-retail.bin
+                fi
+                exit
+                ;;
+        qca-nss1* | qca-nss.1*)
+                if [ -e /lib/firmware/qca-nss1-enterprise.bin ] ; then
+                        $select_or_load /lib/firmware/qca-nss1-enterprise.bin
+                else
+                        $select_or_load /lib/firmware/qca-nss1-retail.bin
+                fi
+                exit
+                ;;
+esac
+
diff --git a/package/qca/qca-nss-drv/files/qca-nss-drv.init b/package/qca/qca-nss-drv/files/qca-nss-drv.init
new file mode 100644
index 0000000000..de12cb6d12
--- /dev/null
+++ b/package/qca/qca-nss-drv/files/qca-nss-drv.init
@@ -0,0 +1,50 @@
+#!/bin/sh /etc/rc.common
+#
+# Copyright (c) 2015-2017, The Linux Foundation. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+#
+
+START=70
+
+enable_rps() {
+	irq_nss_rps=`grep nss_queue1 /proc/interrupts | cut -d ':' -f 1 | tr -d ' '`
+	for entry in $irq_nss_rps
+	do
+		echo 2 > /proc/irq/$entry/smp_affinity
+	done
+
+	irq_nss_rps=`grep nss_queue2 /proc/interrupts | cut -d ':' -f 1 | tr -d ' '`
+	for entry in $irq_nss_rps
+	do
+		echo 4 > /proc/irq/$entry/smp_affinity
+	done
+
+	irq_nss_rps=`grep nss_queue3 /proc/interrupts | cut -d ':' -f 1 | tr -d ' '`
+	for entry in $irq_nss_rps
+	do
+		echo 8 > /proc/irq/$entry/smp_affinity
+	done
+
+	# Enable NSS RPS
+	sysctl -w dev.nss.rps.enable=1 >/dev/null 2>/dev/null
+
+}
+
+
+start() {
+	local rps_enabled="$(uci_get nss @general[0] enable_rps)"
+	if [ "$rps_enabled" -eq 1 ]; then
+		enable_rps
+	fi
+}
diff --git a/package/qca/qca-nss-drv/files/qca-nss-drv.sysctl b/package/qca/qca-nss-drv/files/qca-nss-drv.sysctl
new file mode 100644
index 0000000000..fc36c33eb5
--- /dev/null
+++ b/package/qca/qca-nss-drv/files/qca-nss-drv.sysctl
@@ -0,0 +1,4 @@
+# Default Number of connection configuration
+dev.nss.ipv4cfg.ipv4_conn=4096
+dev.nss.ipv6cfg.ipv6_conn=4096
+
diff --git a/package/qca/qca-nss-drv/patches/100-kernel-5.4-support.patch b/package/qca/qca-nss-drv/patches/100-kernel-5.4-support.patch
new file mode 100644
index 0000000000..4268225c3b
--- /dev/null
+++ b/package/qca/qca-nss-drv/patches/100-kernel-5.4-support.patch
@@ -0,0 +1,107 @@
+diff --git a/Makefile b/Makefile
+index d998548..b1a4a83 100644
+--- a/Makefile
++++ b/Makefile
+@@ -161,7 +161,7 @@ endif
+ ccflags-y += -I$(obj)/nss_hal/include -I$(obj)/nss_data_plane/include -I$(obj)/exports -DNSS_DEBUG_LEVEL=0 -DNSS_PKT_STATS_ENABLED=1
+ 
+ ccflags-y += -DNSS_PM_DEBUG_LEVEL=0 -DNSS_SKB_REUSE_SUPPORT=1
+-ccflags-y += -Werror
++# ccflags-y += -Werror
+ 
+ ifneq ($(findstring 3.4, $(KERNELVERSION)),)
+ NSS_CCFLAGS = -DNSS_DT_SUPPORT=0 -DNSS_FW_DBG_SUPPORT=1 -DNSS_PM_SUPPORT=1 -DNSS_EMPTY_BUFFER_SIZE=1984
+diff --git a/nss_core.c b/nss_core.c
+index 6c9716a..8956eb5 100644
+--- a/nss_core.c
++++ b/nss_core.c
+@@ -26,6 +26,7 @@
+ #include <nss_hal.h>
+ #include <net/dst.h>
+ #include <linux/etherdevice.h>
++#include <linux/kmemleak.h>
+ #include "nss_tx_rx_common.h"
+ #include "nss_data_plane.h"
+ 
+@@ -45,7 +46,8 @@
+ (((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)))) || \
+ (((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0)))) || \
+ (((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)))) || \
+-(((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))))))
++(((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)))) || \
++(((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(5, 5, 0))))))
+ #error "Check skb recycle code in this file to match Linux version"
+ #endif
+ 
+@@ -395,7 +397,11 @@ static void nss_get_ddr_info(struct nss_mmu_ddr_info *mmu, char *name)
+ 	struct device_node *node;
+ 
+ 	si_meminfo(&vals);
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
++	cached = global_zone_page_state(NR_FILE_PAGES);
++#else
+ 	cached = global_page_state(NR_FILE_PAGES);
++#endif /*KERNEL_VERSION(4, 14, 0)*/
+ 	avail_ddr = (vals.totalram + cached + vals.sharedram) * vals.mem_unit;
+ 
+ 	/*
+@@ -679,7 +685,11 @@ static inline void nss_core_handle_virt_if_pkt(struct nss_ctx_instance *nss_ctx,
+ 	 * Mimic Linux behavior to allow multi-queue netdev choose which queue to use
+ 	 */
+ 	if (ndev->netdev_ops->ndo_select_queue) {
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
++		queue_offset = ndev->netdev_ops->ndo_select_queue(ndev, nbuf, NULL);
++#else
+ 		queue_offset = ndev->netdev_ops->ndo_select_queue(ndev, nbuf, NULL, NULL);
++#endif /*KERNEL_VERSION(5, 3, 0)*/
+ 	}
+ 
+ 	skb_set_queue_mapping(nbuf, queue_offset);
+@@ -2269,7 +2279,11 @@ static inline bool nss_skb_can_reuse(struct nss_ctx_instance *nss_ctx,
+ 	 * This check is added to avoid deadlock from nf_conntrack
+ 	 * when ecm is trying to flush a rule.
+ 	 */
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
++	if (unlikely(skb_nfct(nbuf))) {
++#else
+ 	if (unlikely(nbuf->nfct)) {
++#endif /*KERNEL_VERSION(4, 11, 0)*/
+ 		return false;
+ 	}
+ #endif
+@@ -2279,7 +2285,11 @@ static inline bool nss_skb_can_reuse(struct nss_ctx_instance *nss_ctx,
+ 	 * This check is added to avoid deadlock from nf_bridge
+ 	 * when ecm is trying to flush a rule.
+ 	 */
++#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0))
++	if (unlikely(skb_ext_exist(nbuf, SKB_EXT_BRIDGE_NF))) {
++#else
+ 	if (unlikely(nbuf->nf_bridge)) {
++#endif /*KERNEL_VERSION(4, 11, 0)*/
+ 		return false;
+ 	}
+ #endif
+diff --git a/nss_n2h.c b/nss_n2h.c
+index 781ce2b..695ac13 100644
+--- a/nss_n2h.c
++++ b/nss_n2h.c
+@@ -19,6 +19,7 @@
+  *	NSS N2H node APIs
+  */
+ 
++#include <linux/kmemleak.h>
+ #include "nss_tx_rx_common.h"
+ #include "nss_n2h_stats.h"
+ 
+
+--- a/nss_data_plane/nss_data_plane_gmac.c
++++ b/nss_data_plane/nss_data_plane_gmac.c
+@@ -20,7 +20,7 @@
+ #include "nss_tx_rx_common.h"
+ #include <nss_gmac_api_if.h>
+ 
+-#define NSS_DP_GMAC_SUPPORTED_FEATURES (NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_FRAGLIST | (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO))
++#define NSS_DP_GMAC_SUPPORTED_FEATURES (NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_FRAGLIST | (NETIF_F_TSO | NETIF_F_TSO6))
+ #define NSS_DATA_PLANE_GMAC_MAX_INTERFACES 4
+ 
+ static DEFINE_SPINLOCK(nss_data_plane_gmac_stats_lock);
diff --git a/package/qca/qca-nss-drv/patches/101-nss-drv-Control-fab-scaling-from-package-Makefile.patch b/package/qca/qca-nss-drv/patches/101-nss-drv-Control-fab-scaling-from-package-Makefile.patch
new file mode 100644
index 0000000000..b0facc856c
--- /dev/null
+++ b/package/qca/qca-nss-drv/patches/101-nss-drv-Control-fab-scaling-from-package-Makefile.patch
@@ -0,0 +1,38 @@
+From 40d4b080f17883ac6b39c74a5feb1af384ab6a51 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robert.marko@sartura.hr>
+Date: Thu, 11 Jun 2020 16:57:39 +0200
+Subject: [PATCH] nss-drv: Control fab scaling from package Makefile
+
+Lets control the fab scaling from the package Makefile
+instead of using kernel checks that dont work.
+Fab scaling in OpenWrt is done in a external way.
+
+Signed-off-by: Robert Marko <robert.marko@sartura.hr>
+---
+ Makefile | 9 ---------
+ 1 file changed, 9 deletions(-)
+
+diff --git a/Makefile b/Makefile
+index 20729ab..2567dd4 100644
+--- a/Makefile
++++ b/Makefile
+@@ -405,15 +405,8 @@ NSS_CCFLAGS = -DNSS_DT_SUPPORT=1 -DNSS_FW_DBG_SUPPORT=0 -DNSS_PM_SUPPORT=0
+ ccflags-y += -I$(obj)
+ endif
+ 
+-# Fabric scaling is supported in 3.14 and 4.4 only
+-ifneq ($(findstring 3.14, $(KERNELVERSION)),)
+-NSS_CCFLAGS += -DNSS_FABRIC_SCALING_SUPPORT=1
+-else ifneq ($(findstring 4.4, $(KERNELVERSION)),)
+-NSS_CCFLAGS += -DNSS_FABRIC_SCALING_SUPPORT=1
+-else
+-NSS_CCFLAGS += -DNSS_FABRIC_SCALING_SUPPORT=0
+-endif
++NSS_CCFLAGS += -DNSS_FABRIC_SCALING_SUPPORT=0
+
+ # Disable Frequency scaling
+ ifeq "$(NSS_FREQ_SCALE_DISABLE)" "y"
+ ccflags-y += -DNSS_FREQ_SCALE_SUPPORT=0
+-- 
+2.26.2
+
diff --git a/package/qca/qca-nss-drv/patches/200-fix-NULL-pointer-exception.patch b/package/qca/qca-nss-drv/patches/200-fix-NULL-pointer-exception.patch
new file mode 100644
index 0000000000..3d8bba9508
--- /dev/null
+++ b/package/qca/qca-nss-drv/patches/200-fix-NULL-pointer-exception.patch
@@ -0,0 +1,11 @@
+--- a/nss_core.c
++++ b/nss_core.c
+@@ -1599,7 +1599,7 @@ static int32_t nss_core_handle_cause_que
+ 		 *
+ 		 */
+ 		if (unlikely((buffer_type == N2H_BUFFER_CRYPTO_RESP))) {
+-			dma_unmap_single(NULL, (desc->buffer + desc->payload_offs), desc->payload_len, DMA_FROM_DEVICE);
++			dma_unmap_single(nss_ctx->dev, (desc->buffer + desc->payload_offs), desc->payload_len, DMA_FROM_DEVICE);
+ 			goto consume;
+ 		}
+ 
diff --git a/package/qca/qca-nss-drv/patches/201-Fix-Kernel-Panic-dma-with-NULL-dev.patch b/package/qca/qca-nss-drv/patches/201-Fix-Kernel-Panic-dma-with-NULL-dev.patch
new file mode 100644
index 0000000000..addfef1bb8
--- /dev/null
+++ b/package/qca/qca-nss-drv/patches/201-Fix-Kernel-Panic-dma-with-NULL-dev.patch
@@ -0,0 +1,82 @@
+From 89949decfd9a0f86427b502aae4fbc3a3ef399f0 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Tue, 23 Jun 2020 19:50:28 +0200
+Subject: [PATCH] Fix Kernel Panic dma with NULL dev
+
+---
+ nss_coredump.c | 4 ++--
+ nss_log.c      | 8 +++++---
+ 2 files changed, 8 insertions(+), 6 deletions(-)
+
+diff --git a/nss_coredump.c b/nss_coredump.c
+index aa4ba82..957eca0 100644
+--- a/nss_coredump.c
++++ b/nss_coredump.c
+@@ -154,7 +154,7 @@ void nss_fw_coredump_notify(struct nss_ctx_instance *nss_own,
+ 		dma_addr = nss_own->meminfo_ctx.logbuffer_dma;
+ 	}
+ 
+-	dma_sync_single_for_cpu(NULL, dma_addr, sizeof(struct nss_log_descriptor), DMA_FROM_DEVICE);
++	dma_sync_single_for_cpu(nss_own->dev, dma_addr, sizeof(struct nss_log_descriptor), DMA_FROM_DEVICE);
+ 
+ 	/*
+ 	 * If the current entry is smaller than or equal to the number of NSS_LOG_COREDUMP_LINE_NUM,
+@@ -181,7 +181,7 @@ void nss_fw_coredump_notify(struct nss_ctx_instance *nss_own,
+ 
+ 		offset = (index * sizeof(struct nss_log_entry))
+ 			+ offsetof(struct nss_log_descriptor, log_ring_buffer);
+-		dma_sync_single_for_cpu(NULL, dma_addr + offset,
++		dma_sync_single_for_cpu(nss_own->dev, dma_addr + offset,
+ 				sizeof(struct nss_log_entry), DMA_FROM_DEVICE);
+ 		nss_info_always("%p: %s\n", nss_own, nle_print->message);
+ 		nle_print++;
+diff --git a/nss_log.c b/nss_log.c
+index 06ebba4..f9bd6c8 100644
+--- a/nss_log.c
++++ b/nss_log.c
+@@ -44,6 +44,7 @@ struct nss_log_data {
+ 	uint32_t last_entry;	/* Last known sampled entry (or index) */
+ 	uint32_t nentries;	/* Caches the total number of entries of log buffer */
+ 	int nss_id;		/* NSS Core id being used */
++	struct device *nss_dev;
+ };
+ 
+ struct nss_log_ring_buffer_addr nss_rbe[NSS_MAX_CORES];
+@@ -125,6 +126,7 @@ static int nss_log_open(struct inode *inode, struct file *filp)
+ 	data->last_entry = 0;
+ 	data->nentries = nss_rbe[nss_id].nentries;
+ 	data->dma_addr = nss_rbe[nss_id].dma_addr;
++	data->nss_dev = nss_ctx->dev;
+ 
+ 	/*
+ 	 * Increment the reference count so that we don't free
+@@ -207,7 +209,7 @@ static ssize_t nss_log_read(struct file *filp, char __user *buf, size_t size, lo
+ 	/*
+ 	 * Get the current index
+ 	 */
+-	dma_sync_single_for_cpu(NULL, data->dma_addr, sizeof(struct nss_log_descriptor), DMA_FROM_DEVICE);
++	dma_sync_single_for_cpu(data->nss_dev, data->dma_addr, sizeof(struct nss_log_descriptor), DMA_FROM_DEVICE);
+ 	entry = nss_log_current_entry(desc);
+ 
+ 	/*
+@@ -251,7 +253,7 @@ static ssize_t nss_log_read(struct file *filp, char __user *buf, size_t size, lo
+ 		offset = (offset * sizeof(struct nss_log_entry))
+ 			 + offsetof(struct nss_log_descriptor, log_ring_buffer);
+ 
+-		dma_sync_single_for_cpu(NULL, data->dma_addr + offset,
++		dma_sync_single_for_cpu(data->nss_dev, data->dma_addr + offset,
+ 			sizeof(struct nss_log_entry), DMA_FROM_DEVICE);
+ 		rb = &desc->log_ring_buffer[index];
+ 
+@@ -510,7 +512,7 @@ bool nss_debug_log_buffer_alloc(uint8_t nss_id, uint32_t nentry)
+ 	return true;
+ 
+ fail:
+-	dma_unmap_single(NULL, dma_addr, size, DMA_FROM_DEVICE);
++	dma_unmap_single(nss_ctx->dev, dma_addr, size, DMA_FROM_DEVICE);
+ 	kfree(addr);
+ 	wake_up(&nss_log_wq);
+ 	return false;
+-- 
+2.27.0
+
diff --git a/package/qca/qca-nss-drv/patches/400-Exported-set-nexthop-function.patch b/package/qca/qca-nss-drv/patches/400-Exported-set-nexthop-function.patch
new file mode 100644
index 0000000000..8c0ffe7742
--- /dev/null
+++ b/package/qca/qca-nss-drv/patches/400-Exported-set-nexthop-function.patch
@@ -0,0 +1,47 @@
+From f8cf061454a3707c0c84d0fca685e84455f91362 Mon Sep 17 00:00:00 2001
+From: Suruchi Suman <surusuma@codeaurora.org>
+Date: Tue, 3 Dec 2019 12:57:38 +0530
+Subject: [qca-nss-drv] Exported set nexhop function from drv.
+
+Change-Id: I3df6658bef72fe574ac9acfb7aac61785769766f
+Signed-off-by: Suruchi Suman <surusuma@codeaurora.org>
+---
+ nss_phys_if.c | 9 ++++++++-
+ 1 file changed, 8 insertions(+), 1 deletion(-)
+
+diff --git a/nss_phys_if.c b/nss_phys_if.c
+index 4f9b20f..0c58d95 100644
+--- a/nss_phys_if.c
++++ b/nss_phys_if.c
+@@ -1,6 +1,6 @@
+ /*
+  **************************************************************************
+- * Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
++ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
+  * Permission to use, copy, modify, and/or distribute this software for
+  * any purpose with or without fee is hereby granted, provided that the
+  * above copyright notice and this permission notice appear in all copies.
+@@ -583,6 +583,12 @@ nss_tx_status_t nss_phys_if_set_nexthop(struct nss_ctx_instance *nss_ctx, uint32
+ 	struct nss_phys_if_msg nim;
+ 
+ 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
++
++	if (nexthop >= NSS_MAX_NET_INTERFACES) {
++		nss_warning("%p: Invalid nexthop interface number: %d", nss_ctx, nexthop);
++		return NSS_TX_FAILURE_BAD_PARAM;
++	}
++
+ 	nss_info("%p: Phys If nexthop will be set to %d, id:%d\n", nss_ctx, nexthop, if_num);
+ 
+ 	nss_cmn_msg_init(&nim.cm, if_num, NSS_PHYS_IF_SET_NEXTHOP,
+@@ -591,6 +597,7 @@ nss_tx_status_t nss_phys_if_set_nexthop(struct nss_ctx_instance *nss_ctx, uint32
+ 
+ 	return nss_phys_if_msg_sync(nss_ctx, &nim);
+ }
++EXPORT_SYMBOL(nss_phys_if_set_nexthop);
+ 
+ /*
+  * nss_get_state()
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/Makefile b/package/qca/qca-nss-ecm/Makefile
new file mode 100644
index 0000000000..d3f8ac29c8
--- /dev/null
+++ b/package/qca/qca-nss-ecm/Makefile
@@ -0,0 +1,270 @@
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=qca-nss-ecm
+PKG_RELEASE:=1
+
+PKG_SOURCE_URL:=https://source.codeaurora.org/quic/qsdk/oss/lklm/qca-nss-ecm
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_VERSION:=9228212b4238c0d8c296f795948ede8f2ca0242e
+
+LOCAL_VARIANT=$(patsubst qca-nss-ecm-%,%,$(patsubst qca-nss-ecm-%,%,$(BUILD_VARIANT)))
+include $(INCLUDE_DIR)/package.mk
+
+ifeq ($(CONFIG_QCA_NSS_ECM_EXAMPLES_PCC),y)
+       FILES_EXAMPLES=$(PKG_BUILD_DIR)/examples/ecm_pcc_test.ko
+endif
+
+ifeq ($(CONFIG_QCA_NSS_ECM_EXAMPLES_MARK),y)
+       FILES_EXAMPLES+=$(PKG_BUILD_DIR)/examples/ecm_mark_test.ko
+endif
+
+#Explicitly enable OVS external module, if ovsmgr is enabled.
+ifneq ($(CONFIG_PACKAGE_kmod-qca-ovsmgr),)
+CONFIG_QCA_NSS_ECM_OVS=y
+endif
+
+ifeq ($(CONFIG_QCA_NSS_ECM_OVS),y)
+       FILES_EXAMPLES+=$(PKG_BUILD_DIR)/examples/ecm_ovs.ko
+endif
+
+define KernelPackage/qca-nss-ecm/Default
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Support
+  DEPENDS:=+TARGET_ipq806x:kmod-qca-nss-drv \
+	+TARGET_ipq_ipq806x:kmod-qca-nss-drv \
+	+TARGET_ipq_ipq807x:kmod-qca-nss-drv \
+	+TARGET_ipq_ipq807x_64:kmod-qca-nss-drv \
+	+TARGET_ipq807x:kmod-qca-nss-drv \
+	+TARGET_ipq807x_64:kmod-qca-nss-drv \
+	+TARGET_ipq_ipq60xx:kmod-qca-nss-drv \
+	+TARGET_ipq_ipq60xx_64:kmod-qca-nss-drv \
+	+TARGET_ipq_ipq50xx:kmod-qca-nss-drv \
+	+TARGET_ipq_ipq50xx_64:kmod-qca-nss-drv \
+	+iptables-mod-extra +kmod-ipt-conntrack \
+	+kmod-pppoe @!LINUX_3_18 \
+	+kmod-ipsec
+  TITLE:=QCA NSS Enhanced Connection Manager (ECM)
+  FILES:=$(PKG_BUILD_DIR)/*.ko $(FILES_EXAMPLES)
+  KCONFIG:=CONFIG_BRIDGE_NETFILTER=y \
+	CONFIG_NF_CONNTRACK_EVENTS=y \
+	CONFIG_NF_CONNTRACK_CHAIN_EVENTS=y \
+	CONFIG_NF_CONNTRACK_DSCPREMARK_EXT=y
+  MENU:=1
+  PROVIDES:=kmod-qca-nss-ecm
+endef
+
+define KernelPackage/qca-nss-ecm/Description/Default
+This package contains the QCA NSS Enhanced Connection Manager
+endef
+
+define KernelPackage/qca-nss-ecm/Default/install
+	$(INSTALL_DIR) $(1)/etc/firewall.d $(1)/etc/init.d $(1)/usr/bin $(1)/lib/netifd/offload $(1)/etc/config $(1)/etc/uci-defaults $(1)/etc/sysctl.d
+	$(INSTALL_DATA) ./files/qca-nss-ecm.firewall $(1)/etc/firewall.d/qca-nss-ecm
+	$(INSTALL_BIN) ./files/qca-nss-ecm.init $(1)/etc/init.d/qca-nss-ecm
+	$(INSTALL_BIN) ./files/ecm_dump.sh $(1)/usr/bin/
+	$(INSTALL_BIN) ./files/on-demand-down $(1)/lib/netifd/offload/on-demand-down
+	$(INSTALL_DATA) ./files/qca-nss-ecm.uci $(1)/etc/config/ecm
+	$(INSTALL_DATA) ./files/qca-nss-ecm.defaults $(1)/etc/uci-defaults/99-qca-nss-ecm
+	$(INSTALL_BIN) ./files/qca-nss-ecm.sysctl $(1)/etc/sysctl.d/qca-nss-ecm.conf
+ifeq ($(CONFIG_KERNEL_IPQ_MEM_PROFILE),256)
+	echo 'net.netfilter.nf_conntrack_max=2048' >> $(1)/etc/sysctl.d/qca-nss-ecm.conf
+endif
+ifeq ($(CONFIG_KERNEL_IPQ_MEM_PROFILE),512)
+	echo 'net.netfilter.nf_conntrack_max=8192' >> $(1)/etc/sysctl.d/qca-nss-ecm.conf
+endif
+endef
+
+define KernelPackage/qca-nss-ecm-standard
+  $(call KernelPackage/qca-nss-ecm/Default)
+  VARIANT:=standard
+endef
+
+define KernelPackage/qca-nss-ecm-standard/Description
+  $(call KernelPackage/qca-nss-ecm/Description/Default)
+endef
+
+define KernelPackage/qca-nss-ecm-standard/install
+$(call KernelPackage/qca-nss-ecm/Default/install, $(1))
+endef
+
+# Variant with additional features enabled for premium profile
+define KernelPackage/qca-nss-ecm-premium/Default
+$(call KernelPackage/qca-nss-ecm/Default)
+  TITLE+= (with premium features)
+  VARIANT:=premium
+  DEPENDS+=+kmod-nat46 \
+	+kmod-l2tp +kmod-pppol2tp +kmod-pptp \
+	+kmod-bonding
+endef
+
+define KernelPackage/qca-nss-ecm-premium/Description/Default
+$(call KernelPackage/qca-nss-ecm/Description/Default)
+with the premium features enabled
+endef
+
+define KernelPackage/qca-nss-ecm-premium/Default/install
+$(call KernelPackage/qca-nss-ecm/install)
+endef
+
+define KernelPackage/qca-nss-ecm-premium
+$(call KernelPackage/qca-nss-ecm-premium/Default)
+endef
+
+define KernelPackage/qca-nss-ecm-premium/Description
+$(call KernelPackage/qca-nss-ecm-premium/Description/Default)
+endef
+
+define KernelPackage/qca-nss-ecm-premium/install
+$(call KernelPackage/qca-nss-ecm-standard/install, $(1))
+endef
+
+# Variant with additional features enabled for noload profile
+define KernelPackage/qca-nss-ecm-noload
+  $(call KernelPackage/qca-nss-ecm/Default)
+  TITLE+= (with noload features)
+  PROVIDES:=kmod-qca-nss-ecm
+  VARIANT:=noload
+  DEPENDS+=+kmod-l2tp +kmod-pppol2tp +kmod-pptp \
+	   +kmod-bonding
+endef
+
+define KernelPackage/qca-nss-ecm-noload/Description
+  $(call KernelPackage/qca-nss-ecm/Description/Default)
+  When selected, this package installs the driver but does not load it at init.
+endef
+
+define KernelPackage/qca-nss-ecm-noload/install
+$(call KernelPackage/qca-nss-ecm/Default/install, $(1))
+	#
+	# Remove the START line from the init script, so that the symlink
+	# in the /etc/rc.d directory is not created.
+	#
+	sed -i '/START=/d' $(1)/etc/init.d/qca-nss-ecm
+endef
+
+define KernelPackage/qca-nss-ecm-premium-noload
+  $(call KernelPackage/qca-nss-ecm-premium/Default)
+  PROVIDES:=kmod-qca-nss-ecm-premium
+endef
+
+define KernelPackage/qca-nss-ecm-premium-noload/Description
+  $(call KernelPackage/qca-nss-ecm-premium/Description/Default)
+  When selected, this package installs the driver but does not load it at init.
+endef
+
+define KernelPackage/qca-nss-ecm-premium-noload/install
+$(call KernelPackage/qca-nss-ecm-premium/Default/install, $(1))
+endef
+
+define Build/InstallDev/qca-nss-ecm
+	$(INSTALL_DIR) $(1)/usr/include/qca-nss-ecm
+	$(CP) $(PKG_BUILD_DIR)/exports/* $(1)/usr/include/qca-nss-ecm/
+endef
+
+define Build/InstallDev
+	$(call Build/InstallDev/qca-nss-ecm,$(1))
+endef
+
+EXTRA_CFLAGS+= \
+	-I$(STAGING_DIR)/usr/include/hyfibr \
+	-I$(STAGING_DIR)/usr/include/qca-mcs \
+	-I$(STAGING_DIR)/usr/include/qca-nss-drv \
+	-I$(STAGING_DIR)/usr/include/shortcut-fe \
+	-I$(STAGING_DIR)/usr/include/nat46
+
+ECM_MAKE_OPTS:=ECM_CLASSIFIER_HYFI_ENABLE=y
+ifneq ($(LOCAL_VARIANT),standard)
+ECM_MAKE_OPTS+=ECM_MULTICAST_ENABLE=y \
+		ECM_INTERFACE_IPSEC_ENABLE=y \
+		# ECM_INTERFACE_PPTP_ENABLE=y \
+		ECM_INTERFACE_L2TPV2_ENABLE=y \
+		ECM_INTERFACE_GRE_TAP_ENABLE=y \
+		ECM_INTERFACE_GRE_TUN_ENABLE=y \
+		ECM_INTERFACE_SIT_ENABLE=y \
+		ECM_INTERFACE_TUNIPIP6_ENABLE=y \
+		ECM_INTERFACE_RAWIP_ENABLE=y
+
+ifeq ($(CONFIG_TARGET_ipq_ipq40xx)$(CONFIG_TARGET_ipq40xx),)
+ECM_MAKE_OPTS+=ECM_INTERFACE_BOND_ENABLE=y
+endif
+endif
+
+ifeq ($(filter $(CONFIG_KERNEL_IPQ_MEM_PROFILE), 256),)
+ECM_MAKE_OPTS+=ECM_XFRM_ENABLE=y
+endif
+
+# ifneq ($(CONFIG_PACKAGE_kmod-nat46),)
+# ECM_MAKE_OPTS+=ECM_INTERFACE_MAP_T_ENABLE=y
+# endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-ovpn-link),)
+ECM_MAKE_OPTS+=ECM_INTERFACE_OVPN_ENABLE=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-nss-drv-vxlanmgr),)
+ECM_MAKE_OPTS+=ECM_INTERFACE_VXLAN_ENABLE=y
+endif
+
+ifneq ($(CONFIG_PACKAGE_kmod-qca-ovsmgr),)
+ECM_MAKE_OPTS+=ECM_INTERFACE_OVS_BRIDGE_ENABLE=y \
+		ECM_CLASSIFIER_OVS_ENABLE=y
+EXTRA_CFLAGS+= -I$(STAGING_DIR)/usr/include/qca-ovsmgr
+endif
+
+# Keeping default as ipq806x for branches that does not have subtarget framework
+ifeq ($(CONFIG_TARGET_ipq),y)
+subtarget:=$(SUBTARGET)
+else
+subtarget:=$(CONFIG_TARGET_BOARD)
+endif
+
+define Build/InstallDev
+	$(INSTALL_DIR) $(1)/usr/include/qca-nss-ecm
+	$(CP) $(PKG_BUILD_DIR)/exports/* $(1)/usr/include/qca-nss-ecm
+endef
+
+define Build/Compile
+	$(MAKE) $(PKG_JOBS) -C "$(LINUX_DIR)" $(strip $(ECM_MAKE_OPTS)) \
+		$(KERNEL_MAKE_FLAGS) \
+		$(PKG_MAKE_FLAGS) \
+		M="$(PKG_BUILD_DIR)" \
+		EXTRA_CFLAGS="$(EXTRA_CFLAGS)" SoC="$(subtarget)" \
+		EXAMPLES_BUILD_PCC="$(CONFIG_QCA_NSS_ECM_EXAMPLES_PCC)" \
+		EXAMPLES_BUILD_MARK="$(CONFIG_QCA_NSS_ECM_EXAMPLES_MARK)" \
+		EXAMPLES_BUILD_OVS="$(CONFIG_QCA_NSS_ECM_OVS)" \
+		ECM_FRONT_END_SFE_ENABLE="$(CONFIG_QCA_ECM_SFE_SUPPORT)" \
+		modules
+endef
+
+define KernelPackage/qca-nss-ecm-premium/config
+menu "ECM Configuration"
+	config QCA_NSS_ECM_EXAMPLES_PCC
+		bool "Build PCC usage example"
+		help
+			Selecting this will build the PCC classifier usage example module.
+		default n
+
+	config QCA_NSS_ECM_EXAMPLES_MARK
+		bool "Build Mark classifier usage example"
+		help
+			Selecting this will build the Mark classifier usage example module.
+		default n
+
+	config QCA_NSS_ECM_OVS
+		bool "Build OVS classifier external module"
+		help
+			Selecting this will build the OVS classifier external module.
+		default n
+
+	config QCA_ECM_SFE_SUPPORT
+		bool "Add SFE support to ECM driver"
+		default n
+endmenu
+endef
+
+$(eval $(call KernelPackage,qca-nss-ecm-noload))
+$(eval $(call KernelPackage,qca-nss-ecm-standard))
+$(eval $(call KernelPackage,qca-nss-ecm-premium-noload))
+$(eval $(call KernelPackage,qca-nss-ecm-premium))
diff --git a/package/qca/qca-nss-ecm/files/ecm_dump.sh b/package/qca/qca-nss-ecm/files/ecm_dump.sh
new file mode 100644
index 0000000000..dbf7de753f
--- /dev/null
+++ b/package/qca/qca-nss-ecm/files/ecm_dump.sh
@@ -0,0 +1,95 @@
+#!/bin/sh
+#
+# Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+#
+
+ECM_MODULE=${1:-ecm_state}
+MOUNT_ROOT=/dev/ecm
+
+#
+# usage: ecm_dump.sh [module=ecm_db]
+#
+# with no parameters, ecm_dump.sh will attempt to mount the
+# ecm_db state file and cat its contents.
+#
+# example with a parameter: ecm_dump.sh ecm_classifier_default
+#
+# this will cause ecm_dump to attempt to find and mount the state
+# file for the ecm_classifier_default module, and if successful
+# cat the contents.
+#
+
+# this is one of the state files, which happens to be the
+# last module started in ecm
+ECM_STATE=/sys/kernel/debug/ecm/ecm_state/state_dev_major
+
+# tests to see if ECM is up and ready to receive commands.
+# returns 0 if ECM is fully up and ready, else 1
+ecm_is_ready() {
+	if [ ! -e "${ECM_STATE}" ]
+	then
+		return 1
+	fi
+	return 0
+}
+
+#
+# module_state_mount(module_name)
+#      Mounts the state file of the module, if supported
+#
+module_state_mount() {
+	local module_name=$1
+	local mount_dir=$2
+	local state_file="/sys/kernel/debug/ecm/${module_name}/state_dev_major"
+
+	if [ -e "${mount_dir}/${module_name}" ]
+	then
+		# already mounted
+		return 0
+	fi
+
+	#echo "Mount state file for $module_name ..."
+	if [ ! -e "$state_file" ]
+	then
+		#echo "... $module_name does not support state"
+		return 1
+	fi
+
+	local major="`cat $state_file`"
+	#echo "... Mounting state $state_file with major: $major"
+	mknod "${mount_dir}/${module_name}" c $major 0
+}
+
+#
+# main
+#
+ecm_is_ready || {
+	#echo "ECM is not running"
+	exit 1
+}
+
+# all state files are mounted under MOUNT_ROOT, so make sure it exists
+mkdir -p ${MOUNT_ROOT}
+
+#
+# attempt to mount state files for the requested module and cat it
+# if the mount succeeded
+#
+module_state_mount ${ECM_MODULE} ${MOUNT_ROOT} && {
+	cat ${MOUNT_ROOT}/${ECM_MODULE}
+	exit 0
+}
+
+exit 2
diff --git a/package/qca/qca-nss-ecm/files/on-demand-down b/package/qca/qca-nss-ecm/files/on-demand-down
new file mode 100644
index 0000000000..02d708e03b
--- /dev/null
+++ b/package/qca/qca-nss-ecm/files/on-demand-down
@@ -0,0 +1,6 @@
+#!/bin/sh
+# Copyright (c) 2016 The Linux Foundation. All rights reserved.
+
+[ -e "/sys/kernel/debug/ecm/ecm_db/defunct_all" ] && {
+	echo 1 > /sys/kernel/debug/ecm/ecm_db/defunct_all
+}
diff --git a/package/qca/qca-nss-ecm/files/qca-nss-ecm.defaults b/package/qca/qca-nss-ecm/files/qca-nss-ecm.defaults
new file mode 100644
index 0000000000..308e265c98
--- /dev/null
+++ b/package/qca/qca-nss-ecm/files/qca-nss-ecm.defaults
@@ -0,0 +1,28 @@
+#!/bin/sh
+#
+# Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+#
+
+uci -q batch << EOF
+	delete firewall.qcanssecm
+	set firewall.qcanssecm=include
+	set firewall.qcanssecm.type=script
+	set firewall.qcanssecm.path=/etc/firewall.d/qca-nss-ecm
+	set firewall.qcanssecm.family=any
+	set firewall.qcanssecm.reload=1
+	commit firewall
+EOF
+
+exit 0
diff --git a/package/qca/qca-nss-ecm/files/qca-nss-ecm.firewall b/package/qca/qca-nss-ecm/files/qca-nss-ecm.firewall
new file mode 100644
index 0000000000..24c64def2a
--- /dev/null
+++ b/package/qca/qca-nss-ecm/files/qca-nss-ecm.firewall
@@ -0,0 +1,18 @@
+#!/bin/sh
+#
+# Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+#
+
+iptables -A FORWARD -m physdev --physdev-is-bridged -j ACCEPT
diff --git a/package/qca/qca-nss-ecm/files/qca-nss-ecm.init b/package/qca/qca-nss-ecm/files/qca-nss-ecm.init
new file mode 100644
index 0000000000..9b43fdb093
--- /dev/null
+++ b/package/qca/qca-nss-ecm/files/qca-nss-ecm.init
@@ -0,0 +1,118 @@
+#!/bin/sh  /etc/rc.common
+#
+# Copyright (c) 2014, 2019 The Linux Foundation. All rights reserved.
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+# The shebang above has an extra space intentially to avoid having
+# openwrt build scripts automatically enable this package starting
+# at boot.
+
+START=19
+
+get_front_end_mode() {
+	config_load "ecm"
+	config_get front_end global acceleration_engine "auto"
+
+	case $front_end in
+	auto)
+		echo '0'
+		;;
+	nss)
+		echo '1'
+		;;
+	sfe)
+		echo '2'
+		;;
+	*)
+		echo 'uci_option_acceleration_engine is invalid'
+	esac
+}
+
+support_bridge() {
+	#NSS support bridge acceleration
+	[ -d /sys/kernel/debug/ecm/ecm_nss_ipv4 ] && return 0
+	#SFE doesn't support bridge acceleration
+	[ -d /sys/kernel/debug/ecm/ecm_sfe_ipv4 ] && return 1
+}
+
+load_sfe() {
+	[ -d /sys/module/shortcut_fe ] || insmod shortcut-fe
+	[ -d /sys/module/shortcut_fe_ipv6 ] || insmod shortcut-fe-ipv6
+	[ -d /sys/module/shortcut_fe_drv ] || insmod shortcut-fe-drv
+}
+
+load_ecm() {
+	[ -d /sys/module/ecm ] || {
+		[ ! -e /proc/device-tree/MP_256 ] && load_sfe
+		insmod ecm front_end_selection=$(get_front_end_mode)
+	}
+
+	support_bridge && {
+		sysctl -w net.bridge.bridge-nf-call-ip6tables=1
+		sysctl -w net.bridge.bridge-nf-call-iptables=1
+	}
+}
+
+unload_ecm() {
+	sysctl -w net.bridge.bridge-nf-call-ip6tables=0
+	sysctl -w net.bridge.bridge-nf-call-iptables=0
+
+	if [ -d /sys/module/ecm ]; then
+		#
+		# Stop ECM frontends
+		#
+		echo 1 > /sys/kernel/debug/ecm/front_end_ipv4_stop
+		echo 1 > /sys/kernel/debug/ecm/front_end_ipv6_stop
+
+		#
+		# Defunct the connections
+		#
+	        echo 1 > /sys/kernel/debug/ecm/ecm_db/defunct_all
+		sleep 5;
+
+		rmmod ecm
+		sleep 1
+	fi
+}
+
+start() {
+	load_ecm
+
+	# If the acceleration engine is NSS, enable wifi redirect.
+	[ -d /sys/kernel/debug/ecm/ecm_nss_ipv4 ] && sysctl -w dev.nss.general.redirect=1
+
+	support_bridge && {
+		echo 'net.bridge.bridge-nf-call-ip6tables=1' >> /etc/sysctl.d/qca-nss-ecm.conf
+		echo 'net.bridge.bridge-nf-call-iptables=1' >> /etc/sysctl.d/qca-nss-ecm.conf
+	}
+
+	if [ -d /sys/module/qca_ovsmgr ]; then
+		insmod ecm_ovs
+	fi
+
+}
+
+stop() {
+	# If the acceleration engine is NSS, disable wifi redirect.
+	[ -d /sys/kernel/debug/ecm/ecm_nss_ipv4 ] && sysctl -w dev.nss.general.redirect=0
+
+	sed '/net.bridge.bridge-nf-call-ip6tables=1/d' -i /etc/sysctl.d/qca-nss-ecm.conf
+	sed '/net.bridge.bridge-nf-call-iptables=1/d' -i /etc/sysctl.d/qca-nss-ecm.conf
+
+	if [ -d /sys/module/ecm_ovs ]; then
+		rmmod ecm_ovs
+	fi
+
+	unload_ecm
+}
diff --git a/package/qca/qca-nss-ecm/files/qca-nss-ecm.sysctl b/package/qca/qca-nss-ecm/files/qca-nss-ecm.sysctl
new file mode 100644
index 0000000000..1a3d76b189
--- /dev/null
+++ b/package/qca/qca-nss-ecm/files/qca-nss-ecm.sysctl
@@ -0,0 +1,2 @@
+# nf_conntrack_tcp_no_window_check is 0 by default, set it to 1
+net.netfilter.nf_conntrack_tcp_no_window_check=1
diff --git a/package/qca/qca-nss-ecm/files/qca-nss-ecm.uci b/package/qca/qca-nss-ecm/files/qca-nss-ecm.uci
new file mode 100644
index 0000000000..4f2de68771
--- /dev/null
+++ b/package/qca/qca-nss-ecm/files/qca-nss-ecm.uci
@@ -0,0 +1,2 @@
+config ecm 'global'
+	option acceleration_engine 'auto'
diff --git a/package/qca/qca-nss-ecm/patches/001-Drop_SFE_from_ecm.patch b/package/qca/qca-nss-ecm/patches/001-Drop_SFE_from_ecm.patch
new file mode 100644
index 0000000000..b1cd2b7b12
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/001-Drop_SFE_from_ecm.patch
@@ -0,0 +1,12 @@
+--- a/Makefile
++++ b/Makefile
+@@ -66,8 +66,7 @@ endif
+ # Define ECM_FRONT_END_SFE_ENABLE=y in order to select
+ # sfe as ECM's front end.
+ # #############################################################################
+-ifeq ($(SoC),$(filter $(SoC),ipq806x ipq40xx))
+-ECM_FRONT_END_SFE_ENABLE=y
++ifeq ($(ECM_FRONT_END_SFE_ENABLE), y)
+ ecm-$(ECM_FRONT_END_SFE_ENABLE) += frontends/sfe/ecm_sfe_ipv4.o
+ ecm-$(ECM_FRONT_END_SFE_ENABLE) += frontends/sfe/ecm_sfe_ported_ipv4.o
+ ccflags-$(ECM_FRONT_END_SFE_ENABLE) += -DECM_FRONT_END_SFE_ENABLE
diff --git a/package/qca/qca-nss-ecm/patches/100-kernel-5.4-support.patch b/package/qca/qca-nss-ecm/patches/100-kernel-5.4-support.patch
new file mode 100644
index 0000000000..b863ad7e09
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/100-kernel-5.4-support.patch
@@ -0,0 +1,1276 @@
+--- a/ecm_classifier_default.c
++++ b/ecm_classifier_default.c
+@@ -42,7 +42,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_classifier_dscp.c
++++ b/ecm_classifier_dscp.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_classifier_hyfi.c
++++ b/ecm_classifier_hyfi.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_classifier_nl.c
++++ b/ecm_classifier_nl.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(4, 2, 0))
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #else
+@@ -146,12 +145,42 @@ static struct genl_multicast_group ecm_c
+ 	},
+ };
+ 
++static int ecm_classifier_nl_genl_msg_ACCEL(struct sk_buff *skb, struct genl_info *info);
++static int ecm_classifier_nl_genl_msg_DUMP(struct sk_buff *skb, struct netlink_callback *cb);
++
++/*
++ * Generic Netlink message-to-handler mapping
++ */
++static struct genl_ops ecm_cl_nl_genl_ops[] = {
++	{
++		.cmd = ECM_CL_NL_GENL_CMD_ACCEL,
++		.flags = 0,
++		.doit = ecm_classifier_nl_genl_msg_ACCEL,
++		.dumpit = NULL,
++	},
++	{
++		.cmd = ECM_CL_NL_GENL_CMD_ACCEL_OK,
++		.flags = 0,
++		.doit = NULL,
++		.dumpit = ecm_classifier_nl_genl_msg_DUMP,
++	},
++	{
++		.cmd = ECM_CL_NL_GENL_CMD_CONNECTION_CLOSED,
++		.flags = 0,
++		.doit = NULL,
++		.dumpit = ecm_classifier_nl_genl_msg_DUMP,
++	},
++};
++
+ static struct genl_family ecm_cl_nl_genl_family = {
+-	.id = GENL_ID_GENERATE,
+ 	.hdrsize = 0,
+ 	.name = ECM_CL_NL_GENL_NAME,
+ 	.version = ECM_CL_NL_GENL_VERSION,
+ 	.maxattr = ECM_CL_NL_GENL_ATTR_MAX,
++	.ops = ecm_cl_nl_genl_ops,
++	.n_ops = ARRAY_SIZE(ecm_cl_nl_genl_ops),
++	.mcgrps = ecm_cl_nl_genl_mcgrp,
++	.n_mcgrps = ARRAY_SIZE(ecm_cl_nl_genl_mcgrp),
+ };
+ 
+ /*
+@@ -215,12 +244,7 @@ ecm_classifier_nl_send_genl_msg(enum ECM
+ 		return ret;
+ 	}
+ 
+-	ret = genlmsg_end(skb, msg_head);
+-	if (ret < 0) {
+-		DEBUG_WARN("failed to finalize genl msg: %d\n", ret);
+-		nlmsg_free(skb);
+-		return ret;
+-	}
++	genlmsg_end(skb, msg_head);
+ 
+ 	/* genlmsg_multicast frees the skb in both success and error cases */
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+@@ -1377,85 +1401,14 @@ static struct file_operations ecm_classi
+ 	.write = ecm_classifier_nl_set_command,
+ };
+ 
+-/*
+- * Generic Netlink attr checking policies
+- */
+-static struct nla_policy
+-ecm_cl_nl_genl_policy[ECM_CL_NL_GENL_ATTR_COUNT] = {
+-	[ECM_CL_NL_GENL_ATTR_TUPLE] = {
+-		.type = NLA_UNSPEC,
+-		.len = sizeof(struct ecm_cl_nl_genl_attr_tuple), },
+-};
+-
+-/*
+- * Generic Netlink message-to-handler mapping
+- */
+-static struct genl_ops ecm_cl_nl_genl_ops[] = {
+-	{
+-		.cmd = ECM_CL_NL_GENL_CMD_ACCEL,
+-		.flags = 0,
+-		.policy = ecm_cl_nl_genl_policy,
+-		.doit = ecm_classifier_nl_genl_msg_ACCEL,
+-		.dumpit = NULL,
+-	},
+-	{
+-		.cmd = ECM_CL_NL_GENL_CMD_ACCEL_OK,
+-		.flags = 0,
+-		.policy = ecm_cl_nl_genl_policy,
+-		.doit = NULL,
+-		.dumpit = ecm_classifier_nl_genl_msg_DUMP,
+-	},
+-	{
+-		.cmd = ECM_CL_NL_GENL_CMD_CONNECTION_CLOSED,
+-		.flags = 0,
+-		.policy = ecm_cl_nl_genl_policy,
+-		.doit = NULL,
+-		.dumpit = ecm_classifier_nl_genl_msg_DUMP,
+-	},
+-};
+-
+ static int ecm_classifier_nl_register_genl(void)
+ {
+ 	int result;
+ 
+-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+-	result = genl_register_family_with_ops_groups(&ecm_cl_nl_genl_family,
+-						      ecm_cl_nl_genl_ops,
+-						      ecm_cl_nl_genl_mcgrp);
+-	if (result != 0) {
+-		DEBUG_ERROR("failed to register genl ops: %d\n", result);
+-		return result;
+-	}
+-#else
+ 	result = genl_register_family(&ecm_cl_nl_genl_family);
+-	if (result != 0) {
++	if (result != 0) 
+ 		DEBUG_ERROR("failed to register genl family: %d\n", result);
+-		goto err1;
+-	}
+-
+-	result = genl_register_ops(&ecm_cl_nl_genl_family,
+-				   ecm_cl_nl_genl_ops);
+-	if (result != 0) {
+-		DEBUG_ERROR("failed to register genl ops: %d\n", result);
+-		goto err2;
+-	}
+-
+-	result = genl_register_mc_group(&ecm_cl_nl_genl_family,
+-					ecm_cl_nl_genl_mcgrp);
+-	if (result != 0) {
+-		DEBUG_ERROR("failed to register genl multicast group: %d\n",
+-			    result);
+-		goto err3;
+-	}
+-
+-	return 0;
+ 
+-err3:
+-	genl_unregister_ops(&ecm_cl_nl_genl_family, ecm_cl_nl_genl_ops);
+-err2:
+-	genl_unregister_family(&ecm_cl_nl_genl_family);
+-err1:
+-#endif
+ 	return result;
+ }
+ 
+--- a/ecm_classifier_pcc.c
++++ b/ecm_classifier_pcc.c
+@@ -49,7 +49,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_conntrack_notifier.c
++++ b/ecm_conntrack_notifier.c
+@@ -51,7 +51,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+@@ -345,14 +344,6 @@ static int ecm_conntrack_event(unsigned
+ 		return NOTIFY_DONE;
+ 	}
+ 
+-	/*
+-	 * Special untracked connection is not monitored
+-	 */
+-	if (ct == &nf_conntrack_untracked) {
+-		DEBUG_TRACE("Fake connection event - ignoring\n");
+-		return NOTIFY_DONE;
+-	}
+-
+ 	/*
+ 	 * Only interested if this is IPv4 or IPv6.
+ 	 */
+--- a/ecm_db/ecm_db.c
++++ b/ecm_db/ecm_db.c
+@@ -42,7 +42,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_db/ecm_db_connection.c
++++ b/ecm_db/ecm_db_connection.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_db/ecm_db_host.c
++++ b/ecm_db/ecm_db_host.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_db/ecm_db_iface.c
++++ b/ecm_db/ecm_db_iface.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_db/ecm_db_listener.c
++++ b/ecm_db/ecm_db_listener.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_db/ecm_db_mapping.c
++++ b/ecm_db/ecm_db_mapping.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_db/ecm_db_multicast.c
++++ b/ecm_db/ecm_db_multicast.c
+@@ -42,7 +42,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_db/ecm_db_node.c
++++ b/ecm_db/ecm_db_node.c
+@@ -41,7 +41,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_db/ecm_db_timer.c
++++ b/ecm_db/ecm_db_timer.c
+@@ -42,7 +42,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+@@ -387,7 +386,7 @@ EXPORT_SYMBOL(ecm_db_time_get);
+  *	Manage expiration of connections
+  * NOTE: This is softirq context
+  */
+-static void ecm_db_timer_callback(unsigned long data)
++static void ecm_db_timer_callback(struct timer_list *arg)
+ {
+ 	uint32_t timer;
+ 
+@@ -425,9 +424,7 @@ void ecm_db_timer_init(void)
+ 	/*
+ 	 * Set a timer to manage cleanup of expired connections
+ 	 */
+-	init_timer(&ecm_db_timer);
+-	ecm_db_timer.function = ecm_db_timer_callback;
+-	ecm_db_timer.data = 0;
++	timer_setup(&ecm_db_timer, ecm_db_timer_callback, 0);
+ 	ecm_db_timer.expires = jiffies + HZ;
+ 	add_timer(&ecm_db_timer);
+ 
+--- a/ecm_interface.c
++++ b/ecm_interface.c
+@@ -66,7 +66,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <linux/netfilter_ipv6/ip6_tables.h>
+@@ -537,7 +536,7 @@ static bool ecm_interface_find_gateway_ipv4(ip_addr_t addr, ip_addr_t gw_addr)
+ 		return false;
+ 	}
+ 
+-	ECM_NIN4_ADDR_TO_IP_ADDR(gw_addr, rt->rt_gateway)
++	ECM_NIN4_ADDR_TO_IP_ADDR(gw_addr, rt->rt_gw4)
+ 	ecm_interface_route_release(&ecm_rt);
+ 	return true;
+ }
+@@ -596,7 +595,7 @@ static bool ecm_interface_mac_addr_get_ipv4(ip_addr_t addr, uint8_t *mac_addr, b
+ 	if (rt->rt_uses_gateway || (rt->rt_flags & RTF_GATEWAY)) {
+ #endif
+ 		*on_link = false;
+-		ECM_NIN4_ADDR_TO_IP_ADDR(gw_addr, rt->rt_gateway)
++		ECM_NIN4_ADDR_TO_IP_ADDR(gw_addr, rt->rt_gw4)
+ 	} else {
+ 		*on_link = true;
+ 	}
+@@ -1003,7 +1002,7 @@ static bool ecm_interface_find_route_by_addr_ipv6(ip_addr_t addr, struct ecm_int
+ 	 * Get a route to the given IP address, this will allow us to also find the interface
+ 	 * it is using to communicate with that IP address.
+ 	 */
+-	ecm_rt->rt.rtv6 = rt6_lookup(&init_net, &naddr, NULL, 0, 0);
++	ecm_rt->rt.rtv6 = rt6_lookup(&init_net, &naddr, NULL, 0, NULL, 0);
+ 	if (!ecm_rt->rt.rtv6) {
+ 		DEBUG_TRACE("No output route to: " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(addr));
+ 		return NULL;
+@@ -1077,7 +1076,7 @@ void ecm_interface_send_neighbour_solicitation(struct net_device *dev, ip_addr_t
+ 	/*
+ 	 * Find the route entry
+ 	 */
+-	rt6i = rt6_lookup(netf, &dst_addr, NULL, 0, 0);
++	rt6i = rt6_lookup(netf, &dst_addr, NULL, 0, NULL, 0);
+ 	if (!rt6i) {
+ 		DEBUG_TRACE("IPv6 Route lookup failure for destination IPv6 address " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(addr));
+ 		return;
+@@ -1104,7 +1103,7 @@ void ecm_interface_send_neighbour_solicitation(struct net_device *dev, ip_addr_t
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0))
+ 	ndisc_send_ns(dev, neigh, &dst_addr, &mc_dst_addr, &src_addr);
+ #else
+-	ndisc_send_ns(dev, &dst_addr, &mc_dst_addr, &src_addr);
++	ndisc_send_ns(dev, &dst_addr, &mc_dst_addr, &src_addr, 0);
+ #endif
+ 	neigh_release(neigh);
+ 	dst_release(&rt6i->dst);
+@@ -1194,7 +1193,7 @@ struct neighbour *ecm_interface_ipv6_neigh_get(ip_addr_t addr)
+ 	struct in6_addr ipv6_addr;
+ 
+ 	ECM_IP_ADDR_TO_NIN6_ADDR(ipv6_addr, addr);
+-	rt = rt6_lookup(&init_net, &ipv6_addr, NULL, 0, 0);
++	rt = rt6_lookup(&init_net, &ipv6_addr, NULL, 0, NULL, 0);
+ 	if (!rt) {
+ 		return NULL;
+ 	}
+@@ -1220,7 +1219,7 @@ bool ecm_interface_is_pptp(struct sk_buff *skb, const struct net_device *out)
+ 	 * skip first pass of l2tp/pptp tunnel encapsulated traffic
+ 	 */
+ 	if (out->type == ARPHRD_PPP) {
+-		if (out->priv_flags & IFF_PPP_PPTP) {
++		if (out->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_PPTP) {
+ 			return true;
+ 		}
+ 	}
+@@ -1231,7 +1230,7 @@ bool ecm_interface_is_pptp(struct sk_buff *skb, const struct net_device *out)
+ 	}
+ 
+ 	if (in->type == ARPHRD_PPP) {
+-		if (in->priv_flags & IFF_PPP_PPTP) {
++		if (in->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_PPTP) {
+ 			dev_put(in);
+ 			return true;
+ 		}
+@@ -1256,10 +1255,10 @@ bool ecm_interface_is_l2tp_packet_by_version(struct sk_buff *skb, const struct n
+ 
+ 	switch (ver) {
+ 	case 2:
+-		flag = IFF_PPP_L2TPV2;
++		flag = IFF_QCA_ECM_PPP_L2TPV2;
+ 		break;
+ 	case 3:
+-		flag = IFF_PPP_L2TPV3;
++		flag = IFF_QCA_ECM_PPP_L2TPV3;
+ 		break;
+ 	default:
+ 		break;
+@@ -1268,10 +1267,8 @@ bool ecm_interface_is_l2tp_packet_by_version(struct sk_buff *skb, const struct n
+ 	/*
+ 	 * skip first pass of l2tp/pptp tunnel encapsulated traffic
+ 	 */
+-	if (out->type == ARPHRD_PPP) {
+-		if (out->priv_flags & flag) {
+-			return true;
+-		}
++	if (out->priv_flags_qca_ecm & flag) {
++		return true;
+ 	}
+ 
+ 	in = dev_get_by_index(&init_net, skb->skb_iif);
+@@ -1279,11 +1276,9 @@ bool ecm_interface_is_l2tp_packet_by_version(struct sk_buff *skb, const struct n
+ 		return true;
+ 	}
+ 
+-	if (in->type == ARPHRD_PPP) {
+-		if (in->priv_flags & flag) {
+-			dev_put(in);
+-			return true;
+-		}
++	if (out->priv_flags_qca_ecm & flag) {
++		dev_put(in);
++		return true;
+ 	}
+ 
+ 	dev_put(in);
+@@ -1304,11 +1299,9 @@ bool ecm_interface_is_l2tp_pptp(struct sk_buff *skb, const struct net_device *ou
+ 	/*
+ 	 * skip first pass of l2tp/pptp tunnel encapsulated traffic
+ 	 */
+-	if (out->type == ARPHRD_PPP) {
+-		if (out->priv_flags & (IFF_PPP_L2TPV2 | IFF_PPP_L2TPV3 |
+-				      IFF_PPP_PPTP)) {
+-			return true;
+-		}
++	if (out->priv_flags_qca_ecm & (IFF_QCA_ECM_PPP_L2TPV2 | IFF_QCA_ECM_PPP_L2TPV3 |
++			IFF_QCA_ECM_PPP_PPTP)) {
++		return true;
+ 	}
+ 
+ 	in = dev_get_by_index(&init_net, skb->skb_iif);
+@@ -1316,12 +1309,10 @@ bool ecm_interface_is_l2tp_pptp(struct sk_buff *skb, const struct net_device *ou
+ 		return true;
+ 	}
+ 
+-	if (in->type == ARPHRD_PPP) {
+-		if (in->priv_flags & (IFF_PPP_L2TPV2 | IFF_PPP_L2TPV3 |
+-				      IFF_PPP_PPTP)) {
+-			dev_put(in);
+-			return true;
+-		}
++	if (out->priv_flags_qca_ecm & (IFF_QCA_ECM_PPP_L2TPV2 | IFF_QCA_ECM_PPP_L2TPV3 |
++			       IFF_QCA_ECM_PPP_PPTP)) {
++		dev_put(in);
++		return true;
+ 	}
+ 
+ 	dev_put(in);
+@@ -2416,7 +2407,7 @@ struct ecm_db_iface_instance *ecm_interface_establish_and_ref(struct ecm_front_e
+ 		/*
+ 		 * GRE TAP?
+ 		 */
+-		if (dev->priv_flags & (IFF_GRE_V4_TAP | IFF_GRE_V6_TAP)) {
++		if (dev->priv_flags_qca_ecm & (IFF_QCA_ECM_GRE_V4_TAP | IFF_QCA_ECM_GRE_V6_TAP)) {
+ 			interface_type = feci->ae_interface_type_get(feci, dev);
+ 			ae_interface_num = feci->ae_interface_number_by_dev_type_get(dev, interface_type);
+ 
+@@ -2680,7 +2671,7 @@ identifier_update:
+ 	/*
+ 	 * OVPN Tunnel?
+ 	 */
+-	if ((dev_type == ARPHRD_NONE) && (dev->priv_flags & IFF_TUN_TAP)) {
++	if ((dev_type == ARPHRD_NONE) && (dev->priv_flags_qca_ecm & IFF_QCA_ECM_TUN_TAP)) {
+ 		struct net_device *tun_dev = NULL;
+ 		ip_addr_t saddr, daddr;
+ 
+@@ -2746,7 +2737,7 @@ identifier_update:
+ 	 * ppp_is_multilink() and ppp_hold_channels() which acquire same lock
+ 	 */
+ 
+-	if ((dev->priv_flags & IFF_PPP_L2TPV2) && ppp_is_xmit_locked(dev)) {
++	if ((dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_L2TPV2) && ppp_is_xmit_locked(dev)) {
+ 		if (skb && (skb->skb_iif == dev->ifindex)) {
+ 			struct pppol2tp_common_addr info;
+ 
+@@ -2804,7 +2795,7 @@ identifier_update:
+ #endif
+ 
+ #ifdef ECM_INTERFACE_PPTP_ENABLE
+-	if ((protocol == IPPROTO_GRE) && skb && v4_hdr && (dev->priv_flags & IFF_PPP_PPTP)) {
++	if ((protocol == IPPROTO_GRE) && skb && v4_hdr && (dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_PPTP)) {
+ 		struct gre_hdr_pptp *gre_hdr;
+ 		uint16_t proto;
+ 		int ret;
+@@ -3972,7 +3963,7 @@ int32_t ecm_interface_heirarchy_construct(struct ecm_front_end_connection_instan
+ 		if (((ip_version == 4) && (protocol == IPPROTO_IPV6)) ||
+ 		    ((ip_version == 6) && (protocol == IPPROTO_IPIP)) ||
+ 					  (protocol == IPPROTO_GRE) ||
+-		    ((given_dest_dev->type == ARPHRD_NONE) && (given_dest_dev->priv_flags & IFF_TUN_TAP))) {
++		    ((given_dest_dev->type == ARPHRD_NONE) && (given_dest_dev->priv_flags_qca_ecm & IFF_QCA_ECM_TUN_TAP))) {
+ 			dev_put(dest_dev);
+ 			dest_dev = given_dest_dev;
+ 			if (dest_dev) {
+@@ -3991,7 +3982,7 @@ int32_t ecm_interface_heirarchy_construct(struct ecm_front_end_connection_instan
+ 	/*
+ 	 * if the address is a local address and indev=l2tp.
+ 	 */
+-	if ((given_src_dev->type == ARPHRD_PPP) && (given_src_dev->priv_flags & IFF_PPP_L2TPV2) && ppp_is_xmit_locked(given_src_dev)) {
++	if ((given_src_dev->type == ARPHRD_PPP) && (given_src_dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_L2TPV2) && ppp_is_xmit_locked(given_src_dev)) {
+ 		dev_put(dest_dev);
+ 		dest_dev = given_dest_dev;
+ 		if (dest_dev) {
+@@ -4005,7 +3996,7 @@ int32_t ecm_interface_heirarchy_construct(struct ecm_front_end_connection_instan
+ 	/*
+ 	 * if the address is a local address and indev=PPTP.
+ 	 */
+-	if (protocol == IPPROTO_GRE && given_dest_dev && (given_dest_dev->priv_flags & IFF_PPP_PPTP)){
++	if (protocol == IPPROTO_GRE && given_dest_dev && (given_dest_dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_PPTP)){
+ 		dev_put(dest_dev);
+ 		dest_dev = given_dest_dev;
+ 		if (dest_dev) {
+@@ -4054,7 +4045,7 @@ int32_t ecm_interface_heirarchy_construct(struct ecm_front_end_connection_instan
+ 		if (((ip_version == 4) && (protocol == IPPROTO_IPV6)) ||
+ 		    ((ip_version == 6) && (protocol == IPPROTO_IPIP)) ||
+ 					  (protocol == IPPROTO_GRE) ||
+-		    ((given_src_dev->type == ARPHRD_NONE) && (given_src_dev->priv_flags & IFF_TUN_TAP))) {
++		    ((given_src_dev->type == ARPHRD_NONE) && (given_src_dev->priv_flags_qca_ecm & IFF_QCA_ECM_TUN_TAP))) {
+ 			dev_put(src_dev);
+ 			src_dev = given_src_dev;
+ 			if (src_dev) {
+@@ -4504,7 +4495,7 @@ lag_success:
+ 			/*
+ 			 * OVPN ?
+ 			 */
+-			if ((dest_dev_type == ARPHRD_NONE) && (dest_dev->priv_flags & IFF_TUN_TAP)) {
++			if ((dest_dev_type == ARPHRD_NONE) && (dest_dev->priv_flags_qca_ecm & IFF_QCA_ECM_TUN_TAP)) {
+ 				DEBUG_TRACE("Net device: %p is OVPN, device name: %s\n", dest_dev, dest_dev->name);
+ 				break;
+ 			}
+@@ -4523,7 +4514,7 @@ lag_success:
+ 			DEBUG_TRACE("%p: Net device: %p is PPP\n", feci, dest_dev);
+ 
+ #ifdef ECM_INTERFACE_L2TPV2_ENABLE
+-			if ((given_src_dev->priv_flags & IFF_PPP_L2TPV2) && ppp_is_xmit_locked(given_src_dev)) {
++			if ((given_src_dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_L2TPV2) && ppp_is_xmit_locked(given_src_dev)) {
+ 				if (skb->skb_iif == dest_dev->ifindex) {
+ 					DEBUG_TRACE("%p: Net device: %p PPP channel is PPPoL2TPV2\n", feci, dest_dev);
+ 					break;
+@@ -4532,7 +4523,7 @@ lag_success:
+ #endif
+ 
+ #ifdef ECM_INTERFACE_PPTP_ENABLE
+-			if (protocol == IPPROTO_GRE && dest_dev && (dest_dev->priv_flags & IFF_PPP_PPTP)) {
++			if (protocol == IPPROTO_GRE && dest_dev && (dest_dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_PPTP)) {
+ 				DEBUG_TRACE("%p: Net device: %p PPP channel is PPTP\n", feci, dest_dev);
+ 				break;
+ 			}
+@@ -4798,7 +4789,7 @@ int32_t ecm_interface_multicast_from_heirarchy_construct(struct ecm_front_end_co
+ 	/*
+ 	 * if the address is a local address and indev=l2tp.
+ 	 */
+-	if ((given_src_dev->type == ARPHRD_PPP) && (given_src_dev->priv_flags & IFF_PPP_L2TPV2) && ppp_is_xmit_locked(given_src_dev)) {
++	if ((given_src_dev->type == ARPHRD_PPP) && (given_src_dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_L2TPV2) && ppp_is_xmit_locked(given_src_dev)) {
+ 		dev_put(dest_dev);
+ 		dest_dev = given_dest_dev;
+ 		if (dest_dev) {
+@@ -5265,7 +5256,7 @@ int32_t ecm_interface_multicast_from_heirarchy_construct(struct ecm_front_end_co
+ 			DEBUG_TRACE("Net device: %p is PPP\n", dest_dev);
+ 
+ #ifdef ECM_INTERFACE_L2TPV2_ENABLE
+-			if ((given_src_dev->priv_flags & IFF_PPP_L2TPV2) && ppp_is_xmit_locked(given_src_dev)) {
++			if ((given_src_dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_L2TPV2) && ppp_is_xmit_locked(given_src_dev)) {
+ 				if (skb->skb_iif == dest_dev->ifindex) {
+ 					DEBUG_TRACE("Net device: %p PPP channel is PPPoL2TPV2\n", dest_dev);
+ 					break;
+@@ -6520,7 +6511,7 @@ static int ecm_interface_wifi_event_rx(struct socket *sock, struct sockaddr_nl *
+ #endif
+ 	oldfs = get_fs();
+ 	set_fs(KERNEL_DS);
+-	size = sock_recvmsg(sock, &msg, len, msg.msg_flags);
++	size = sock_recvmsg(sock, &msg, msg.msg_flags);
+ 	set_fs(oldfs);
+ 
+ 	return size;
+@@ -6609,7 +6600,7 @@ int ecm_interface_wifi_event_stop(void)
+ 	}
+ 
+ 	DEBUG_INFO("kill ecm_interface_wifi_event thread\n");
+-	force_sig(SIGKILL, __ewn.thread);
++	send_sig(SIGKILL, __ewn.thread, 1);
+ 	err = kthread_stop(__ewn.thread);
+ 	__ewn.thread = NULL;
+ 
+--- a/ecm_tracker.c
++++ b/ecm_tracker.c
+@@ -43,7 +43,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_tracker_datagram.c
++++ b/ecm_tracker_datagram.c
+@@ -43,7 +43,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/ecm_tracker_tcp.c
++++ b/ecm_tracker_tcp.c
+@@ -43,7 +43,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+@@ -1143,7 +1142,7 @@ static bool ecm_tracker_tcp_extract_mss(
+ 		const u8 *hash_location;
+ 		tcp_parse_options(skb, &opt_rx, &hash_location, 0);
+ #elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
+-		tcp_parse_options(skb, &opt_rx, 0, NULL);
++		tcp_parse_options(&init_net, skb, &opt_rx, 0, NULL);
+ #else
+ #error "Unsupported kernel version for tcp_parse_options()"
+ #endif
+--- a/ecm_tracker_udp.c
++++ b/ecm_tracker_udp.c
+@@ -43,7 +43,6 @@
+ #include <net/netfilter/nf_conntrack.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+--- a/frontends/ecm_front_end_ipv4.c
++++ b/frontends/ecm_front_end_ipv4.c
+@@ -215,7 +215,7 @@ bool ecm_front_end_ipv4_interface_constr
+ 			 * behind a gateway.
+ 			 */
+ 			DEBUG_TRACE("Gateway address will be looked up overwrite the rt_dst_addr\n");
+-			ECM_NIN4_ADDR_TO_IP_ADDR(rt_dst_addr, rt->rt_gateway)
++			ECM_NIN4_ADDR_TO_IP_ADDR(rt_dst_addr, rt->rt_gw4)
+ 			gateway = true;
+ 		}
+ 
+--- a/frontends/include/ecm_front_end_common.h
++++ b/frontends/include/ecm_front_end_common.h
+@@ -98,13 +98,6 @@ static inline bool ecm_front_end_acceler
+ 		return false;
+ 	}
+ 
+-	if (unlikely(nf_ct_is_untracked(ct))) {
+-		/*
+-		 * Untracked traffic certainly can't be accelerated.
+-		 */
+-		return true;
+-	}
+-
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(3, 6, 0))
+ 	acct = nf_conn_acct_find(ct);
+ #else
+--- a/frontends/nss/ecm_nss_bond_notifier.c
++++ b/frontends/nss/ecm_nss_bond_notifier.c
+@@ -52,7 +52,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+--- a/frontends/nss/ecm_nss_common.h
++++ b/frontends/nss/ecm_nss_common.h
+@@ -144,7 +144,7 @@ static inline int32_t ecm_nss_common_get_interface_type(struct ecm_front_end_con
+ 		/*
+ 		 * If device is not GRETAP then return NONE.
+ 		 */
+-		if (!(dev->priv_flags & (IFF_GRE_V4_TAP | IFF_GRE_V6_TAP))) {
++		if (!(dev->priv_flags_qca_ecm & (IFF_QCA_ECM_GRE_V4_TAP | IFF_QCA_ECM_GRE_V6_TAP))) {
+ 			break;
+ 		}
+ #endif
+--- a/frontends/nss/ecm_nss_ipv4.c
++++ b/frontends/nss/ecm_nss_ipv4.c
+@@ -48,7 +48,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(4, 2, 0))
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #else
+@@ -1053,7 +1052,7 @@ static unsigned int ecm_nss_ipv4_ip_process(struct net_device *out_dev, struct n
+ 		 * If any of the input or output interface is a GRE V4 TAP/TUN interface
+ 		 * we can continue to accelerate it.
+ 		 */
+-		if ((in_dev->priv_flags & IFF_GRE_V4_TAP) || (out_dev->priv_flags & IFF_GRE_V4_TAP)) {
++		if ((in_dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V4_TAP) || (out_dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V4_TAP)) {
+ #ifndef ECM_INTERFACE_GRE_TAP_ENABLE
+ 			DEBUG_TRACE("GRE TAP acceleration is disabled\n");
+ 			return NF_ACCEPT;
+@@ -1082,7 +1081,7 @@ static unsigned int ecm_nss_ipv4_ip_process(struct net_device *out_dev, struct n
+ 		reply_tuple.dst.u3.ip = orig_tuple.src.u3.ip;
+ 		sender = ECM_TRACKER_SENDER_TYPE_SRC;
+ 	} else {
+-		if (unlikely(ct == &nf_conntrack_untracked)) {
++		if (unlikely(ctinfo == IP_CT_UNTRACKED)) {
+ 			DEBUG_TRACE("%p: ct: untracked\n", skb);
+ 			return NF_ACCEPT;
+ 		}
+@@ -2097,7 +2096,6 @@ sync_conntrack:
+ 	}
+ 
+ 	ct = nf_ct_tuplehash_to_ctrack(h);
+-	NF_CT_ASSERT(ct->timeout.data == (unsigned long)ct);
+ 	DEBUG_TRACE("%p: NSS Sync: conntrack connection\n", ct);
+ 
+ 	ecm_front_end_flow_and_return_directions_get(ct, flow_ip, 4, &flow_dir, &return_dir);
+@@ -2108,7 +2106,7 @@ sync_conntrack:
+ 	 */
+ 	if (!test_bit(IPS_FIXED_TIMEOUT_BIT, &ct->status)) {
+ 		spin_lock_bh(&ct->lock);
+-		ct->timeout.expires += delta_jiffies;
++		ct->timeout += delta_jiffies;
+ 		spin_unlock_bh(&ct->lock);
+ 	}
+ 
+@@ -2166,17 +2164,15 @@ sync_conntrack:
+ 			u_int64_t reply_pkts = atomic64_read(&acct[IP_CT_DIR_REPLY].packets);
+ 
+ 			if (reply_pkts != 0) {
+-				struct nf_conntrack_l4proto *l4proto;
+ 				unsigned int *timeouts;
+ 
+ 				set_bit(IPS_SEEN_REPLY_BIT, &ct->status);
+ 				set_bit(IPS_ASSURED_BIT, &ct->status);
+ 
+-				l4proto = __nf_ct_l4proto_find(AF_INET, IPPROTO_UDP);
+-				timeouts = nf_ct_timeout_lookup(&init_net, ct, l4proto);
++				timeouts = nf_ct_timeout_lookup(ct);
+ 
+ 				spin_lock_bh(&ct->lock);
+-				ct->timeout.expires = jiffies + timeouts[UDP_CT_REPLIED];
++				ct->timeout = jiffies + timeouts[UDP_CT_REPLIED];
+ 				spin_unlock_bh(&ct->lock);
+ 			}
+ 		}
+@@ -2690,7 +2686,8 @@ int ecm_nss_ipv4_init(struct dentry *dentry)
+ 	/*
+ 	 * Register netfilter hooks
+ 	 */
+-	result = nf_register_hooks(ecm_nss_ipv4_netfilter_hooks, ARRAY_SIZE(ecm_nss_ipv4_netfilter_hooks));
++	result = nf_register_net_hooks(&init_net, ecm_nss_ipv4_netfilter_hooks, \
++				       ARRAY_SIZE(ecm_nss_ipv4_netfilter_hooks));
+ 	if (result < 0) {
+ 		DEBUG_ERROR("Can't register netfilter hooks.\n");
+ 		nss_ipv4_notify_unregister();
+@@ -2702,8 +2699,8 @@ int ecm_nss_ipv4_init(struct dentry *dentry)
+ 	if (result < 0) {
+ 		DEBUG_ERROR("Failed to init ecm ipv4 multicast frontend\n");
+ 		nss_ipv4_notify_unregister();
+-		nf_unregister_hooks(ecm_nss_ipv4_netfilter_hooks,
+-				ARRAY_SIZE(ecm_nss_ipv4_netfilter_hooks));
++		nf_unregister_net_hooks(&init_net, ecm_nss_ipv4_netfilter_hooks,
++					ARRAY_SIZE(ecm_nss_ipv4_netfilter_hooks));
+ 		goto task_cleanup;
+ 	}
+ #endif
+@@ -2714,8 +2711,8 @@ int ecm_nss_ipv4_init(struct dentry *dentry)
+ #ifdef ECM_MULTICAST_ENABLE
+ 		ecm_nss_multicast_ipv4_exit();
+ #endif
+-		nf_unregister_hooks(ecm_nss_ipv4_netfilter_hooks,
+-				ARRAY_SIZE(ecm_nss_ipv4_netfilter_hooks));
++		nf_unregister_net_hooks(&init_net, ecm_nss_ipv4_netfilter_hooks,
++					ARRAY_SIZE(ecm_nss_ipv4_netfilter_hooks));
+ 		goto task_cleanup;
+ 	}
+ 
+@@ -2742,8 +2739,8 @@ void ecm_nss_ipv4_exit(void)
+ 	/*
+ 	 * Stop the network stack hooks
+ 	 */
+-	nf_unregister_hooks(ecm_nss_ipv4_netfilter_hooks,
+-			    ARRAY_SIZE(ecm_nss_ipv4_netfilter_hooks));
++	nf_unregister_net_hooks(&init_net, ecm_nss_ipv4_netfilter_hooks,
++				ARRAY_SIZE(ecm_nss_ipv4_netfilter_hooks));
+ 
+ 	/*
+ 	 * Unregister from the Linux NSS Network driver
+--- a/frontends/nss/ecm_nss_ipv6.c
++++ b/frontends/nss/ecm_nss_ipv6.c
+@@ -51,7 +51,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(4, 2, 0))
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #else
+@@ -1035,7 +1034,7 @@ static unsigned int ecm_nss_ipv6_ip_process(struct net_device *out_dev, struct n
+ 		 * If any of the input or output interface is a GRE V4 TAP/TUN interface
+ 		 * we can continue to accelerate it.
+ 		 */
+-		if ((in_dev->priv_flags & IFF_GRE_V4_TAP) || (out_dev->priv_flags & IFF_GRE_V4_TAP)) {
++		if ((in_dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V4_TAP) || (out_dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V4_TAP)) {
+ #ifndef ECM_INTERFACE_GRE_TAP_ENABLE
+ 			DEBUG_TRACE("GRE TAP acceleration is disabled\n");
+ 			return NF_ACCEPT;
+@@ -1064,7 +1063,7 @@ static unsigned int ecm_nss_ipv6_ip_process(struct net_device *out_dev, struct n
+ 		ECM_IP_ADDR_TO_NIN6_ADDR(reply_tuple.dst.u3.in6, ip_hdr.src_addr);
+ 		sender = ECM_TRACKER_SENDER_TYPE_SRC;
+ 	} else {
+-		if (unlikely(ct == &nf_conntrack_untracked)) {
++		if (unlikely(ctinfo == IP_CT_UNTRACKED)) {
+ 			DEBUG_TRACE("%p: ct: untracked\n", skb);
+ 			return NF_ACCEPT;
+ 		}
+@@ -1809,7 +1808,6 @@ sync_conntrack:
+ 	}
+ 
+ 	ct = nf_ct_tuplehash_to_ctrack(h);
+-	NF_CT_ASSERT(ct->timeout.data == (unsigned long)ct);
+ 	DEBUG_TRACE("%p: NSS Sync: conntrack connection\n", ct);
+ 
+ 	ecm_front_end_flow_and_return_directions_get(ct, flow_ip, 6, &flow_dir, &return_dir);
+@@ -1820,7 +1818,7 @@ sync_conntrack:
+ 	 */
+ 	if (!test_bit(IPS_FIXED_TIMEOUT_BIT, &ct->status)) {
+ 		spin_lock_bh(&ct->lock);
+-		ct->timeout.expires += delta_jiffies;
++		ct->timeout += delta_jiffies;
+ 		spin_unlock_bh(&ct->lock);
+ 	}
+ 
+@@ -1878,17 +1876,15 @@ sync_conntrack:
+ 			u_int64_t reply_pkts = atomic64_read(&acct[IP_CT_DIR_REPLY].packets);
+ 
+ 			if (reply_pkts != 0) {
+-				struct nf_conntrack_l4proto *l4proto;
+ 				unsigned int *timeouts;
+ 
+ 				set_bit(IPS_SEEN_REPLY_BIT, &ct->status);
+ 				set_bit(IPS_ASSURED_BIT, &ct->status);
+ 
+-				l4proto = __nf_ct_l4proto_find(AF_INET6, IPPROTO_UDP);
+-				timeouts = nf_ct_timeout_lookup(&init_net, ct, l4proto);
++				timeouts = nf_ct_timeout_lookup(ct);
+ 
+ 				spin_lock_bh(&ct->lock);
+-				ct->timeout.expires = jiffies + timeouts[UDP_CT_REPLIED];
++				ct->timeout = jiffies + timeouts[UDP_CT_REPLIED];
+ 				spin_unlock_bh(&ct->lock);
+ 			}
+ 		}
+@@ -2402,7 +2398,7 @@ int ecm_nss_ipv6_init(struct dentry *dentry)
+ 	/*
+ 	 * Register netfilter hooks
+ 	 */
+-	result = nf_register_hooks(ecm_nss_ipv6_netfilter_hooks, ARRAY_SIZE(ecm_nss_ipv6_netfilter_hooks));
++	result = nf_register_net_hooks(&init_net, ecm_nss_ipv6_netfilter_hooks, ARRAY_SIZE(ecm_nss_ipv6_netfilter_hooks));
+ 	if (result < 0) {
+ 		DEBUG_ERROR("Can't register netfilter hooks.\n");
+ 		nss_ipv6_notify_unregister();
+@@ -2414,8 +2410,8 @@ int ecm_nss_ipv6_init(struct dentry *dentry)
+ 	if (result < 0) {
+ 		DEBUG_ERROR("Failed to init ecm ipv6 multicast frontend\n");
+ 		nss_ipv6_notify_unregister();
+-		nf_unregister_hooks(ecm_nss_ipv6_netfilter_hooks,
+-				ARRAY_SIZE(ecm_nss_ipv6_netfilter_hooks));
++		nf_unregister_net_hooks(&init_net, ecm_nss_ipv6_netfilter_hooks,
++					ARRAY_SIZE(ecm_nss_ipv6_netfilter_hooks));
+ 		goto task_cleanup;
+ 	}
+ #endif
+@@ -2426,8 +2422,8 @@ int ecm_nss_ipv6_init(struct dentry *dentry)
+ #ifdef ECM_MULTICAST_ENABLE
+ 		ecm_nss_multicast_ipv6_exit();
+ #endif
+-		nf_unregister_hooks(ecm_nss_ipv6_netfilter_hooks,
+-				ARRAY_SIZE(ecm_nss_ipv6_netfilter_hooks));
++		nf_unregister_net_hooks(&init_net, ecm_nss_ipv6_netfilter_hooks,
++					ARRAY_SIZE(ecm_nss_ipv6_netfilter_hooks));
+ 		goto task_cleanup;
+ 	}
+ 
+@@ -2453,8 +2449,8 @@ void ecm_nss_ipv6_exit(void)
+ 	/*
+ 	 * Stop the network stack hooks
+ 	 */
+-	nf_unregister_hooks(ecm_nss_ipv6_netfilter_hooks,
+-			    ARRAY_SIZE(ecm_nss_ipv6_netfilter_hooks));
++	nf_unregister_net_hooks(&init_net, ecm_nss_ipv6_netfilter_hooks,
++				ARRAY_SIZE(ecm_nss_ipv6_netfilter_hooks));
+ 
+ 	/*
+ 	 * Unregister from the Linux NSS Network driver
+--- a/frontends/nss/ecm_nss_multicast_ipv4.c
++++ b/frontends/nss/ecm_nss_multicast_ipv4.c
+@@ -50,7 +50,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+--- a/frontends/nss/ecm_nss_multicast_ipv6.c
++++ b/frontends/nss/ecm_nss_multicast_ipv6.c
+@@ -51,7 +51,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+--- a/frontends/nss/ecm_nss_non_ported_ipv4.c
++++ b/frontends/nss/ecm_nss_non_ported_ipv4.c
+@@ -47,7 +47,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+@@ -640,7 +639,7 @@ static void ecm_nss_non_ported_ipv4_connection_accelerate(struct ecm_front_end_c
+ #ifdef ECM_INTERFACE_GRE_TAP_ENABLE
+ 			dev = dev_get_by_index(&init_net, ecm_db_iface_interface_identifier_get(ii));
+ 			if (dev) {
+-				if (dev->priv_flags & IFF_GRE_V4_TAP) {
++				if (dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V4_TAP) {
+ 					/*
+ 					 * Clear QOS_VALID to prevent outer rule from overwriting
+ 					 * inner flow's QoS classification.
+--- a/frontends/nss/ecm_nss_non_ported_ipv6.c
++++ b/frontends/nss/ecm_nss_non_ported_ipv6.c
+@@ -47,7 +47,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+@@ -548,7 +547,7 @@ static void ecm_nss_non_ported_ipv6_connection_accelerate(struct ecm_front_end_c
+ #ifdef ECM_INTERFACE_GRE_TAP_ENABLE
+ 			dev = dev_get_by_index(&init_net, ecm_db_iface_interface_identifier_get(ii));
+ 			if (dev) {
+-				if (dev->priv_flags & IFF_GRE_V6_TAP) {
++				if (dev->priv_flags_qca_ecm & IFF_QCA_ECM_GRE_V6_TAP) {
+ 					/*
+ 					 * Clear QOS_VALID to prevent outer rule from overwriting
+ 					 * inner flow's QoS classification.
+--- a/frontends/nss/ecm_nss_ported_ipv4.c
++++ b/frontends/nss/ecm_nss_ported_ipv4.c
+@@ -47,7 +47,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+--- a/frontends/nss/ecm_nss_ported_ipv6.c
++++ b/frontends/nss/ecm_nss_ported_ipv6.c
+@@ -47,7 +47,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+@@ -1996,7 +1995,7 @@ unsigned int ecm_nss_ported_ipv6_process
+ 		/*
+ 		 * Deny acceleration for L2TP-over-UDP tunnel
+ 		 */
+-		if ((in_dev->priv_flags & IFF_PPP_L2TPV2) && ppp_is_xmit_locked(in_dev)) {
++		if ((in_dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_L2TPV2) && ppp_is_xmit_locked(in_dev)) {
+ 			DEBUG_TRACE("Skip packets for L2TP tunnel in skb %p\n", skb);
+ 			can_accel = false;
+ 		}
+--- a/frontends/sfe/ecm_sfe_ipv4.c
++++ b/frontends/sfe/ecm_sfe_ipv4.c
+@@ -47,7 +47,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(4, 2, 0))
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #else
+@@ -746,7 +745,8 @@ static unsigned int ecm_sfe_ipv4_ip_proc
+ 	 * If skb_dst(skb)->xfrm is not null, packet is to be encrypted by ipsec, we can't accelerate it.
+ 	 * If skb->sp is not null, packet is decrypted by ipsec. We only accelerate it when configuration didn't reject ipsec.
+ 	 */
+-	if (unlikely((skb_dst(skb) && skb_dst(skb)->xfrm) || (ecm_sfe_ipv4_reject_acceleration_for_ipsec && skb->sp))) {
++	if (unlikely((skb_dst(skb) && skb_dst(skb)->xfrm) || \
++		     (ecm_sfe_ipv4_reject_acceleration_for_ipsec && skb_ext_exist(skb, SKB_EXT_SEC_PATH)))) {
+ 		DEBUG_TRACE("skip local ipsec flows\n");
+ 		return NF_ACCEPT;
+ 	}
+@@ -762,7 +762,7 @@ static unsigned int ecm_sfe_ipv4_ip_process(struct net_device *out_dev, struct n
+ 		reply_tuple.dst.u3.ip = orig_tuple.src.u3.ip;
+ 		sender = ECM_TRACKER_SENDER_TYPE_SRC;
+ 	} else {
+-		if (unlikely(ct == &nf_conntrack_untracked)) {
++		if (unlikely(ctinfo == IP_CT_UNTRACKED)) {
+ 			DEBUG_TRACE("%p: ct: untracked\n", skb);
+ 			return NF_ACCEPT;
+ 		}
+@@ -1531,7 +1526,6 @@ sync_conntrack:
+ 	}
+ 
+ 	ct = nf_ct_tuplehash_to_ctrack(h);
+-	NF_CT_ASSERT(ct->timeout.data == (unsigned long)ct);
+ 	DEBUG_TRACE("%p: SFE Sync: conntrack connection\n", ct);
+ 
+ 	ecm_front_end_flow_and_return_directions_get(ct, flow_ip, 4, &flow_dir, &return_dir);
+@@ -1551,7 +1545,7 @@ sync_conntrack:
+ 		delta_jiffies = ((sync->inc_ticks * HZ) + (MSEC_PER_SEC / 2)) / MSEC_PER_SEC;
+ 
+ 		spin_lock_bh(&ct->lock);
+-		ct->timeout.expires += delta_jiffies;
++		ct->timeout += delta_jiffies;
+ 		spin_unlock_bh(&ct->lock);
+ 	}
+ 
+@@ -1609,17 +1603,15 @@ sync_conntrack:
+ 			u_int64_t reply_pkts = atomic64_read(&acct[IP_CT_DIR_REPLY].packets);
+ 
+ 			if (reply_pkts != 0) {
+-				struct nf_conntrack_l4proto *l4proto;
+ 				unsigned int *timeouts;
+ 
+ 				set_bit(IPS_SEEN_REPLY_BIT, &ct->status);
+ 				set_bit(IPS_ASSURED_BIT, &ct->status);
+ 
+-				l4proto = __nf_ct_l4proto_find(AF_INET, IPPROTO_UDP);
+-				timeouts = nf_ct_timeout_lookup(&init_net, ct, l4proto);
++				timeouts = nf_ct_timeout_lookup(ct);
+ 
+ 				spin_lock_bh(&ct->lock);
+-				ct->timeout.expires = jiffies + timeouts[UDP_CT_REPLIED];
++				ct->timeout = jiffies + timeouts[UDP_CT_REPLIED];
+ 				spin_unlock_bh(&ct->lock);
+ 			}
+ 		}
+@@ -1901,7 +1893,7 @@ int ecm_sfe_ipv4_init(struct dentry *den
+ 	/*
+ 	 * Register netfilter hooks
+ 	 */
+-	result = nf_register_hooks(ecm_sfe_ipv4_netfilter_hooks, ARRAY_SIZE(ecm_sfe_ipv4_netfilter_hooks));
++	result = nf_register_net_hooks(&init_net, ecm_sfe_ipv4_netfilter_hooks, ARRAY_SIZE(ecm_sfe_ipv4_netfilter_hooks));
+ 	if (result < 0) {
+ 		DEBUG_ERROR("Can't register netfilter hooks.\n");
+ 		sfe_drv_ipv4_notify_unregister();
+@@ -1934,8 +1926,8 @@ void ecm_sfe_ipv4_exit(void)
+ 	/*
+ 	 * Stop the network stack hooks
+ 	 */
+-	nf_unregister_hooks(ecm_sfe_ipv4_netfilter_hooks,
+-			    ARRAY_SIZE(ecm_sfe_ipv4_netfilter_hooks));
++	nf_unregister_net_hooks(&init_net, ecm_sfe_ipv4_netfilter_hooks,
++				ARRAY_SIZE(ecm_sfe_ipv4_netfilter_hooks));
+ 
+ 	/*
+ 	 * Unregister from the simulated sfe driver
+--- a/frontends/sfe/ecm_sfe_ipv6.c
++++ b/frontends/sfe/ecm_sfe_ipv6.c
+@@ -51,7 +51,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(4, 2, 0))
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #else
+@@ -714,7 +713,8 @@ static unsigned int ecm_sfe_ipv6_ip_proc
+ 	 * If skb_dst(skb)->xfrm is not null, packet is to be encrypted by ipsec, we can't accelerate it.
+ 	 * If skb->sp is not null, packet is decrypted by ipsec. We only accelerate it when configuration didn't reject ipsec.
+ 	 */
+-	if (unlikely((skb_dst(skb) && skb_dst(skb)->xfrm) || (ecm_sfe_ipv6_reject_acceleration_for_ipsec && skb->sp))) {
++	if (unlikely((skb_dst(skb) && skb_dst(skb)->xfrm) || \
++		     (ecm_sfe_ipv6_reject_acceleration_for_ipsec && skb_ext_exist(skb, SKB_EXT_SEC_PATH)))) {
+ 		DEBUG_TRACE("skip local ipsec flows\n");
+ 		return NF_ACCEPT;
+ 	}
+@@ -733,7 +733,7 @@ static unsigned int ecm_sfe_ipv6_ip_proc
+ 		ECM_IP_ADDR_TO_NIN6_ADDR(reply_tuple.dst.u3.in6, ip_hdr.src_addr);
+ 		sender = ECM_TRACKER_SENDER_TYPE_SRC;
+ 	} else {
+-		if (unlikely(ct == &nf_conntrack_untracked)) {
++		if (unlikely(ctinfo == IP_CT_UNTRACKED)) {
+ 			DEBUG_TRACE("%p: ct: untracked\n", skb);
+ 			return NF_ACCEPT;
+ 		}
+@@ -1255,7 +1255,6 @@ sync_conntrack:
+ 	}
+ 
+ 	ct = nf_ct_tuplehash_to_ctrack(h);
+-	NF_CT_ASSERT(ct->timeout.data == (unsigned long)ct);
+ 	DEBUG_TRACE("%p: SFE Sync: conntrack connection\n", ct);
+ 
+ 	ecm_front_end_flow_and_return_directions_get(ct, flow_ip, 6, &flow_dir, &return_dir);
+@@ -1275,7 +1274,7 @@ sync_conntrack:
+ 		delta_jiffies = ((sync->inc_ticks * HZ) + (MSEC_PER_SEC / 2)) / MSEC_PER_SEC;
+ 
+ 		spin_lock_bh(&ct->lock);
+-		ct->timeout.expires += delta_jiffies;
++		ct->timeout += delta_jiffies;
+ 		spin_unlock_bh(&ct->lock);
+ 	}
+ #if (LINUX_VERSION_CODE <= KERNEL_VERSION(3,6,0))
+@@ -1332,17 +1331,15 @@ sync_conntrack:
+ 			u_int64_t reply_pkts = atomic64_read(&acct[IP_CT_DIR_REPLY].packets);
+ 
+ 			if (reply_pkts != 0) {
+-				struct nf_conntrack_l4proto *l4proto;
+ 				unsigned int *timeouts;
+ 
+ 				set_bit(IPS_SEEN_REPLY_BIT, &ct->status);
+ 				set_bit(IPS_ASSURED_BIT, &ct->status);
+ 
+-				l4proto = __nf_ct_l4proto_find(AF_INET6, IPPROTO_UDP);
+-				timeouts = nf_ct_timeout_lookup(&init_net, ct, l4proto);
++				timeouts = nf_ct_timeout_lookup(ct);
+ 
+ 				spin_lock_bh(&ct->lock);
+-				ct->timeout.expires = jiffies + timeouts[UDP_CT_REPLIED];
++				ct->timeout = jiffies + timeouts[UDP_CT_REPLIED];
+ 				spin_unlock_bh(&ct->lock);
+ 			}
+ 		}
+@@ -1624,7 +1621,7 @@ int ecm_sfe_ipv6_init(struct dentry *den
+ 	/*
+ 	 * Register netfilter hooks
+ 	 */
+-	result = nf_register_hooks(ecm_sfe_ipv6_netfilter_hooks, ARRAY_SIZE(ecm_sfe_ipv6_netfilter_hooks));
++	result = nf_register_net_hooks(&init_net, ecm_sfe_ipv6_netfilter_hooks, ARRAY_SIZE(ecm_sfe_ipv6_netfilter_hooks));
+ 	if (result < 0) {
+ 		DEBUG_ERROR("Can't register netfilter hooks.\n");
+ 		sfe_drv_ipv6_notify_unregister();
+@@ -1656,8 +1653,8 @@ void ecm_sfe_ipv6_exit(void)
+ 	/*
+ 	 * Stop the network stack hooks
+ 	 */
+-	nf_unregister_hooks(ecm_sfe_ipv6_netfilter_hooks,
+-			    ARRAY_SIZE(ecm_sfe_ipv6_netfilter_hooks));
++	nf_unregister_net_hooks(&init_net, ecm_sfe_ipv6_netfilter_hooks,
++				ARRAY_SIZE(ecm_sfe_ipv6_netfilter_hooks));
+ 
+ 	/*
+ 	 * Unregister from the Linux SFE Network driver
+--- a/frontends/sfe/ecm_sfe_non_ported_ipv4.c
++++ b/frontends/sfe/ecm_sfe_non_ported_ipv4.c
+@@ -46,7 +46,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+@@ -1829,7 +1828,7 @@ unsigned int ecm_sfe_non_ported_ipv4_pro
+ 		/*
+ 		 * Packet has been decrypted by ipsec, mark it in connection.
+ 		 */
+-		if (unlikely(skb->sp)) {
++		if (unlikely(skb_ext_exist(skb, SKB_EXT_SEC_PATH))) {
+ 			((struct ecm_sfe_non_ported_ipv4_connection_instance *)feci)->flow_ipsec_state = ECM_SFE_IPSEC_STATE_WAS_DECRYPTED;
+ 			((struct ecm_sfe_non_ported_ipv4_connection_instance *)feci)->return_ipsec_state = ECM_SFE_IPSEC_STATE_TO_ENCRYPT;
+ 		}
+--- a/frontends/sfe/ecm_sfe_non_ported_ipv6.c
++++ b/frontends/sfe/ecm_sfe_non_ported_ipv6.c
+@@ -47,7 +47,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+@@ -1710,7 +1709,7 @@ unsigned int ecm_sfe_non_ported_ipv6_pro
+ 		/*
+ 		 * Packet has been decrypted by ipsec, mark it in connection.
+ 		 */
+-		if (unlikely(skb->sp)) {
++		if (unlikely(skb_ext_exist(skb, SKB_EXT_SEC_PATH))) {
+ 			((struct ecm_sfe_non_ported_ipv6_connection_instance *)feci)->flow_ipsec_state = ECM_SFE_IPSEC_STATE_WAS_DECRYPTED;
+ 			((struct ecm_sfe_non_ported_ipv6_connection_instance *)feci)->return_ipsec_state = ECM_SFE_IPSEC_STATE_TO_ENCRYPT;
+ 		}
+--- a/frontends/sfe/ecm_sfe_ported_ipv4.c
++++ b/frontends/sfe/ecm_sfe_ported_ipv4.c
+@@ -46,7 +46,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+@@ -2053,7 +2052,7 @@ unsigned int ecm_sfe_ported_ipv4_process
+ 		/*
+ 		 * Packet has been decrypted by ipsec, mark it in connection.
+ 		 */
+-		if (unlikely(skb->sp)) {
++		if (unlikely(skb_ext_exist(skb, SKB_EXT_SEC_PATH))) {
+ 			((struct ecm_sfe_ported_ipv4_connection_instance *)feci)->flow_ipsec_state = ECM_SFE_IPSEC_STATE_WAS_DECRYPTED;
+ 			((struct ecm_sfe_ported_ipv4_connection_instance *)feci)->return_ipsec_state = ECM_SFE_IPSEC_STATE_TO_ENCRYPT;
+ 		}
+--- a/frontends/sfe/ecm_sfe_ported_ipv6.c
++++ b/frontends/sfe/ecm_sfe_ported_ipv6.c
+@@ -47,7 +47,6 @@
+ #include <net/netfilter/nf_conntrack_acct.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_l4proto.h>
+-#include <net/netfilter/nf_conntrack_l3proto.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_core.h>
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+@@ -1826,7 +1825,7 @@ unsigned int ecm_sfe_ported_ipv6_process
+ 		/*
+ 		 * Deny acceleration for L2TP-over-UDP tunnel
+ 		 */
+-		if ((in_dev->priv_flags & IFF_PPP_L2TPV2) && ppp_is_xmit_locked(in_dev)) {
++		if ((in_dev->priv_flags_qca_ecm & IFF_QCA_ECM_PPP_L2TPV2) && ppp_is_xmit_locked(in_dev)) {
+ 			DEBUG_TRACE("Skip packets for L2TP tunnel in skb %p\n", skb);
+ 			can_accel = false;
+ 		}
+@@ -1958,7 +1957,7 @@ unsigned int ecm_sfe_ported_ipv6_process
+ 		/*
+ 		 * Packet has been decrypted by ipsec, mark it in connection.
+ 		 */
+-		if (unlikely(skb->sp)) {
++		if (unlikely(skb_ext_exist(skb, SKB_EXT_SEC_PATH))) {
+ 			((struct ecm_sfe_ported_ipv6_connection_instance *)feci)->flow_ipsec_state = ECM_SFE_IPSEC_STATE_WAS_DECRYPTED;
+ 			((struct ecm_sfe_ported_ipv6_connection_instance *)feci)->return_ipsec_state = ECM_SFE_IPSEC_STATE_TO_ENCRYPT;
+ 		}
diff --git a/package/qca/qca-nss-ecm/patches/101-Fix_Kern_Panic_on_UDP_CONNTRACK.patch b/package/qca/qca-nss-ecm/patches/101-Fix_Kern_Panic_on_UDP_CONNTRACK.patch
new file mode 100644
index 0000000000..6633f72b44
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/101-Fix_Kern_Panic_on_UDP_CONNTRACK.patch
@@ -0,0 +1,60 @@
+diff --git a/frontends/nss/ecm_nss_ipv4.c b/frontends/nss/ecm_nss_ipv4.c
+index 1ce4b61..29e70ba 100644
+--- a/frontends/nss/ecm_nss_ipv4.c
++++ b/frontends/nss/ecm_nss_ipv4.c
+@@ -2171,6 +2171,10 @@ sync_conntrack:
+ 
+ 				timeouts = nf_ct_timeout_lookup(ct);
+ 
++				/* Copy of udp_get_timeouts in kernel */
++				if (!timeouts)
++					timeouts = nf_udp_pernet(nf_ct_net(ct))->timeouts;
++
+ 				spin_lock_bh(&ct->lock);
+ 				ct->timeout = jiffies + timeouts[UDP_CT_REPLIED];
+ 				spin_unlock_bh(&ct->lock);
+diff --git a/frontends/nss/ecm_nss_ipv6.c b/frontends/nss/ecm_nss_ipv6.c
+index 2adc5ec..08253b6 100644
+--- a/frontends/nss/ecm_nss_ipv6.c
++++ b/frontends/nss/ecm_nss_ipv6.c
+@@ -1883,6 +1883,10 @@ sync_conntrack:
+ 
+ 				timeouts = nf_ct_timeout_lookup(ct);
+ 
++				/* Copy of udp_get_timeouts in kernel */
++				if (!timeouts)
++					timeouts = nf_udp_pernet(nf_ct_net(ct))->timeouts;
++
+ 				spin_lock_bh(&ct->lock);
+ 				ct->timeout = jiffies + timeouts[UDP_CT_REPLIED];
+ 				spin_unlock_bh(&ct->lock);
+diff --git a/frontends/sfe/ecm_sfe_ipv4.c b/frontends/sfe/ecm_sfe_ipv4.c
+index 7cfe4fc..8f525ee 100644
+--- a/frontends/sfe/ecm_sfe_ipv4.c
++++ b/frontends/sfe/ecm_sfe_ipv4.c
+@@ -1608,6 +1608,10 @@ sync_conntrack:
+ 
+ 				timeouts = nf_ct_timeout_lookup(ct);
+ 
++				/* Copy of udp_get_timeouts in kernel */
++				if (!timeouts)
++					timeouts = nf_udp_pernet(nf_ct_net(ct))->timeouts;
++
+ 				spin_lock_bh(&ct->lock);
+ 				ct->timeout = jiffies + timeouts[UDP_CT_REPLIED];
+ 				spin_unlock_bh(&ct->lock);
+diff --git a/frontends/sfe/ecm_sfe_ipv6.c b/frontends/sfe/ecm_sfe_ipv6.c
+index dfde309..47c531a 100644
+--- a/frontends/sfe/ecm_sfe_ipv6.c
++++ b/frontends/sfe/ecm_sfe_ipv6.c
+@@ -1321,6 +1321,10 @@ sync_conntrack:
+ 
+ 				timeouts = nf_ct_timeout_lookup(ct);
+ 
++				/* Copy of udp_get_timeouts in kernel */
++				if (!timeouts)
++					timeouts = nf_udp_pernet(nf_ct_net(ct))->timeouts;
++
+ 				spin_lock_bh(&ct->lock);
+ 				ct->timeout = jiffies + timeouts[UDP_CT_REPLIED];
+ 				spin_unlock_bh(&ct->lock);
diff --git a/package/qca/qca-nss-ecm/patches/200-resolve-high-load.patch b/package/qca/qca-nss-ecm/patches/200-resolve-high-load.patch
new file mode 100644
index 0000000000..2f39d2770e
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/200-resolve-high-load.patch
@@ -0,0 +1,44 @@
+The sync update work queue tasks is calling uninterruptible sleep function, which is
+causing high CPU load.  Changed to interruptible sleep function.  The stats update
+task should be interruptible.
+
+--- a/frontends/nss/ecm_nss_ipv4.c
++++ b.frontends/nss/ecm_nss_ipv4.c
+@@ -2411,7 +2411,7 @@ static void ecm_nss_ipv4_stats_sync_req_
+ 	}
+ 	spin_unlock_bh(&ecm_nss_ipv4_lock);
+ 
+-	usleep_range(ECM_NSS_IPV4_STATS_SYNC_UDELAY - 100, ECM_NSS_IPV4_STATS_SYNC_UDELAY);
++	msleep_interruptible(ECM_NSS_IPV4_STATS_SYNC_UDELAY / 1000);
+ 
+ 	/*
+ 	 * If index is 0, we are starting a new round, but if we still have time remain
+@@ -2425,7 +2425,7 @@ static void ecm_nss_ipv4_stats_sync_req_
+ 		}
+ 
+ 		if (ecm_nss_ipv4_next_req_time > current_jiffies) {
+-			msleep(jiffies_to_msecs(ecm_nss_ipv4_next_req_time - current_jiffies));
++			msleep_interruptible(jiffies_to_msecs(ecm_nss_ipv4_next_req_time - current_jiffies));
+ 		}
+ 		ecm_nss_ipv4_roll_check_jiffies = jiffies;
+ 		ecm_nss_ipv4_next_req_time = ecm_nss_ipv4_roll_check_jiffies + ECM_NSS_IPV4_STATS_SYNC_PERIOD;
+--- a/frontends/nss/ecm_nss_ipv6.c
++++ b.frontends/nss/ecm_nss_ipv6.c
+@@ -2128,7 +2128,7 @@ static void ecm_nss_ipv6_stats_sync_req_
+ 	}
+ 	spin_unlock_bh(&ecm_nss_ipv6_lock);
+ 
+-	usleep_range(ECM_NSS_IPV6_STATS_SYNC_UDELAY - 100, ECM_NSS_IPV6_STATS_SYNC_UDELAY);
++	msleep_interruptible(ECM_NSS_IPV6_STATS_SYNC_UDELAY / 1000);
+ 
+ 	/*
+ 	 * If index is 0, we are starting a new round, but if we still have time remain
+@@ -2142,7 +2142,7 @@ static void ecm_nss_ipv6_stats_sync_req_
+ 		}
+ 
+ 		if (ecm_nss_ipv6_next_req_time > current_jiffies) {
+-			msleep(jiffies_to_msecs(ecm_nss_ipv6_next_req_time - current_jiffies));
++			msleep_interruptible(jiffies_to_msecs(ecm_nss_ipv6_next_req_time - current_jiffies));
+ 		}
+ 		ecm_nss_ipv6_roll_check_jiffies = jiffies;
+ 		ecm_nss_ipv6_next_req_time = ecm_nss_ipv6_roll_check_jiffies + ECM_NSS_IPV6_STATS_SYNC_PERIOD;
diff --git a/package/qca/qca-nss-ecm/patches/203-rework-nfct-notification.patch b/package/qca/qca-nss-ecm/patches/203-rework-nfct-notification.patch
new file mode 100644
index 0000000000..a0e09c1fae
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/203-rework-nfct-notification.patch
@@ -0,0 +1,20 @@
+--- a/ecm_conntrack_notifier.c
++++ b/ecm_conntrack_notifier.c
+@@ -411,7 +411,7 @@ int ecm_conntrack_notifier_init(struct d
+ 	/*
+ 	 * Eventing subsystem is available so we register a notifier hook to get fast notifications of expired connections
+ 	 */
+-	result = nf_conntrack_register_notifier(&init_net, &ecm_conntrack_notifier);
++	result = nf_conntrack_register_chain_notifier(&init_net, &ecm_conntrack_notifier);
+ 	if (result < 0) {
+ 		DEBUG_ERROR("Can't register nf notifier hook.\n");
+ 		debugfs_remove_recursive(ecm_conntrack_notifier_dentry);
+@@ -430,7 +430,7 @@ void ecm_conntrack_notifier_exit(void)
+ {
+ 	DEBUG_INFO("ECM Conntrack Notifier exit\n");
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+-	nf_conntrack_unregister_notifier(&init_net, &ecm_conntrack_notifier);
++	nf_conntrack_unregister_chain_notifier(&init_net, &ecm_conntrack_notifier);
+ #endif
+ 	/*
+ 	 * Remove the debugfs files recursively.
diff --git a/package/qca/qca-nss-ecm/patches/400-Check-TCP_UDP-conntrack-state-earlier.patch b/package/qca/qca-nss-ecm/patches/400-Check-TCP_UDP-conntrack-state-earlier.patch
new file mode 100644
index 0000000000..b7882c1b3f
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/400-Check-TCP_UDP-conntrack-state-earlier.patch
@@ -0,0 +1,236 @@
+From 90cace88a342e77ee8ca1e961cf7b7a7930d4c89 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Mon, 9 Mar 2020 12:51:03 -0700
+Subject: [qca-nss-ecm] Check TCP/UDP conntrack state earlier
+
+Check the conntrack state before processing the flow
+and adding it to the database. The unconfirmed
+connections can be changed after the confirmation.
+
+Changed the TCP tracker connection state matrix to set the
+state of the connection as ESTABLISHED when any of the src or
+dest side is set as ESTABLISHED. With this change ECM will not
+handle the SYN and SYN-ACK packets of the TCP handshake. Only the
+ACK and FIN flaged packets will be used during the creation and
+closing the connection respectively.
+
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Change-Id: I3e0a58d604df4c6a85478ca9c05f24d50cd8c894
+---
+ ecm_classifier_default.c            | 36 ++++++++----------------------------
+ ecm_tracker_tcp.c                   |  4 ++--
+ frontends/nss/ecm_nss_ported_ipv4.c | 17 +++++++++++++++++
+ frontends/nss/ecm_nss_ported_ipv6.c | 17 +++++++++++++++++
+ frontends/sfe/ecm_sfe_ported_ipv4.c | 17 +++++++++++++++++
+ frontends/sfe/ecm_sfe_ported_ipv6.c | 17 +++++++++++++++++
+ 6 files changed, 78 insertions(+), 30 deletions(-)
+
+diff --git a/ecm_classifier_default.c b/ecm_classifier_default.c
+index 22c4bec..d04cdfa 100644
+--- a/ecm_classifier_default.c
++++ b/ecm_classifier_default.c
+@@ -1,6 +1,6 @@
+ /*
+  **************************************************************************
+- * Copyright (c) 2014-2016, The Linux Foundation.  All rights reserved.
++ * Copyright (c) 2014-2016, 2020, The Linux Foundation.  All rights reserved.
+  * Permission to use, copy, modify, and/or distribute this software for
+  * any purpose with or without fee is hereby granted, provided that the
+  * above copyright notice and this permission notice appear in all copies.
+@@ -285,12 +285,12 @@ static void ecm_classifier_default_process(struct ecm_classifier_instance *aci,
+ 	}
+ 
+ 	/*
+-	 * Check the TCP connection state.
++	 * Check the TCP connection state, when the ct is NULL.
++	 * ct valid case was already checked in the ecm_nss{sfe}_ported_ipv4{6}_process functions.
+ 	 * If we are not established then we deny acceleration.
+-	 * Take lead from conntrack if exists.
+ 	 */
+ 	ct = nf_ct_get(skb, &ctinfo);
+-	if (ct == NULL) {
++	if (!ct) {
+ 		DEBUG_TRACE("%p: No Conntrack found for packet, using ECM tracker state\n", cdii);
+ 		if (unlikely(prevailing_state != ECM_TRACKER_CONNECTION_STATE_ESTABLISHED)) {
+ 			cdii->process_response.accel_mode = ECM_CLASSIFIER_ACCELERATION_MODE_NO;
+@@ -298,29 +298,10 @@ static void ecm_classifier_default_process(struct ecm_classifier_instance *aci,
+ 		}
+ 	} else {
+ 		/*
+-		 * Unconfirmed connection may be dropped by Linux at the final step,
+-		 * So we don't allow acceleration for the unconfirmed connections.
+-		 */
+-		if (!nf_ct_is_confirmed(ct)) {
+-			DEBUG_TRACE("%p: Unconfirmed connection\n", ct);
+-			cdii->process_response.accel_mode = ECM_CLASSIFIER_ACCELERATION_MODE_NO;
+-			goto return_response;
+-		}
+-
+-		/*
+-		 * Don't try to manage a non-established connection.
+-		 */
+-		if (!test_bit(IPS_ASSURED_BIT, &ct->status)) {
+-			DEBUG_TRACE("%p: Non-established connection\n", ct);
+-			cdii->process_response.accel_mode = ECM_CLASSIFIER_ACCELERATION_MODE_NO;
+-			goto return_response;
+-		}
+-
+-		/*
+-		 * If the connection is shutting down do not manage it.
+-		 * state can not be SYN_SENT, SYN_RECV because connection is assured
+-		 * Not managed states: FIN_WAIT, CLOSE_WAIT, LAST_ACK, TIME_WAIT, CLOSE.
+-		 */
++		* If the connection is shutting down do not manage it.
++		* state can not be SYN_SENT, SYN_RECV because connection is assured
++		* Not managed states: FIN_WAIT, CLOSE_WAIT, LAST_ACK, TIME_WAIT, CLOSE.
++		*/
+ 		spin_lock_bh(&ct->lock);
+ 		if (ct->proto.tcp.state != TCP_CONNTRACK_ESTABLISHED) {
+ 			spin_unlock_bh(&ct->lock);
+@@ -333,7 +314,6 @@ static void ecm_classifier_default_process(struct ecm_classifier_instance *aci,
+ 
+ return_response:
+ 	;
+-
+ 	/*
+ 	 * Return the process response
+ 	 */
+diff --git a/ecm_tracker_tcp.c b/ecm_tracker_tcp.c
+index f073c36..e5b327a 100644
+--- a/ecm_tracker_tcp.c
++++ b/ecm_tracker_tcp.c
+@@ -257,9 +257,9 @@ static  DEFINE_SPINLOCK(ecm_tracker_tcp_lock);	/* Global lock for the tracker gl
+  */
+ static ecm_tracker_connection_state_t ecm_tracker_tcp_connection_state_matrix[ECM_TRACKER_SENDER_STATE_MAX][ECM_TRACKER_SENDER_STATE_MAX] =
+ {	/* 			Unknown						Establishing					Established					Closing					Closed					Fault */
+-	/* Unknown */		{ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_FAULT,	ECM_TRACKER_CONNECTION_STATE_FAULT,	ECM_TRACKER_CONNECTION_STATE_FAULT},
++	/* Unknown */		{ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHED,	ECM_TRACKER_CONNECTION_STATE_FAULT,	ECM_TRACKER_CONNECTION_STATE_FAULT,	ECM_TRACKER_CONNECTION_STATE_FAULT},
+ 	/* Establishing */	{ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_FAULT,	ECM_TRACKER_CONNECTION_STATE_FAULT,	ECM_TRACKER_CONNECTION_STATE_FAULT},
+-	/* Established */	{ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHED,	ECM_TRACKER_CONNECTION_STATE_CLOSING,	ECM_TRACKER_CONNECTION_STATE_CLOSING,	ECM_TRACKER_CONNECTION_STATE_FAULT},
++	/* Established */	{ECM_TRACKER_CONNECTION_STATE_ESTABLISHED,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHING,	ECM_TRACKER_CONNECTION_STATE_ESTABLISHED,	ECM_TRACKER_CONNECTION_STATE_CLOSING,	ECM_TRACKER_CONNECTION_STATE_CLOSING,	ECM_TRACKER_CONNECTION_STATE_FAULT},
+ 	/* Closing */		{ECM_TRACKER_CONNECTION_STATE_FAULT,		ECM_TRACKER_CONNECTION_STATE_FAULT,		ECM_TRACKER_CONNECTION_STATE_CLOSING,		ECM_TRACKER_CONNECTION_STATE_CLOSING,	ECM_TRACKER_CONNECTION_STATE_CLOSING,	ECM_TRACKER_CONNECTION_STATE_FAULT},
+ 	/* Closed */		{ECM_TRACKER_CONNECTION_STATE_FAULT,		ECM_TRACKER_CONNECTION_STATE_FAULT,		ECM_TRACKER_CONNECTION_STATE_CLOSING,		ECM_TRACKER_CONNECTION_STATE_CLOSING,	ECM_TRACKER_CONNECTION_STATE_CLOSED, 	ECM_TRACKER_CONNECTION_STATE_FAULT},
+ 	/* Fault */		{ECM_TRACKER_CONNECTION_STATE_FAULT,		ECM_TRACKER_CONNECTION_STATE_FAULT,		ECM_TRACKER_CONNECTION_STATE_FAULT,		ECM_TRACKER_CONNECTION_STATE_FAULT,	ECM_TRACKER_CONNECTION_STATE_FAULT,	ECM_TRACKER_CONNECTION_STATE_FAULT},
+diff --git a/frontends/nss/ecm_nss_ported_ipv4.c b/frontends/nss/ecm_nss_ported_ipv4.c
+index 1435ec0..34c056f 100644
+--- a/frontends/nss/ecm_nss_ported_ipv4.c
++++ b/frontends/nss/ecm_nss_ported_ipv4.c
+@@ -2002,8 +2002,25 @@ unsigned int ecm_nss_ported_ipv4_process(struct net_device *out_dev, struct net_
+ 	int protocol = (int)orig_tuple->dst.protonum;
+ 	__be16 *layer4hdr = NULL;
+ 
++	/*
++	 * Unconfirmed connection may be dropped by Linux at the final step,
++	 * So we don't allow acceleration for the unconfirmed connections.
++	 */
++	if (likely(ct) && !nf_ct_is_confirmed(ct)) {
++		DEBUG_WARN("%p: Unconfirmed connection\n", ct);
++		return NF_ACCEPT;
++	}
++
+ 	if (protocol == IPPROTO_TCP) {
+ 		/*
++		 * Don't try to manage a non-established connection.
++		 */
++		if (likely(ct) && !test_bit(IPS_ASSURED_BIT, &ct->status)) {
++			DEBUG_WARN("%p: Non-established TCP connection\n", ct);
++			return NF_ACCEPT;
++		}
++
++		/*
+ 		 * Extract TCP header to obtain port information
+ 		 */
+ 		tcp_hdr = ecm_tracker_tcp_check_header_and_read(skb, iph, &tcp_hdr_buff);
+diff --git a/frontends/nss/ecm_nss_ported_ipv6.c b/frontends/nss/ecm_nss_ported_ipv6.c
+index 4c154a6..bd6349b 100644
+--- a/frontends/nss/ecm_nss_ported_ipv6.c
++++ b/frontends/nss/ecm_nss_ported_ipv6.c
+@@ -1914,8 +1914,25 @@ unsigned int ecm_nss_ported_ipv6_process(struct net_device *out_dev,
+ 	int protocol = (int)orig_tuple->dst.protonum;
+ 	__be16 *layer4hdr = NULL;
+ 
++	/*
++	 * Unconfirmed connection may be dropped by Linux at the final step,
++	 * So we don't allow acceleration for the unconfirmed connections.
++	 */
++	if (likely(ct) && !nf_ct_is_confirmed(ct)) {
++		DEBUG_WARN("%p: Unconfirmed connection\n", ct);
++		return NF_ACCEPT;
++	}
++
+ 	if (protocol == IPPROTO_TCP) {
+ 		/*
++		 * Don't try to manage a non-established connection.
++		 */
++		if (likely(ct) && !test_bit(IPS_ASSURED_BIT, &ct->status)) {
++			DEBUG_WARN("%p: Non-established TCP connection\n", ct);
++			return NF_ACCEPT;
++		}
++
++		/*
+ 		 * Extract TCP header to obtain port information
+ 		 */
+ 		tcp_hdr = ecm_tracker_tcp_check_header_and_read(skb, iph, &tcp_hdr_buff);
+diff --git a/frontends/sfe/ecm_sfe_ported_ipv4.c b/frontends/sfe/ecm_sfe_ported_ipv4.c
+index e034cde..df1ce57 100644
+--- a/frontends/sfe/ecm_sfe_ported_ipv4.c
++++ b/frontends/sfe/ecm_sfe_ported_ipv4.c
+@@ -1805,8 +1805,25 @@ unsigned int ecm_sfe_ported_ipv4_process(struct net_device *out_dev, struct net_
+ 	int protocol = (int)orig_tuple->dst.protonum;
+ 	__be16 *layer4hdr = NULL;
+ 
++	/*
++	 * Unconfirmed connection may be dropped by Linux at the final step,
++	 * So we don't allow acceleration for the unconfirmed connections.
++	 */
++	if (likely(ct) && !nf_ct_is_confirmed(ct)) {
++		DEBUG_WARN("%p: Unconfirmed connection\n", ct);
++		return NF_ACCEPT;
++	}
++
+ 	if (protocol == IPPROTO_TCP) {
+ 		/*
++		 * Don't try to manage a non-established connection.
++		 */
++		if (likely(ct) && !test_bit(IPS_ASSURED_BIT, &ct->status)) {
++			DEBUG_WARN("%p: Non-established TCP connection\n", ct);
++			return NF_ACCEPT;
++		}
++
++		/*
+ 		 * Extract TCP header to obtain port information
+ 		 */
+ 		tcp_hdr = ecm_tracker_tcp_check_header_and_read(skb, iph, &tcp_hdr_buff);
+diff --git a/frontends/sfe/ecm_sfe_ported_ipv6.c b/frontends/sfe/ecm_sfe_ported_ipv6.c
+index 6ac05ad..657a1c7 100644
+--- a/frontends/sfe/ecm_sfe_ported_ipv6.c
++++ b/frontends/sfe/ecm_sfe_ported_ipv6.c
+@@ -1746,8 +1746,25 @@ unsigned int ecm_sfe_ported_ipv6_process(struct net_device *out_dev,
+ 	int protocol = (int)orig_tuple->dst.protonum;
+ 	__be16 *layer4hdr = NULL;
+ 
++	/*
++	 * Unconfirmed connection may be dropped by Linux at the final step,
++	 * So we don't allow acceleration for the unconfirmed connections.
++	 */
++	if (likely(ct) && !nf_ct_is_confirmed(ct)) {
++		DEBUG_WARN("%p: Unconfirmed connection\n", ct);
++		return NF_ACCEPT;
++	}
++
+ 	if (protocol == IPPROTO_TCP) {
+ 		/*
++		 * Don't try to manage a non-established connection.
++		 */
++		if (likely(ct) && !test_bit(IPS_ASSURED_BIT, &ct->status)) {
++			DEBUG_WARN("%p: Non-established TCP connection\n", ct);
++			return NF_ACCEPT;
++		}
++
++		/*
+ 		 * Extract TCP header to obtain port information
+ 		 */
+ 		tcp_hdr = ecm_tracker_tcp_check_header_and_read(skb, iph, &tcp_hdr_buff);
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/patches/401-Fix-NSS-stats-request-roll-over-issue.patch b/package/qca/qca-nss-ecm/patches/401-Fix-NSS-stats-request-roll-over-issue.patch
new file mode 100644
index 0000000000..217054bb7c
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/401-Fix-NSS-stats-request-roll-over-issue.patch
@@ -0,0 +1,52 @@
+From 9ad19ffdcfdf77baf3abd4fcc933fd3dc8e791a5 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Sat, 20 Jun 2020 09:41:01 -0700
+Subject: [qca-nss-ecm] Fix NSS stats request roll over issue
+
+Use the correct timer API to check the next request time
+when jiffies wrap happens.
+
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Change-Id: I18646d28df7e17daeff2986dfe4bd73866d47668
+---
+ frontends/nss/ecm_nss_ipv4.c | 4 ++--
+ frontends/nss/ecm_nss_ipv6.c | 4 ++--
+ 2 files changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/frontends/nss/ecm_nss_ipv4.c b/frontends/nss/ecm_nss_ipv4.c
+index 3eaf5d8..80e1aee 100644
+--- a/frontends/nss/ecm_nss_ipv4.c
++++ b/frontends/nss/ecm_nss_ipv4.c
+@@ -2421,10 +2421,10 @@ static void ecm_nss_ipv4_stats_sync_req_work(struct work_struct *work)
+ 		current_jiffies = jiffies;
+ 
+ 		if (time_is_after_jiffies(ecm_nss_ipv4_roll_check_jiffies))  {
+-			ecm_nss_ipv4_next_req_time = 0;
++			ecm_nss_ipv4_next_req_time = jiffies + ECM_NSS_IPV4_STATS_SYNC_PERIOD;
+ 		}
+ 
+-		if (ecm_nss_ipv4_next_req_time > current_jiffies) {
++		if (time_after(ecm_nss_ipv4_next_req_time, current_jiffies)) {
+ 			msleep_interruptible(jiffies_to_msecs(ecm_nss_ipv4_next_req_time - current_jiffies));
+ 		}
+ 		ecm_nss_ipv4_roll_check_jiffies = jiffies;
+diff --git a/frontends/nss/ecm_nss_ipv6.c b/frontends/nss/ecm_nss_ipv6.c
+index 288dc55..483421e 100644
+--- a/frontends/nss/ecm_nss_ipv6.c
++++ b/frontends/nss/ecm_nss_ipv6.c
+@@ -2135,10 +2135,10 @@ static void ecm_nss_ipv6_stats_sync_req_work(struct work_struct *work)
+ 		current_jiffies = jiffies;
+ 
+ 		if (time_is_after_jiffies(ecm_nss_ipv6_roll_check_jiffies))  {
+-			ecm_nss_ipv6_next_req_time = 0;
++			ecm_nss_ipv6_next_req_time = jiffies + ECM_NSS_IPV6_STATS_SYNC_PERIOD;
+ 		}
+ 
+-		if (ecm_nss_ipv6_next_req_time > current_jiffies) {
++		if (time_after(ecm_nss_ipv6_next_req_time, current_jiffies)) {
+ 			msleep_interruptible(jiffies_to_msecs(ecm_nss_ipv6_next_req_time - current_jiffies));
+ 		}
+ 		ecm_nss_ipv6_roll_check_jiffies = jiffies;
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/patches/401-Fix-for-ref-leak-during-multicast.patch b/package/qca/qca-nss-ecm/patches/401-Fix-for-ref-leak-during-multicast.patch
new file mode 100644
index 0000000000..e1df653b7f
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/401-Fix-for-ref-leak-during-multicast.patch
@@ -0,0 +1,112 @@
+From 4b41703a181b7187d9ff8cb744eb96d09997387c Mon Sep 17 00:00:00 2001
+From: Suman Ghosh <sumaghos@codeaurora.org>
+Date: Wed, 19 Feb 2020 15:09:19 +0530
+Subject: [qca-nss-ecm] Fix for ref leak during multicast 'to' hierarchy
+ creation
+
+Change-Id: I89df9dbe5ea054cf3b87d55ce68a751cb1d6c24f
+Signed-off-by: Suman Ghosh <sumaghos@codeaurora.org>
+---
+ ecm_interface.c | 34 ++++++++++++++++++++++++++++++----
+ 1 file changed, 30 insertions(+), 4 deletions(-)
+
+diff --git a/ecm_interface.c b/ecm_interface.c
+index 4f7a886..2a0ca5b 100644
+--- a/ecm_interface.c
++++ b/ecm_interface.c
+@@ -3885,13 +3885,13 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 		dest_dev = dev_get_by_index(&init_net, *dst_if_index);
+ 		if (!dest_dev) {
+ 			if (!src_dev_is_bridge) {
+-				int i;
+-
+ 				/*
+ 				 * If already constructed any interface heirarchies before hitting
+ 				 * this error condition then Deref all interface heirarchies.
+ 				 */
+ 				if (valid_if > 0) {
++					int i;
++
+ 					for (i = 0; i < valid_if; i++) {
+ 						ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, i);
+ 						ecm_db_multicast_copy_if_heirarchy(to_list_single, ifaces);
+@@ -3902,11 +3902,14 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 				/*
+ 				 * If valid netdev not found, Return 0
+ 				 */
++				if (br_dev_src) {
++					dev_put(br_dev_src);
++				}
++
+ 				return 0;
+ 			}
+ 
+ 			dest_dev = br_dev_src;
+-
+ 		}
+ 
+ 		dest_dev_type = dest_dev->type;
+@@ -3945,6 +3948,10 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 					}
+ 				}
+ 
++				if (br_dev_src && (dest_dev != br_dev_src)) {
++					dev_put(br_dev_src);
++				}
++
+ 				dev_put(dest_dev);
+ 				return 0;
+ 			}
+@@ -3972,6 +3979,10 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 						ecm_db_connection_interfaces_deref(to_list_single, interface_first_base[i]);
+ 					}
+ 
++					if (br_dev_src && (dest_dev != br_dev_src)) {
++						dev_put(br_dev_src);
++					}
++
+ 					dev_put(dest_dev);
+ 					dev_put(mc_br_slave_dev);
+ 					return 0;
+@@ -3997,6 +4008,10 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 						}
+ 					}
+ 
++					if (br_dev_src && (dest_dev != br_dev_src)) {
++						dev_put(br_dev_src);
++					}
++
+ 					dev_put(dest_dev);
+ 					dev_put(mc_br_slave_dev);
+ 					return 0;
+@@ -4032,6 +4047,10 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 					}
+ 				}
+ 
++				if (br_dev_src && (dest_dev != br_dev_src)) {
++					dev_put(br_dev_src);
++				}
++
+ 				dev_put(dest_dev);
+ 				return 0;
+ 			}
+@@ -4042,8 +4061,15 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 			valid_if++;
+ 		}
+ 
+-		dev_put(dest_dev);
++		if (dest_dev != br_dev_src) {
++			dev_put(dest_dev);
++		}
+ 	}
++
++	if (br_dev_src) {
++		dev_put(br_dev_src);
++	}
++
+ 	return total_ii_count;
+ }
+ EXPORT_SYMBOL(ecm_interface_multicast_heirarchy_construct_routed);
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/patches/401-Fix-neighbour-solicitation-send-function.patch b/package/qca/qca-nss-ecm/patches/401-Fix-neighbour-solicitation-send-function.patch
new file mode 100644
index 0000000000..7d32d6fd5a
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/401-Fix-neighbour-solicitation-send-function.patch
@@ -0,0 +1,33 @@
+From 72e3ae508906553e7bc982bf3c0d99bb1cbe9008 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Wed, 20 Nov 2019 16:23:06 -0800
+Subject: [qca-nss-ecm] Fix neighbour solicitation send function.
+
+dst_ops->neigh_lookup function pointer is set to the
+ip6_neigh_lookup function. This function returns an
+error pointer with the ERR_PTR() macro. So, we should
+check the return value of this function pointer with
+the IS_ERR() macro.
+
+Change-Id: I188a6e53278faaa68f1854524f612efc1f7451fe
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ ecm_interface.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/ecm_interface.c b/ecm_interface.c
+index 3f8554b..36509f0 100644
+--- a/ecm_interface.c
++++ b/ecm_interface.c
+@@ -1100,7 +1100,7 @@ void ecm_interface_send_neighbour_solicitation(struct net_device *dev, ip_addr_t
+ #else
+ 	neigh = rt6i->dst.ops->neigh_lookup(&rt6i->dst, NULL, &dst_addr);
+ #endif
+-	if (neigh == NULL) {
++	if (IS_ERR(neigh)) {
+ 		DEBUG_TRACE("Neighbour lookup failure for destination IPv6 address " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(addr));
+ 		dst_release(&rt6i->dst);
+ 		return;
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/patches/402-Reference-leak-during-multicast_PPPoE-bridge.patch b/package/qca/qca-nss-ecm/patches/402-Reference-leak-during-multicast_PPPoE-bridge.patch
new file mode 100644
index 0000000000..97ce7a7e8e
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/402-Reference-leak-during-multicast_PPPoE-bridge.patch
@@ -0,0 +1,260 @@
+From 7c0610828b835b2aab96dd50ec841a3a28689112 Mon Sep 17 00:00:00 2001
+From: Suman Ghosh <sumaghos@codeaurora.org>
+Date: Mon, 16 Mar 2020 15:22:18 +0530
+Subject: [qca-nss-ecm] Reference leak during multicast + PPPoE bridge
+
+Signed-off-by: Suman Ghosh <sumaghos@codeaurora.org>
+Change-Id: I4472035f1bbb087e637169762ae2648c0fda792a
+---
+ ecm_interface.c | 136 +++++++++++++++++++++++++-------------------------------
+ 1 file changed, 60 insertions(+), 76 deletions(-)
+
+diff --git a/ecm_interface.c b/ecm_interface.c
+index 1614336..c0d2357 100644
+--- a/ecm_interface.c
++++ b/ecm_interface.c
+@@ -3796,6 +3796,25 @@ fail:
+ }
+ 
+ /*
++ * ecm_interface_hierarchy_delete()
++ * 	Delete hierarchy of the requested interfaces.
++ */
++static inline void ecm_interface_hierarchy_delete(struct ecm_db_iface_instance *interfaces,
++							uint32_t *interface_first_base,
++							int valid_if)
++{
++	struct ecm_db_iface_instance *to_list_single[ECM_DB_IFACE_HEIRARCHY_MAX];
++	struct ecm_db_iface_instance *ifaces;
++	int i;
++
++	for (i = 0; i < valid_if; i++) {
++		ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, i);
++		ecm_db_multicast_copy_if_heirarchy(to_list_single, ifaces);
++		ecm_db_connection_interfaces_deref(to_list_single, interface_first_base[i]);
++	}
++}
++
++/*
+  * ecm_interface_multicast_heirarchy_construct_routed()
+  * 	Create destination interface heirarchy for a routed multicast connectiona
+  *
+@@ -3816,7 +3835,6 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 								uint32_t *interface_first_base, bool mfc_update,
+ 								__be16 *layer4hdr, struct sk_buff *skb)
+ {
+-	struct ecm_db_iface_instance *to_list_single[ECM_DB_IFACE_HEIRARCHY_MAX];
+ 	struct ecm_db_iface_instance *ifaces;
+ 	struct net_device *dest_dev = NULL;
+ 	struct net_device *br_dev_src = NULL;
+@@ -3829,7 +3847,7 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 	int if_index;
+ 	int ii_cnt;
+ 	int total_ii_count = 0;
+-	bool src_dev_is_bridge = false;
++	bool src_dev_is_bridge = false, dest_dev_is_br_dev_src = false;
+ 
+ 	DEBUG_TRACE("Construct interface heirarchy for dest_addr: " ECM_IP_ADDR_DOT_FMT " src_addr: " ECM_IP_ADDR_DOT_FMT "total destination ifs %d\n",
+ 			ECM_IP_ADDR_TO_DOT(packet_dest_addr), ECM_IP_ADDR_TO_DOT(packet_src_addr), max_if);
+@@ -3876,6 +3894,7 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 			continue;
+ 		}
+ 
++		dest_dev_is_br_dev_src = false;
+ 		dest_dev = dev_get_by_index(&init_net, *dst_if_index);
+ 		if (!dest_dev) {
+ 			if (!src_dev_is_bridge) {
+@@ -3884,26 +3903,23 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 				 * this error condition then Deref all interface heirarchies.
+ 				 */
+ 				if (valid_if > 0) {
+-					int i;
+-
+-					for (i = 0; i < valid_if; i++) {
+-						ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, i);
+-						ecm_db_multicast_copy_if_heirarchy(to_list_single, ifaces);
+-						ecm_db_connection_interfaces_deref(to_list_single, interface_first_base[i]);
+-					}
++					ecm_interface_hierarchy_delete(interfaces, interface_first_base, valid_if);
+ 				}
+ 
+-				/*
+-				 * If valid netdev not found, Return 0
+-				 */
+-				if (br_dev_src) {
+-					dev_put(br_dev_src);
+-				}
+-
+-				return 0;
++				goto fail1;
+ 			}
+ 
+ 			dest_dev = br_dev_src;
++
++			/*
++			 * In some cases when WAN interface is added to bridge and traffic is downstream,
++			 * the bridge device is part of the destination list from MFC, and at the same time
++			 * 'src_dev_is_bridge' will be true as well. In such cases we will need to release
++			 * the hold on the bridge device separately for dest_dev and br_dev_src.
++			 * Setting this flag to true indicates that this is not the case,
++			 * and that releasing the hold once is enough
++			 */
++			dest_dev_is_br_dev_src = true;
+ 		}
+ 
+ 		dest_dev_type = dest_dev->type;
+@@ -3927,7 +3943,6 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 			}
+ 
+ 			if ((if_num < 0) || (if_num > ECM_DB_MULTICAST_IF_MAX)) {
+-				int i;
+ 				DEBUG_WARN("MCS is not ready\n");
+ 
+ 				/*
+@@ -3935,19 +3950,10 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 				 * this error condition then Deref all interface heirarchies.
+ 				 */
+ 				if (valid_if > 0) {
+-					for (i = 0; i < valid_if; i++) {
+-						ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, i);
+-						ecm_db_multicast_copy_if_heirarchy(to_list_single, ifaces);
+-						ecm_db_connection_interfaces_deref(to_list_single, interface_first_base[i]);
+-					}
++					ecm_interface_hierarchy_delete(interfaces, interface_first_base, valid_if);
+ 				}
+ 
+-				if (br_dev_src && (dest_dev != br_dev_src)) {
+-					dev_put(br_dev_src);
+-				}
+-
+-				dev_put(dest_dev);
+-				return 0;
++				goto fail2;
+ 			}
+ 
+ 			if (in_dev && !mfc_update) {
+@@ -3955,34 +3961,20 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 			}
+ 
+ 			for (br_if = 0; br_if < if_num; br_if++) {
++				int total_if = valid_if + br_if;
++
+ 				mc_br_slave_dev = dev_get_by_index(&init_net, mc_dst_if_index[br_if]);
+ 				if (!mc_br_slave_dev) {
+ 					continue;
+ 				}
+ 
+-				if ((valid_if + br_if) > ECM_DB_MULTICAST_IF_MAX) {
+-					int i;
+-
+-					/*
+-					 * If already constructed any interface heirarchies before hitting
+-					 * this error condition then Deref all interface heirarchies.
+-					 */
+-					for (i = 0; i < (valid_if + br_if); i++) {
+-						ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, i);
+-						ecm_db_multicast_copy_if_heirarchy(to_list_single, ifaces);
+-						ecm_db_connection_interfaces_deref(to_list_single, interface_first_base[i]);
+-					}
+-
+-					if (br_dev_src && (dest_dev != br_dev_src)) {
+-						dev_put(br_dev_src);
+-					}
+-
+-					dev_put(dest_dev);
++				if (total_if > ECM_DB_MULTICAST_IF_MAX) {
++					ecm_interface_hierarchy_delete(interfaces, interface_first_base, total_if);
+ 					dev_put(mc_br_slave_dev);
+-					return 0;
++					goto fail2;
+ 				}
+ 
+-				ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, valid_if + br_if);
++				ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, total_if);
+ 				/*
+ 				 * Construct a single interface heirarchy of a multicast dev.
+ 				 */
+@@ -3993,25 +3985,15 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 					 * If already constructed any interface heirarchies before hitting
+ 					 * this error condition then Deref all interface heirarchies.
+ 					 */
+-					if ((valid_if + br_if) > 0) {
+-						int i;
+-						for (i = 0; i < (valid_if + br_if); i++) {
+-							ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, i);
+-							ecm_db_multicast_copy_if_heirarchy(to_list_single, ifaces);
+-							ecm_db_connection_interfaces_deref(to_list_single, interface_first_base[i]);
+-						}
+-					}
+-
+-					if (br_dev_src && (dest_dev != br_dev_src)) {
+-						dev_put(br_dev_src);
++					if (total_if > 0) {
++						ecm_interface_hierarchy_delete(interfaces, interface_first_base, total_if);
+ 					}
+ 
+-					dev_put(dest_dev);
+ 					dev_put(mc_br_slave_dev);
+-					return 0;
++					goto fail2;
+ 				}
+ 
+-				interface_first = ecm_db_multicast_if_first_get_at_index(interface_first_base, (valid_if + br_if));
++				interface_first = ecm_db_multicast_if_first_get_at_index(interface_first_base, total_if);
+ 				*interface_first = ii_cnt;
+ 				total_ii_count += ii_cnt;
+ 				dev_put(mc_br_slave_dev);
+@@ -4033,20 +4015,10 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 				 * this error condition then Deref all interface heirarchies.
+ 				 */
+ 				if (valid_if > 0) {
+-					int i;
+-					for (i = 0; i < valid_if; i++) {
+-						ifaces = ecm_db_multicast_if_heirarchy_get(interfaces, i);
+-						ecm_db_multicast_copy_if_heirarchy(to_list_single, ifaces);
+-						ecm_db_connection_interfaces_deref(to_list_single, interface_first_base[i]);
+-					}
+-				}
+-
+-				if (br_dev_src && (dest_dev != br_dev_src)) {
+-					dev_put(br_dev_src);
++					ecm_interface_hierarchy_delete(interfaces, interface_first_base, valid_if);
+ 				}
+ 
+-				dev_put(dest_dev);
+-				return 0;
++				goto fail2;
+ 			}
+ 
+ 			interface_first = ecm_db_multicast_if_first_get_at_index(interface_first_base, valid_if);
+@@ -4055,7 +4027,7 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 			valid_if++;
+ 		}
+ 
+-		if (dest_dev != br_dev_src) {
++		if (!dest_dev_is_br_dev_src) {
+ 			dev_put(dest_dev);
+ 		}
+ 	}
+@@ -4065,6 +4037,18 @@ int32_t ecm_interface_multicast_heirarchy_construct_routed(struct ecm_front_end_
+ 	}
+ 
+ 	return total_ii_count;
++
++fail2:
++	if (!dest_dev_is_br_dev_src) {
++		dev_put(dest_dev);
++	}
++
++fail1:
++	if (br_dev_src) {
++		dev_put(br_dev_src);
++	}
++
++	return 0;
+ }
+ EXPORT_SYMBOL(ecm_interface_multicast_heirarchy_construct_routed);
+ 
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/patches/403-Access-global-accelerated-count-under-lock.patch b/package/qca/qca-nss-ecm/patches/403-Access-global-accelerated-count-under-lock.patch
new file mode 100644
index 0000000000..d458e11342
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/403-Access-global-accelerated-count-under-lock.patch
@@ -0,0 +1,59 @@
+From 65a49ebd1bd12b9952dfa214de0a2da43ba2abed Mon Sep 17 00:00:00 2001
+From: Bhaskar Valaboju <bhaskarv@codeaurora.org>
+Date: Tue, 13 Aug 2019 14:21:03 +0530
+Subject: [qca-nss-ecm]: Access global ipv4/ipv6 accelerated count under lock
+
+Flow accelerated count maintained as global variables are accessed
+in multiple kernel contexts.  These counters are updated under lock,
+but read without lock.  Read is in kernel thread context (workqueue)
+and sometimes it is taking stale entry (0) and doesn't change.
+Lock is added to read correct value.
+
+Change-Id: I74cf27fe5097c6ae7dfcc06319762a8a322d79a3
+Signed-off-by: Bhaskar Valaboju <bhaskarv@codeaurora.org>
+---
+ frontends/nss/ecm_nss_ipv4.c | 3 +++
+ frontends/nss/ecm_nss_ipv6.c | 3 +++
+ 2 files changed, 6 insertions(+)
+
+(limited to 'frontends')
+
+diff --git a/frontends/nss/ecm_nss_ipv4.c b/frontends/nss/ecm_nss_ipv4.c
+index afd660e..4e66cdf 100644
+--- a/frontends/nss/ecm_nss_ipv4.c
++++ b/frontends/nss/ecm_nss_ipv4.c
+@@ -2288,10 +2288,13 @@ static void ecm_nss_ipv4_stats_sync_req_work(struct work_struct *work)
+ 	int retry = 3;
+ 	unsigned long int current_jiffies;
+ 
++	spin_lock_bh(&ecm_nss_ipv4_lock);
+ 	if (ecm_nss_ipv4_accelerated_count == 0) {
++		spin_unlock_bh(&ecm_nss_ipv4_lock);
+ 		DEBUG_TRACE("There is no accelerated IPv4 connection\n");
+ 		goto reschedule;
+ 	}
++	spin_unlock_bh(&ecm_nss_ipv4_lock);
+ 
+ 	usleep_range(ECM_NSS_IPV4_STATS_SYNC_UDELAY - 100, ECM_NSS_IPV4_STATS_SYNC_UDELAY);
+ 
+diff --git a/frontends/nss/ecm_nss_ipv6.c b/frontends/nss/ecm_nss_ipv6.c
+index 1f7f51e..55849e7 100644
+--- a/frontends/nss/ecm_nss_ipv6.c
++++ b/frontends/nss/ecm_nss_ipv6.c
+@@ -1998,10 +1998,13 @@ static void ecm_nss_ipv6_stats_sync_req_work(struct work_struct *work)
+ 	int retry = 3;
+ 	unsigned long int current_jiffies;
+ 
++	spin_lock_bh(&ecm_nss_ipv6_lock);
+ 	if (ecm_nss_ipv6_accelerated_count == 0) {
++		spin_unlock_bh(&ecm_nss_ipv6_lock);
+ 		DEBUG_TRACE("There is no accelerated IPv6 connection\n");
+ 		goto reschedule;
+ 	}
++	spin_unlock_bh(&ecm_nss_ipv6_lock);
+ 
+ 	usleep_range(ECM_NSS_IPV6_STATS_SYNC_UDELAY - 100, ECM_NSS_IPV6_STATS_SYNC_UDELAY);
+ 
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/patches/403-Fix-IPv6-neighbor-solicitation-request.patch b/package/qca/qca-nss-ecm/patches/403-Fix-IPv6-neighbor-solicitation-request.patch
new file mode 100644
index 0000000000..7639b88a0e
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/403-Fix-IPv6-neighbor-solicitation-request.patch
@@ -0,0 +1,83 @@
+From b96002061178f399c1e58a9ad821e5096a64f788 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Mon, 23 Mar 2020 10:59:39 -0700
+Subject: [qca-nss-ecm] Fix IPv6 neighbor solicitation request
+
+Send the solicitation request to the GW address, when
+a GW address is found, while establishing the node instance.
+
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Change-Id: I2187569bcfd05b0d091cf8c79171ee3c41c39cb9
+---
+ frontends/nss/ecm_nss_ipv6.c           | 7 ++++---
+ frontends/nss/ecm_nss_multicast_ipv6.c | 9 +++++++++
+ frontends/sfe/ecm_sfe_ipv6.c           | 7 ++++---
+ 3 files changed, 17 insertions(+), 6 deletions(-)
+
+diff --git a/frontends/nss/ecm_nss_ipv6.c b/frontends/nss/ecm_nss_ipv6.c
+index c7dd37f..9011e18 100644
+--- a/frontends/nss/ecm_nss_ipv6.c
++++ b/frontends/nss/ecm_nss_ipv6.c
+@@ -527,13 +527,14 @@ struct ecm_db_node_instance *ecm_nss_ipv6_node_establish_and_ref(struct ecm_fron
+ 					struct net_device *master;
+ 					master = ecm_interface_get_and_hold_dev_master(dev);
+ 					DEBUG_ASSERT(master, "Expected a master\n");
+-					ecm_interface_send_neighbour_solicitation(master, addr);
++					ecm_interface_send_neighbour_solicitation(master, gw_addr);
+ 					dev_put(master);
+ 				} else {
+-					ecm_interface_send_neighbour_solicitation(dev, addr);
++					ecm_interface_send_neighbour_solicitation(dev, gw_addr);
+ 				}
+ 
+-				DEBUG_TRACE("Failed to obtain mac for host " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(addr));
++				DEBUG_TRACE("Failed to obtain mac for host " ECM_IP_ADDR_OCTAL_FMT " gw: " ECM_IP_ADDR_OCTAL_FMT "\n",
++					    ECM_IP_ADDR_TO_OCTAL(addr), ECM_IP_ADDR_TO_OCTAL(gw_addr));
+ 				return NULL;
+ 			}
+ done:
+diff --git a/frontends/nss/ecm_nss_multicast_ipv6.c b/frontends/nss/ecm_nss_multicast_ipv6.c
+index a361eec..38fde95 100644
+--- a/frontends/nss/ecm_nss_multicast_ipv6.c
++++ b/frontends/nss/ecm_nss_multicast_ipv6.c
+@@ -2558,6 +2558,15 @@ static struct ecm_db_node_instance *ecm_nss_multicast_ipv6_node_establish_and_re
+ #endif
+ 			if (!ecm_interface_mac_addr_get(addr, node_addr, &on_link, gw_addr)) {
+ 				DEBUG_TRACE("Failed to obtain mac for host " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(addr));
++
++				/*
++				 * If there is a gw_addr found during the lookup, use that address
++				 * for neighbour solicitation request.
++				 */
++				if (!ECM_IP_ADDR_IS_NULL(gw_addr)) {
++					ECM_IP_ADDR_COPY(addr, gw_addr);
++				}
++
+ 				if (ecm_front_end_is_bridge_port(dev)) {
+ 					struct net_device *master;
+ 					master = ecm_interface_get_and_hold_dev_master(dev);
+diff --git a/frontends/sfe/ecm_sfe_ipv6.c b/frontends/sfe/ecm_sfe_ipv6.c
+index 3fd5d46..51a9ccb 100644
+--- a/frontends/sfe/ecm_sfe_ipv6.c
++++ b/frontends/sfe/ecm_sfe_ipv6.c
+@@ -256,13 +256,14 @@ struct ecm_db_node_instance *ecm_sfe_ipv6_node_establish_and_ref(struct ecm_fron
+ 					struct net_device *master;
+ 					master = ecm_interface_get_and_hold_dev_master(dev);
+ 					DEBUG_ASSERT(master, "Expected a master\n");
+-					ecm_interface_send_neighbour_solicitation(master, addr);
++					ecm_interface_send_neighbour_solicitation(master, gw_addr);
+ 					dev_put(master);
+ 				} else {
+-					ecm_interface_send_neighbour_solicitation(dev, addr);
++					ecm_interface_send_neighbour_solicitation(dev, gw_addr);
+ 				}
+ 
+-				DEBUG_TRACE("Failed to obtain mac for host " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(addr));
++				DEBUG_TRACE("Failed to obtain mac for host " ECM_IP_ADDR_OCTAL_FMT " gw: " ECM_IP_ADDR_OCTAL_FMT "\n",
++					    ECM_IP_ADDR_TO_OCTAL(addr), ECM_IP_ADDR_TO_OCTAL(gw_addr));
+ 				return NULL;
+ 			}
+ done:
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/patches/404-IPv6-solicitation-fix-with-zero-gateway-address.patch b/package/qca/qca-nss-ecm/patches/404-IPv6-solicitation-fix-with-zero-gateway-address.patch
new file mode 100644
index 0000000000..bdedff4429
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/404-IPv6-solicitation-fix-with-zero-gateway-address.patch
@@ -0,0 +1,63 @@
+From 5b51ae2f1eca61c6f68e40a05333da5a362ff327 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Mon, 13 Apr 2020 09:01:48 -0700
+Subject: [qca-nss-ecm] IPv6 solicitation fix with zero gateway address
+
+The ECM function can find a zero gateway address for
+a host IP address. In this case, we need to use the
+host IP address while sending the solicitation request.
+
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+Change-Id: I1979834088ddfe1843566f51f64348f79e2df0fc
+---
+ frontends/nss/ecm_nss_ipv6.c | 11 ++++++++++-
+ frontends/sfe/ecm_sfe_ipv6.c | 11 ++++++++++-
+ 2 files changed, 20 insertions(+), 2 deletions(-)
+
+diff --git a/frontends/nss/ecm_nss_ipv6.c b/frontends/nss/ecm_nss_ipv6.c
+index a05781b..9eb591c 100644
+--- a/frontends/nss/ecm_nss_ipv6.c
++++ b/frontends/nss/ecm_nss_ipv6.c
+@@ -516,7 +516,16 @@ struct ecm_db_node_instance *ecm_nss_ipv6_node_establish_and_ref(struct ecm_fron
+ 					return NULL;
+ 				}
+ 
+-				DEBUG_TRACE("Have a gw address " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(gw_addr));
++				/*
++				 * The found gateway address can be all zeros,
++				 * so in this case use the host address.
++				 */
++				if (ECM_IP_ADDR_IS_NULL(gw_addr)) {
++					DEBUG_TRACE("GW address is found as zeros, so use host IP\n");
++					ECM_IP_ADDR_COPY(gw_addr, addr);
++				} else {
++					DEBUG_TRACE("Have a gw address " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(gw_addr));
++				}
+ 
+ 				if (ecm_interface_mac_addr_get_no_route(dev, gw_addr, node_addr)) {
+ 					DEBUG_TRACE("Found the mac address for gateway\n");
+diff --git a/frontends/sfe/ecm_sfe_ipv6.c b/frontends/sfe/ecm_sfe_ipv6.c
+index 51a9ccb..e609df7 100644
+--- a/frontends/sfe/ecm_sfe_ipv6.c
++++ b/frontends/sfe/ecm_sfe_ipv6.c
+@@ -245,7 +245,16 @@ struct ecm_db_node_instance *ecm_sfe_ipv6_node_establish_and_ref(struct ecm_fron
+ 					return NULL;
+ 				}
+ 
+-				DEBUG_TRACE("Have a gw address " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(gw_addr));
++				/*
++				 * The found gateway address can be all zeros,
++				 * so in this case use the host address.
++				 */
++				if (ECM_IP_ADDR_IS_NULL(gw_addr)) {
++					DEBUG_TRACE("GW address is found as zeros, so use host IP\n");
++					ECM_IP_ADDR_COPY(gw_addr, addr);
++				} else {
++					DEBUG_TRACE("Have a gw address " ECM_IP_ADDR_OCTAL_FMT "\n", ECM_IP_ADDR_TO_OCTAL(gw_addr));
++				}
+ 
+ 				if (ecm_interface_mac_addr_get_no_route(dev, gw_addr, node_addr)) {
+ 					DEBUG_TRACE("Found the mac address for gateway\n");
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-ecm/patches/405-Allow-egress-on-same-port-when-bridge-hairpin-is-enabled.patch b/package/qca/qca-nss-ecm/patches/405-Allow-egress-on-same-port-when-bridge-hairpin-is-enabled.patch
new file mode 100644
index 0000000000..a236fb7576
--- /dev/null
+++ b/package/qca/qca-nss-ecm/patches/405-Allow-egress-on-same-port-when-bridge-hairpin-is-enabled.patch
@@ -0,0 +1,126 @@
+From e23eabd570eabde1d1fc803127a97fd101642467 Mon Sep 17 00:00:00 2001
+From: Varsha Mishra <varsham@codeaurora.org>
+Date: Fri, 12 Jun 2020 01:06:58 +0530
+Subject: [qca-nss-ecm] Allow egress on same port when bridge hairpin is
+ enabled.
+
+When bridge hairpin is enabled, allow egress on same port. Wi-Fi intrabss
+frames are getting exceptioned to stack. Bridge gets to make the decision
+whether these frames need to be forwarded or dropped.
+
+Signed-off-by: Varsha Mishra <varsham@codeaurora.org>
+Change-Id: Ibdd72264d8887330ba0297ed12cbcfc390065bff
+---
+ frontends/nss/ecm_nss_ipv4.c | 28 ++++++++++++++++++++++------
+ frontends/nss/ecm_nss_ipv6.c | 28 ++++++++++++++++++++++------
+ 2 files changed, 44 insertions(+), 12 deletions(-)
+
+diff --git a/frontends/nss/ecm_nss_ipv4.c b/frontends/nss/ecm_nss_ipv4.c
+index 60f799b..51c9ebf 100644
+--- a/frontends/nss/ecm_nss_ipv4.c
++++ b/frontends/nss/ecm_nss_ipv4.c
+@@ -1756,7 +1756,9 @@ static unsigned int ecm_nss_ipv4_bridge_post_routing_hook(void *priv,
+ 	 * Case 2:
+ 	 *	For routed packets the skb will have the src mac matching the bridge mac.
+ 	 * Case 3:
+-	 *	If the packet was not local (case 1) or routed (case 2) then we process.
++	 *	If the packet was not local (case 1) or routed (case 2) then
++	 *	we process. There is an exception to case 2: when hairpin mode
++	 *	is enabled, we process.
+ 	 */
+ 
+ 	/*
+@@ -1768,14 +1770,28 @@ static unsigned int ecm_nss_ipv4_bridge_post_routing_hook(void *priv,
+ 		dev_put(bridge);
+ 		return NF_ACCEPT;
+ 	}
++
++	/*
++	 * This flag needs to be checked in slave port(eth0/ath0)
++	 * and not on master interface(br-lan). Hairpin flag can be
++	 * enabled/disabled for ports individually.
++	 */
+ 	if (in == out) {
+-		DEBUG_TRACE("skb: %p, bridge: %p (%s), port bounce on %p (%s)\n", skb, bridge, bridge->name, out, out->name);
+-		dev_put(in);
+-		dev_put(bridge);
+-		return NF_ACCEPT;
++		if (!br_is_hairpin_enabled(in)) {
++			DEBUG_TRACE("skb: %p, bridge: %p (%s), ignoring"
++					"the packet, hairpin not enabled"
++					"on port %p (%s)\n", skb, bridge,
++					bridge->name, out, out->name);
++			dev_put(in);
++			dev_put(bridge);
++			return NF_ACCEPT;
++		}
++		DEBUG_TRACE("skb: %p, bridge: %p (%s), hairpin enabled on port"
++				"%p (%s)\n", skb, bridge, bridge->name, out, out->name);
+ 	}
++
++	/*
++	 * Case 2: Routed trafffic would be handled by the INET post routing.
++	 */
+ 	if (!ecm_mac_addr_equal(skb_eth_hdr->h_source, bridge->dev_addr)) {
+-		/*
+-		 * Case 2: Routed trafffic would be handled by the INET post routing.
+-		 */
+ 		DEBUG_TRACE("skb: %p, Ignoring routed packet to bridge: %p (%s)\n", skb, bridge, bridge->name);
+ 		goto skip_ipv4_bridge_flow;
+ 	}
+diff --git a/frontends/nss/ecm_nss_ipv6.c b/frontends/nss/ecm_nss_ipv6.c
+index 6ad425e..160c94c 100644
+--- a/frontends/nss/ecm_nss_ipv6.c
++++ b/frontends/nss/ecm_nss_ipv6.c
+@@ -1498,7 +1498,9 @@ static unsigned int ecm_nss_ipv6_bridge_post_routing_hook(void *priv,
+ 	 * Case 2:
+ 	 *	For routed packets the skb will have the src mac matching the bridge mac.
+ 	 * Case 3:
+-	 *	If the packet was not local (case 1) or routed (case 2) then we process.
++	 *	If the packet was not local (case 1) or routed (case 2) then
++	 *	we process. There is an exception to case 2: when hairpin mode
++	 *	is enabled, we process.
+ 	 */
+ 
+ 	/*
+@@ -1510,14 +1512,28 @@ static unsigned int ecm_nss_ipv6_bridge_post_routing_hook(void *priv,
+ 		dev_put(bridge);
+ 		return NF_ACCEPT;
+ 	}
++
++	/*
++	 * This flag needs to be checked in slave port(eth0/ath0)
++	 * and not on master interface(br-lan). Hairpin flag can be
++	 * enabled/disabled for ports individually.
++	 */
+ 	if (in == out) {
+-		DEBUG_TRACE("skb: %p, bridge: %p (%s), port bounce on %p (%s)\n", skb, bridge, bridge->name, out, out->name);
+-		dev_put(in);
+-		dev_put(bridge);
+-		return NF_ACCEPT;
++		if (!br_is_hairpin_enabled(in)) {
++			DEBUG_TRACE("skb: %p, bridge: %p (%s), ignoring"
++					"the packet, hairpin not enabled"
++					"on port %p (%s)\n", skb, bridge,
++					bridge->name, out, out->name);
++			dev_put(in);
++			dev_put(bridge);
++			return NF_ACCEPT;
++		}
++		DEBUG_TRACE("skb: %p, bridge: %p (%s), hairpin enabled on port"
++				"%p (%s)\n", skb, bridge, bridge->name, out, out->name);
+ 	}
++
++	/*
++	 * Case 2: Routed trafffic would be handled by the INET post routing.
++	 */
+ 	if (!ecm_mac_addr_equal(skb_eth_hdr->h_source, bridge->dev_addr)) {
+-		/*
+-		 * Case 2: Routed trafffic would be handled by the INET post routing.
+-		 */
+ 		DEBUG_TRACE("skb: %p, Ignoring routed packet to bridge: %p (%s)\n", skb, bridge, bridge->name);
+ 		goto skip_ipv6_bridge_flow;
+ 	}
+-- 
+cgit v1.1
+
diff --git a/package/qca/qca-nss-gmac/Makefile b/package/qca/qca-nss-gmac/Makefile
new file mode 100644
index 0000000000..268f5a944c
--- /dev/null
+++ b/package/qca/qca-nss-gmac/Makefile
@@ -0,0 +1,46 @@
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=qca-nss-gmac
+PKG_RELEASE:=1
+
+PKG_SOURCE_URL:=https://source.codeaurora.org/quic/qsdk/oss/lklm/nss-gmac
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_VERSION:=9b74deef2816d91e58926e6fab7a6ff931eb3b22
+
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/qca-nss-gmac
+  SECTION:=kernel
+  CATEGORY:=Kernel modules
+  SUBMENU:=Network Devices
+  DEPENDS:=@TARGET_ipq806x||TARGET_ipq_ipq806x @!LINUX_3_18
+  TITLE:=Kernel driver for NSS gmac
+  FILES:=$(PKG_BUILD_DIR)/ipq806x/qca-nss-gmac.ko
+  AUTOLOAD:=$(call AutoLoad,31,qca-nss-gmac)
+endef
+
+define KernelPackage/qca-nss-gmac/Description
+This package contains a NSS driver for QCA chipset
+endef
+
+define Build/InstallDev
+	mkdir -p $(1)/usr/include/qca-nss-gmac
+	$(CP) $(PKG_BUILD_DIR)/ipq806x/exports/* $(1)/usr/include/qca-nss-gmac/
+endef
+
+EXTRA_CFLAGS+= \
+	-DCONFIG_NSS_DEBUG_LEVEL=4 \
+	-I$(PKG_BUILD_DIR)/nss_hal/include \
+	-I$(PKG_BUILD_DIR)/nss_hal/$(BOARD)
+
+define Build/Compile
+	$(MAKE) $(PKG_JOBS) -C "$(LINUX_DIR)" \
+		$(KERNEL_MAKE_FLAGS) \
+		$(PKG_MAKE_FLAGS) \
+		M="$(PKG_BUILD_DIR)" \
+		EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
+		modules
+endef
+
+$(eval $(call KernelPackage,qca-nss-gmac))
diff --git a/package/qca/qca-nss-gmac/patches/100-kernel-5.4-support.patch b/package/qca/qca-nss-gmac/patches/100-kernel-5.4-support.patch
new file mode 100644
index 0000000000..f3b91abc20
--- /dev/null
+++ b/package/qca/qca-nss-gmac/patches/100-kernel-5.4-support.patch
@@ -0,0 +1,279 @@
+--- a/ipq806x/nss_gmac_ctrl.c
++++ b/ipq806x/nss_gmac_ctrl.c
+@@ -322,16 +322,15 @@ void nss_gmac_tx_rx_desc_init(struct nss
+  * (for example "ifconfig eth0").
+  * @param[in] pointer to net_device structure.
+  * @param[in] pointer to net_device_stats64 structure.
+- * @return Returns pointer to net_device_stats64 structure.
+  */
+-struct rtnl_link_stats64 *nss_gmac_get_stats64(struct net_device *netdev,
++void nss_gmac_get_stats64(struct net_device *netdev,
+ 						struct rtnl_link_stats64 *stats)
+ {
+ 	struct nss_gmac_dev *gmacdev = (struct nss_gmac_dev *)netdev_priv(netdev);
+ 	BUG_ON(gmacdev == NULL);
+ 
+ 	if (!gmacdev->data_plane_ops)
+-		return stats;
++		return;
+ 
+ 	spin_lock_bh(&gmacdev->stats_lock);
+ 	gmacdev->data_plane_ops->get_stats(gmacdev->data_plane_ctx, &gmacdev->nss_stats);
+@@ -354,8 +353,6 @@ struct rtnl_link_stats64 *nss_gmac_get_s
+ 	stats->tx_fifo_errors = gmacdev->nss_stats.tx_underflow_errors;
+ 	stats->tx_window_errors = gmacdev->nss_stats.tx_late_collision_errors;
+ 	spin_unlock_bh(&gmacdev->stats_lock);
+-
+-	return stats;
+ }
+ 
+ 
+@@ -439,7 +436,7 @@ static int nss_gmac_mtnp_show(struct dev
+ static int nss_gmac_tstamp_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct nss_gmac_dev *gmacdev = (struct nss_gmac_dev *)netdev_priv(to_net_dev(dev));
+-	struct timeval tv;
++	struct timespec64 ts64;
+ 	uint32_t ret, timeout;
+ 	uint32_t ts_hi, ts_lo;
+ 
+@@ -459,11 +456,12 @@ static int nss_gmac_tstamp_show(struct d
+ 		return -1;
+ 	}
+ 
+-	do_gettimeofday(&tv);
++	ktime_get_real_ts64(&ts64);
+ 
+ 	ret = snprintf(
+ 		buf, PAGE_SIZE,
+-		"sec:%u nsec:%u time-of-day: %12d.%06d \n", ts_hi, ts_lo, (int)tv.tv_sec, (int)tv.tv_usec);
++		"sec:%u nsec:%u time-of-day: %12d.%06d \n", \
++		ts_hi, ts_lo, (int)ts64.tv_sec, (int)(ts64.tv_nsec / NSEC_PER_USEC));
+ 
+ 	return ret;
+ }
+@@ -951,7 +949,7 @@ static const struct net_device_ops nss_g
+  * @param[in] pointer to advertised features
+  * @return void
+  */
+-static void nss_gmac_update_features(uint32_t *supp, uint32_t *adv)
++static void nss_gmac_update_features(long unsigned int *supp, long unsigned int *adv)
+ {
+ 	*supp |= NSS_GMAC_SUPPORTED_FEATURES;
+ 	*adv |= NSS_GMAC_ADVERTISED_FEATURES;
+@@ -1409,8 +1407,8 @@ static int32_t nss_gmac_probe(struct pla
+ 			goto nss_gmac_phy_attach_fail;
+ 		}
+ 
+-		nss_gmac_update_features(&(gmacdev->phydev->supported),
+-					&(gmacdev->phydev->advertising));
++		nss_gmac_update_features(gmacdev->phydev->supported,
++					 gmacdev->phydev->advertising);
+ 		gmacdev->phydev->irq = PHY_POLL;
+ 		netdev_dbg(netdev, "PHY %s attach OK\n", phy_id);
+ 
+@@ -1440,6 +1438,8 @@ static int32_t nss_gmac_probe(struct pla
+ 		netdev_dbg(netdev, "%s MII_PHYSID2 - 0x%04x\n", netdev->name,
+ 		      nss_gmac_mii_rd_reg(gmacdev, gmacdev->phy_base, MII_PHYSID2));
+ 	} else if (gmacdev->phy_base != NSS_GMAC_NO_MDIO_PHY) {
++		SET_NETDEV_DEV(netdev, gmacdev->miibus->parent);
++
+ 		/*
+ 		 * Issue a phy_attach for the interface connected to a switch
+ 		 */
+--- a/ipq806x/nss_gmac_ethtool.c
++++ b/ipq806x/nss_gmac_ethtool.c
+@@ -143,9 +143,9 @@ static const struct nss_gmac_ethtool_sta
+ /**
+  * @brief Array of strings describing private flag names
+  */
+-static const char *gmac_strings_priv_flags[] = {
+-	"linkpoll",
+-	"tstamp",
++static const char *gmac_strings_priv_flags[][ETH_GSTRING_LEN] = {
++	{"linkpoll"},
++	{"tstamp"},
+ };
+ 
+ #define NSS_GMAC_STATS_LEN	ARRAY_SIZE(gmac_gstrings_stats)
+@@ -292,6 +292,7 @@ static int nss_gmac_set_pauseparam(struc
+ {
+ 	struct nss_gmac_dev *gmacdev = (struct nss_gmac_dev *)netdev_priv(netdev);
+ 	struct phy_device *phydev;
++	long unsigned int *advertising;
+ 
+ 	BUG_ON(gmacdev == NULL);
+ 	BUG_ON(gmacdev->netdev != netdev);
+@@ -327,14 +328,15 @@ static int nss_gmac_set_pauseparam(struc
+ 	phydev = gmacdev->phydev;
+ 
+ 	/* Update flow control advertisment */
+-	phydev->advertising &= ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
++	advertising = phydev->advertising;
++	*advertising &= ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+ 
+ 	if (gmacdev->pause & FLOW_CTRL_RX)
+-		phydev->advertising |=
++		*advertising |=
+ 				(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+ 
+ 	if (gmacdev->pause & FLOW_CTRL_TX)
+-		phydev->advertising |= ADVERTISED_Asym_Pause;
++		*advertising |= ADVERTISED_Asym_Pause;
+ 
+ 	genphy_config_aneg(gmacdev->phydev);
+ 
+@@ -396,12 +398,13 @@ static uint32_t nss_gmac_get_msglevel(st
+  * @param[in] pointer to struct net_device.
+  * @param[in] pointer to struct ethtool_cmd.
+  */
+-static int32_t nss_gmac_get_settings(struct net_device *netdev,
+-			      struct ethtool_cmd *ecmd)
++static int nss_gmac_get_settings(struct net_device *netdev,
++				 struct ethtool_link_ksettings *elk)
+ {
+ 	struct nss_gmac_dev *gmacdev = (struct nss_gmac_dev *)netdev_priv(netdev);
+ 	struct phy_device *phydev = NULL;
+ 	uint16_t phyreg;
++	u32 lp_advertising = 0;
+ 
+ 	BUG_ON(gmacdev == NULL);
+ 
+@@ -413,10 +416,10 @@ static int32_t nss_gmac_get_settings(str
+ 	 */
+ 	if (!test_bit(__NSS_GMAC_LINKPOLL, &gmacdev->flags)) {
+ 		if (gmacdev->forced_speed != SPEED_UNKNOWN) {
+-			ethtool_cmd_speed_set(ecmd, gmacdev->forced_speed);
+-			ecmd->duplex = gmacdev->forced_duplex;
+-			ecmd->mdio_support = 0;
+-			ecmd->lp_advertising = 0;
++			elk->base.speed = gmacdev->forced_speed;
++			elk->base.duplex = gmacdev->forced_duplex;
++			elk->base.mdio_support = 0;
++			ethtool_convert_legacy_u32_to_link_mode(elk->link_modes.lp_advertising, 0);
+ 			return 0;
+ 		} else {
+ 			/* Non-link polled interfaced must have a forced
+@@ -429,63 +429,59 @@ static int32_t nss_gmac_get_settings(struct net_device *netdev,
+ 
+ 	/* update PHY status */
+ 	if (phydev->is_c45 == true) {
+-		ecmd->mdio_support = ETH_MDIO_SUPPORTS_C45;
++		elk->base.mdio_support = ETH_MDIO_SUPPORTS_C45;
+ 	} else {
+ 		if (genphy_read_status(phydev) != 0) {
+ 			return -EIO;
+ 		}
+-		ecmd->mdio_support = ETH_MDIO_SUPPORTS_C22;
++		elk->base.mdio_support = ETH_MDIO_SUPPORTS_C22;
+ 	}
+ 
+ 	/* Populate capabilities advertised by self */
+-	ecmd->advertising = phydev->advertising;
++	bitmap_copy(elk->link_modes.advertising, phydev->advertising, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 
+-	ecmd->autoneg = phydev->autoneg;
+-
+-	if (gmacdev->link_state == LINKDOWN) {
+-		ethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);
+-		ecmd->duplex = DUPLEX_UNKNOWN;
+-	} else {
+-		ethtool_cmd_speed_set(ecmd, phydev->speed);
+-		ecmd->duplex = phydev->duplex;
+-	}
+-
+-	ecmd->port = PORT_TP;
+-	ecmd->phy_address = gmacdev->phy_base;
+-	ecmd->transceiver = XCVR_EXTERNAL;
++	elk->base.autoneg = phydev->autoneg;
++	elk->base.speed = phydev->speed;
++	elk->base.duplex = phydev->duplex;
++	elk->base.port = PORT_TP;
++	elk->base.phy_address = gmacdev->phy_base;
++	elk->base.transceiver = XCVR_EXTERNAL;
+ 
+ 	/* Populate supported capabilities */
+-	ecmd->supported = phydev->supported;
++	bitmap_copy(elk->link_modes.supported, phydev->supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
+ 
+ 	if (phydev->is_c45 == true)
+ 		return 0;
+ 
+ 	/* Populate capabilities advertised by link partner */
++	ethtool_convert_link_mode_to_legacy_u32(&lp_advertising, elk->link_modes.lp_advertising);
+ 	phyreg = nss_gmac_mii_rd_reg(gmacdev, gmacdev->phy_base, MII_LPA);
+ 	if (phyreg & LPA_10HALF)
+-		ecmd->lp_advertising |= ADVERTISED_10baseT_Half;
++		lp_advertising |= ADVERTISED_10baseT_Half;
+ 
+ 	if (phyreg & LPA_10FULL)
+-		ecmd->lp_advertising |= ADVERTISED_10baseT_Full;
++		lp_advertising |= ADVERTISED_10baseT_Full;
+ 
+ 	if (phyreg & LPA_100HALF)
+-		ecmd->lp_advertising |= ADVERTISED_100baseT_Half;
++		lp_advertising |= ADVERTISED_100baseT_Half;
+ 
+ 	if (phyreg & LPA_100FULL)
+-		ecmd->lp_advertising |= ADVERTISED_100baseT_Full;
++		lp_advertising |= ADVERTISED_100baseT_Full;
+ 
+ 	if (phyreg & LPA_PAUSE_CAP)
+-		ecmd->lp_advertising |= ADVERTISED_Pause;
++		lp_advertising |= ADVERTISED_Pause;
+ 
+ 	if (phyreg & LPA_PAUSE_ASYM)
+-		ecmd->lp_advertising |= ADVERTISED_Asym_Pause;
++		lp_advertising |= ADVERTISED_Asym_Pause;
+ 
+ 	phyreg = nss_gmac_mii_rd_reg(gmacdev, gmacdev->phy_base, MII_STAT1000);
+ 	if (phyreg & LPA_1000HALF)
+-		ecmd->lp_advertising |= ADVERTISED_1000baseT_Half;
++		lp_advertising |= ADVERTISED_1000baseT_Half;
+ 
+ 	if (phyreg & LPA_1000FULL)
+-		ecmd->lp_advertising |= ADVERTISED_1000baseT_Full;
++		lp_advertising |= ADVERTISED_1000baseT_Full;
++
++	ethtool_convert_legacy_u32_to_link_mode(elk->link_modes.lp_advertising, lp_advertising);
+ 
+ 	return 0;
+ }
+@@ -489,8 +495,8 @@ static int32_t nss_gmac_get_settings(str
+  * @param[in] pointer to struct net_device.
+  * @param[in] pointer to struct ethtool_cmd.
+  */
+-static int32_t nss_gmac_set_settings(struct net_device *netdev,
+-			      struct ethtool_cmd *ecmd)
++static int nss_gmac_set_settings(struct net_device *netdev,
++				 const struct ethtool_link_ksettings *elk)
+ {
+ 	struct nss_gmac_dev *gmacdev = (struct nss_gmac_dev *)netdev_priv(netdev);
+ 	struct phy_device *phydev = NULL;
+@@ -512,13 +518,13 @@ static int32_t nss_gmac_set_settings(str
+ 		return -EPERM;
+ 	}
+ 
+-	if (ecmd->autoneg == AUTONEG_ENABLE) {
++	if (elk->base.autoneg == AUTONEG_ENABLE) {
+ 		set_bit(__NSS_GMAC_AUTONEG, &gmacdev->flags);
+ 	} else {
+ 		clear_bit(__NSS_GMAC_AUTONEG, &gmacdev->flags);
+ 	}
+ 
+-	return phy_ethtool_sset(phydev, ecmd);
++	return phy_ethtool_ksettings_set(phydev, elk);
+ }
+ 
+ /**
+@@ -580,8 +586,8 @@ struct ethtool_ops nss_gmac_ethtool_ops
+ 	.set_pauseparam = &nss_gmac_set_pauseparam,
+ 	.nway_reset = &nss_gmac_nway_reset,
+ 	.get_wol = &nss_gmac_get_wol,
+-	.get_settings = &nss_gmac_get_settings,
+-	.set_settings = &nss_gmac_set_settings,
++	.get_link_ksettings = &nss_gmac_get_settings,
++	.set_link_ksettings = &nss_gmac_set_settings,
+ 	.get_strings = &nss_gmac_get_strings,
+ 	.get_sset_count = &nss_gmac_get_strset_count,
+ 	.get_ethtool_stats = &nss_gmac_get_ethtool_stats,
diff --git a/package/qca/qca-nss-gmac/patches/101-nss-gmac-test-ptr.patch b/package/qca/qca-nss-gmac/patches/101-nss-gmac-test-ptr.patch
new file mode 100644
index 0000000000..0b1ff063d5
--- /dev/null
+++ b/package/qca/qca-nss-gmac/patches/101-nss-gmac-test-ptr.patch
@@ -0,0 +1,11 @@
+--- a/ipq806x/nss_gmac_ctrl.c
++++ b/ipq806x/nss_gmac_ctrl.c
+@@ -992,7 +992,7 @@ static int32_t nss_gmac_of_get_pdata(str
+ 		return -EFAULT;
+ 	}
+ 	maddr = (uint8_t *)of_get_mac_address(np);
+-	if (maddr)
++	if (!IS_ERR_OR_NULL(maddr))
+ 		memcpy(gmaccfg->mac_addr, maddr, ETH_ALEN);
+ 
+ 	if (of_address_to_resource(np, 0, &memres_devtree) != 0)
diff --git a/package/qca/qca-nss-gmac/patches/200-work-around-interface-close-warning.patch b/package/qca/qca-nss-gmac/patches/200-work-around-interface-close-warning.patch
new file mode 100644
index 0000000000..7cb6d6fac8
--- /dev/null
+++ b/package/qca/qca-nss-gmac/patches/200-work-around-interface-close-warning.patch
@@ -0,0 +1,15 @@
+--- a/ipq806x/nss_gmac_tx_rx_offload.c
++++ b/ipq806x/nss_gmac_tx_rx_offload.c
+@@ -1027,8 +1027,10 @@ int nss_gmac_close(struct net_device *ne
+ 	nss_gmac_disable_interrupt_all(gmacdev);
+ 	gmacdev->data_plane_ops->link_state(gmacdev->data_plane_ctx, 0);
+ 
+-	if (!IS_ERR(gmacdev->phydev))
+-		phy_stop(gmacdev->phydev);
++	if (!IS_ERR(gmacdev->phydev)) {
++		if (test_bit(__NSS_GMAC_LINKPOLL, &gmacdev->flags))
++			phy_stop(gmacdev->phydev);
++	}
+ 
+ 	clear_bit(__NSS_GMAC_UP, &gmacdev->flags);
+ 	clear_bit(__NSS_GMAC_CLOSING, &gmacdev->flags);
diff --git a/package/qca/qca-rfs/patches/200-rework-nfct-notification.patch b/package/qca/qca-rfs/patches/200-rework-nfct-notification.patch
new file mode 100644
index 0000000000..81e608c02f
--- /dev/null
+++ b/package/qca/qca-rfs/patches/200-rework-nfct-notification.patch
@@ -0,0 +1,20 @@
+--- a/rfs_cm.c
++++ b/rfs_cm.c
+@@ -709,7 +709,7 @@ int rfs_cm_start(void)
+ 
+ 	RFS_DEBUG("RFS cm start\n");
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+-	ret = nf_conntrack_register_notifier(&init_net, &rfs_cm_conntrack_notifier);
++	ret = nf_conntrack_register_chain_notifier(&init_net, &rfs_cm_conntrack_notifier);
+ 	if (ret < 0) {
+ 		RFS_ERROR("can't register nf notifier hook: %d\n", ret);
+ 		return -1;
+@@ -740,7 +740,7 @@ int rfs_cm_stop(void)
+ #endif
+ 
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+-	nf_conntrack_unregister_notifier(&init_net, &rfs_cm_conntrack_notifier);
++	nf_conntrack_unregister_chain_notifier(&init_net, &rfs_cm_conntrack_notifier);
+ #endif
+ 
+ 	rfs_cm_connection_destroy_all();
diff --git a/target/linux/bcm63xx/dts/bcm6328-sercomm-ad1018-nor.dts b/target/linux/bcm63xx/dts/bcm6328-sercomm-ad1018-nor.dts
index 5a9f52648e..83f7578b06 100644
--- a/target/linux/bcm63xx/dts/bcm6328-sercomm-ad1018-nor.dts
+++ b/target/linux/bcm63xx/dts/bcm6328-sercomm-ad1018-nor.dts
@@ -146,30 +146,6 @@
 	};
 };
 
-&nflash {
-	status = "okay";
-
-	nandcs@0 {
-		compatible = "brcm,nandcs";
-		reg = <0>;
-		nand-ecc-step-size = <512>;
-		nand-ecc-strength = <15>;
-		nand-on-flash-bbt;
-		brcm,nand-oob-sector-size = <64>;
-
-		partitions {
-			compatible = "fixed-partitions";
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			partition@0 {
-				label = "storage";
-				reg = <0 0>; /* autodetected size */
-			};
-		};
-	};
-};
-
 &uart0 {
 	status = "okay";
 };
diff --git a/target/linux/ipq806x/config-5.4 b/target/linux/ipq806x/config-5.4
index e6160bd455..b76a02d664 100644
--- a/target/linux/ipq806x/config-5.4
+++ b/target/linux/ipq806x/config-5.4
@@ -1,3 +1,7 @@
+# CONFIG_PHY_QCOM_IPQ806X_USB is not set
+CONFIG_REGULATOR_NSS_VOLT=y
+# CONFIG_SHORTCUT_FE is not set
+CONFIG_64BIT_TIME=y
 CONFIG_ALIGNMENT_TRAP=y
 # CONFIG_APQ_GCC_8084 is not set
 # CONFIG_APQ_MMCC_8084 is not set
@@ -78,7 +82,7 @@ CONFIG_CC_HAS_KASAN_GENERIC=y
 CONFIG_CLKDEV_LOOKUP=y
 CONFIG_CLKSRC_QCOM=y
 CONFIG_CLONE_BACKWARDS=y
-CONFIG_CMDLINE_OVERRIDE=y
+# CONFIG_CMDLINE_OVERRIDE is not set
 CONFIG_COMMON_CLK=y
 CONFIG_COMMON_CLK_QCOM=y
 CONFIG_COMPAT_32BIT_TIME=y
diff --git a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-ad7200-c2600.dtsi b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-ad7200-c2600.dtsi
index af0efb2565..2c2505bd2d 100644
--- a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-ad7200-c2600.dtsi
+++ b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-ad7200-c2600.dtsi
@@ -282,15 +282,29 @@
 
 &gmac1 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37200000 0x200000>;
+	interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "rgmii";
 	qcom,id = <1>;
+	qcom,pcs-chanid = <0>;
+	qcom,phy-mdio-addr = <4>;
+	qcom,poll-required = <0>;
+	qcom,rgmii-delay = <1>;
+	qcom,phy_mii_type = <0>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <255>;
+	mdiobus = <&mdio0>;
 
 	pinctrl-0 = <&rgmii2_pins>;
 	pinctrl-names = "default";
 
 	mtd-mac-address = <&defaultmac 0x8>;
 	mtd-mac-address-increment = <1>;
-
+	
 	fixed-link {
 		speed = <1000>;
 		full-duplex;
@@ -299,9 +313,23 @@
 
 &gmac2 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37400000 0x200000>;
+	interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "sgmii";
 	qcom,id = <2>;
-
+	qcom,pcs-chanid = <1>;
+	qcom,phy-mdio-addr = <0>; /* none */
+	qcom,poll-required = <0>; /* no polling */
+	qcom,rgmii-delay = <0>;
+	qcom,phy_mii_type = <1>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <258>;
+	mdiobus = <&mdio0>;
+	
 	mtd-mac-address = <&defaultmac 0x8>;
 
 	fixed-link {
diff --git a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-eax500.dtsi b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-eax500.dtsi
index 3e6732e9df..30300681de 100644
--- a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-eax500.dtsi
+++ b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-eax500.dtsi
@@ -170,13 +170,30 @@
 			0x00094 0x4e        /* PORT6_STATUS */
 			>;
 	};
+	
+	phy4: ethernet-phy@4 {
+		reg = <4>;
+	};
 };
 
 &gmac1 {
 	status = "okay";
-
+	compatible = "qcom,nss-gmac";
+	reg = <0x37200000 0x200000>;
+	interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "rgmii";
 	qcom,id = <1>;
+	qcom,pcs-chanid = <0>;
+	qcom,phy-mdio-addr = <4>;
+	qcom,poll-required = <1>;
+	qcom,rgmii-delay = <0>;
+	qcom,phy_mii_type = <0>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <255>;
+	mdiobus = <&mdio0>;
 
 	pinctrl-0 = <&rgmii2_pins>;
 	pinctrl-names = "default";
@@ -189,9 +206,22 @@
 
 &gmac2 {
 	status = "okay";
-
+	compatible = "qcom,nss-gmac";
+	reg = <0x37400000 0x200000>;
+	interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "sgmii";
 	qcom,id = <2>;
+	qcom,pcs-chanid = <1>;
+	qcom,phy-mdio-addr = <0>;
+	qcom,poll-required = <0>;	/* no polling */
+	qcom,rgmii-delay = <0>;
+	qcom,phy_mii_type = <1>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <258>;
+	mdiobus = <&mdio0>;
 
 	fixed-link {
 		speed = <1000>;
diff --git a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-g10.dts b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-g10.dts
index 15ed5b4773..9cd1b1b757 100644
--- a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-g10.dts
+++ b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-g10.dts
@@ -114,13 +114,26 @@
 
 &gmac1 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37200000 0x200000>;
+	interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
+	phy-mode = "rgmii";
+	qcom,id = <1>;
+	qcom,pcs-chanid = <0>;
+	qcom,phy-mdio-addr = <4>;
+	qcom,poll-required = <0>;
+	qcom,rgmii-delay = <1>;
+	qcom,phy_mii_type = <0>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <255>;
+	mdiobus = <&mdio0>;
 
 	pinctrl-0 = <&rgmii2_pins>;
 	pinctrl-names = "default";
 
-	phy-mode = "rgmii";
-	qcom,id = <1>;
-
 	fixed-link {
 		speed = <1000>;
 		full-duplex;
@@ -129,9 +142,22 @@
 
 &gmac2 {
 	status = "okay";
-
+	compatible = "qcom,nss-gmac";
+	reg = <0x37400000 0x200000>;
+	interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "sgmii";
 	qcom,id = <2>;
+	qcom,pcs-chanid = <1>;
+	qcom,phy-mdio-addr = <0>;
+	qcom,poll-required = <0>;	/* no polling */
+	qcom,rgmii-delay = <0>;
+	qcom,phy_mii_type = <1>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <258>;
+	mdiobus = <&mdio0>;
 
 	fixed-link {
 		speed = <1000>;
@@ -162,6 +188,10 @@
 			0x00094 0x4e        /* PORT6_STATUS */
 			>;
 	};
+	
+	ethernet-phy@4 {
+		reg = <4>;
+	};
 };
 
 &nand_controller {
diff --git a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-r7500.dts b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-r7500.dts
index ed8ab3dbfa..f4d8578fe1 100644
--- a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-r7500.dts
+++ b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-r7500.dts
@@ -1,4 +1,4 @@
-#include "qcom-ipq8064-v1.0.dtsi"
+#include "qcom-ipq8064-v2.0.dtsi"
 
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/soc/qcom,tcsr.h>
@@ -254,8 +254,22 @@
 
 &gmac1 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37200000 0x200000>;
+	interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "rgmii";
 	qcom,id = <1>;
+	qcom,pcs-chanid = <0>;
+	qcom,phy-mdio-addr = <4>;
+	qcom,poll-required = <0>;
+	qcom,rgmii-delay = <1>;
+	qcom,phy_mii_type = <0>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <255>;
+	mdiobus = <&mdio0>;
 
 	pinctrl-0 = <&rgmii2_pins>;
 	pinctrl-names = "default";
@@ -270,8 +284,22 @@
 
 &gmac2 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37400000 0x200000>;
+	interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "sgmii";
 	qcom,id = <2>;
+	qcom,pcs-chanid = <1>;
+	qcom,phy-mdio-addr = <0>;	/* none */
+	qcom,poll-required = <0>;	/* no polling */
+	qcom,rgmii-delay = <0>;
+	qcom,phy_mii_type = <1>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <258>;
+	mdiobus = <&mdio0>;
 
 	mtd-mac-address = <&art 0>;
 
diff --git a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-r7500v2.dts b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-r7500v2.dts
index 20a1fad7b2..aaf78ddfdd 100644
--- a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-r7500v2.dts
+++ b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8064-r7500v2.dts
@@ -284,8 +284,22 @@
 
 &gmac1 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37200000 0x200000>;
+	interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "rgmii";
 	qcom,id = <1>;
+	qcom,pcs-chanid = <0>;
+	qcom,phy-mdio-addr = <4>;
+	qcom,poll-required = <0>;
+	qcom,rgmii-delay = <1>;
+	qcom,phy_mii_type = <0>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <255>;
+	mdiobus = <&mdio0>;
 
 	pinctrl-0 = <&rgmii2_pins>;
 	pinctrl-names = "default";
@@ -300,8 +314,22 @@
 
 &gmac2 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37400000 0x200000>;
+	interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "sgmii";
 	qcom,id = <2>;
+	qcom,pcs-chanid = <1>;
+	qcom,phy-mdio-addr = <0>;	/* none */
+	qcom,poll-required = <0>;	/* no polling */
+	qcom,rgmii-delay = <0>;
+	qcom,phy_mii_type = <1>;
+	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
+	qcom,irq = <258>;
+	mdiobus = <&mdio0>;
 
 	mtd-mac-address = <&art 0>;
 
@@ -309,4 +337,4 @@
 		speed = <1000>;
 		full-duplex;
 	};
-};
\ No newline at end of file
+};
diff --git a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065-nbg6817.dts b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065-nbg6817.dts
index 2573349f55..5fa0fdf37d 100644
--- a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065-nbg6817.dts
+++ b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065-nbg6817.dts
@@ -262,13 +262,20 @@
 
 &gmac1 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37200000 0x200000>;
+	interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "rgmii";
 	qcom,id = <1>;
-	qcom,phy_mdio_addr = <4>;
-	qcom,poll_required = <0>;
-	qcom,rgmii_delay = <1>;
+	qcom,pcs-chanid = <0>;
+	qcom,phy-mdio-addr = <4>;
+	qcom,poll-required = <0>;
+	qcom,rgmii-delay = <1>;
 	qcom,phy_mii_type = <0>;
 	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
 	qcom,irq = <255>;
 	mdiobus = <&mdio0>;
 
@@ -283,13 +290,20 @@
 
 &gmac2 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37400000 0x200000>;
+	interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "sgmii";
 	qcom,id = <2>;
-	qcom,phy_mdio_addr = <0>;	/* none */
-	qcom,poll_required = <0>;	/* no polling */
-	qcom,rgmii_delay = <0>;
+	qcom,pcs-chanid = <1>;
+	qcom,phy-mdio-addr = <0>;	/* none */
+	qcom,poll-required = <0>;	/* no polling */
+	qcom,rgmii-delay = <0>;
 	qcom,phy_mii_type = <1>;
 	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
 	qcom,irq = <258>;
 	mdiobus = <&mdio0>;
 
diff --git a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065-r7800.dts b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065-r7800.dts
index 181f6d3bde..104c02b0e7 100644
--- a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065-r7800.dts
+++ b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065-r7800.dts
@@ -342,13 +342,20 @@
 
 &gmac1 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37200000 0x200000>;
+	interrupts = <GIC_SPI 223 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "rgmii";
 	qcom,id = <1>;
-	qcom,phy_mdio_addr = <4>;
-	qcom,poll_required = <0>;
-	qcom,rgmii_delay = <1>;
+	qcom,pcs-chanid = <0>;
+	qcom,phy-mdio-addr = <4>;
+	qcom,poll-required = <0>;
+	qcom,rgmii-delay = <1>;
 	qcom,phy_mii_type = <0>;
 	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
 	qcom,irq = <255>;
 	mdiobus = <&mdio0>;
 
@@ -365,13 +372,20 @@
 
 &gmac2 {
 	status = "okay";
+	compatible = "qcom,nss-gmac";
+	reg = <0x37400000 0x200000>;
+	interrupts = <GIC_SPI 226 IRQ_TYPE_LEVEL_HIGH>;
 	phy-mode = "sgmii";
 	qcom,id = <2>;
-	qcom,phy_mdio_addr = <0>;	/* none */
-	qcom,poll_required = <0>;	/* no polling */
-	qcom,rgmii_delay = <0>;
+	qcom,pcs-chanid = <1>;
+	qcom,phy-mdio-addr = <0>;	/* none */
+	qcom,poll-required = <0>;	/* no polling */
+	qcom,rgmii-delay = <0>;
 	qcom,phy_mii_type = <1>;
 	qcom,emulation = <0>;
+	qcom,forced-speed = <1000>;
+	qcom,forced-duplex = <1>;
+	qcom,socver = <0>;
 	qcom,irq = <258>;
 	mdiobus = <&mdio0>;
 
diff --git a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065.dtsi b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065.dtsi
index ab67d504e6..e3daeb447a 100644
--- a/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065.dtsi
+++ b/target/linux/ipq806x/files/arch/arm/boot/dts/qcom-ipq8065.dtsi
@@ -155,3 +155,15 @@
 		clock-latency-ns = <100000>;
 	};
 };
+
+&nss0 {
+	qcom,low-frequency = <800000000>;
+	qcom,mid-frequency = <800000000>;
+	qcom,max-frequency = <800000000>;
+};
+
+&nss1 {
+	qcom,low-frequency = <800000000>;
+	qcom,mid-frequency = <800000000>;
+	qcom,max-frequency = <800000000>;
+};
diff --git a/target/linux/ipq806x/files/include/linux/regulator/nss-volt-ipq806x.h b/target/linux/ipq806x/files/include/linux/regulator/nss-volt-ipq806x.h
new file mode 100644
index 0000000000..648160f06c
--- /dev/null
+++ b/target/linux/ipq806x/files/include/linux/regulator/nss-volt-ipq806x.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __QCOM_NSS_VOL_SCALING_H
+#define __QCOM_NSS_VOL_SCALING_H
+
+#include <linux/regulator/consumer.h>
+
+int nss_ramp_voltage(unsigned long rate, bool ramp_up);
+
+#endif
diff --git a/target/linux/ipq806x/files/include/net/netfilter/nf_conntrack_dscpremark_ext.h b/target/linux/ipq806x/files/include/net/netfilter/nf_conntrack_dscpremark_ext.h
new file mode 100644
index 0000000000..f37e1ac84c
--- /dev/null
+++ b/target/linux/ipq806x/files/include/net/netfilter/nf_conntrack_dscpremark_ext.h
@@ -0,0 +1,101 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/* DSCP remark conntrack extension APIs. */
+
+#ifndef _NF_CONNTRACK_DSCPREMARK_H
+#define _NF_CONNTRACK_DSCPREMARK_H
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+
+/* Rule flags */
+#define NF_CT_DSCPREMARK_EXT_DSCP_RULE_VALID 0x1
+
+/* Rule validity */
+#define NF_CT_DSCPREMARK_EXT_RULE_VALID 0x1
+#define NF_CT_DSCPREMARK_EXT_RULE_NOT_VALID 0x0
+
+/*
+ * DSCP remark conntrack extension structure.
+ */
+struct nf_ct_dscpremark_ext {
+	__u32 flow_priority;	/* Original direction packet priority */
+	__u32 reply_priority;	/* Reply direction packet priority */
+	__u16 igs_flow_qos_tag;	/* Original direction ingress packet priority */
+	__u16 igs_reply_qos_tag;	/* Reply direction ingress packet priority */
+	__u8 flow_dscp;		/* IP DSCP value for original direction */
+	__u8 reply_dscp;	/* IP DSCP value for reply direction */
+	__u16 rule_flags;	/* Rule Validity flags */
+};
+
+/*
+ * nf_ct_dscpremark_ext_find()
+ *	Finds the extension data of the conntrack entry if it exists.
+ */
+static inline struct nf_ct_dscpremark_ext *
+nf_ct_dscpremark_ext_find(const struct nf_conn *ct)
+{
+#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
+	return nf_ct_ext_find(ct, NF_CT_EXT_DSCPREMARK);
+#else
+	return NULL;
+#endif
+}
+
+/*
+ * nf_ct_dscpremark_ext_add()
+ *	Adds the extension data to the conntrack entry.
+ */
+static inline
+struct nf_ct_dscpremark_ext *nf_ct_dscpremark_ext_add(struct nf_conn *ct,
+						      gfp_t gfp)
+{
+#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
+	struct nf_ct_dscpremark_ext *ncde;
+
+	ncde = nf_ct_ext_add(ct, NF_CT_EXT_DSCPREMARK, gfp);
+	if (!ncde)
+		return NULL;
+
+	return ncde;
+#else
+	return NULL;
+#endif
+};
+
+#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
+extern int nf_conntrack_dscpremark_ext_init(void);
+extern void nf_conntrack_dscpremark_ext_fini(void);
+extern int nf_conntrack_dscpremark_ext_set_dscp_rule_valid(struct nf_conn *ct);
+extern int
+nf_conntrack_dscpremark_ext_get_dscp_rule_validity(struct nf_conn *ct);
+#else
+/*
+ * nf_conntrack_dscpremark_ext_init()
+ */
+static inline int nf_conntrack_dscpremark_ext_init(void)
+{
+	return 0;
+}
+
+/*
+ * nf_conntrack_dscpremark_ext_fini()
+ */
+static inline void nf_conntrack_dscpremark_ext_fini(void)
+{
+}
+#endif /* CONFIG_NF_CONNTRACK_DSCPREMARK_EXT */
+#endif /* _NF_CONNTRACK_DSCPREMARK_H */
diff --git a/target/linux/ipq806x/files/include/uapi/linux/tc_act/tc_nss_mirred.h b/target/linux/ipq806x/files/include/uapi/linux/tc_act/tc_nss_mirred.h
new file mode 100644
index 0000000000..3a368fcc8c
--- /dev/null
+++ b/target/linux/ipq806x/files/include/uapi/linux/tc_act/tc_nss_mirred.h
@@ -0,0 +1,36 @@
+#ifndef __LINUX_TC_NSS_MIRRED_H
+#define __LINUX_TC_NSS_MIRRED_H
+
+#include <linux/pkt_cls.h>
+
+/*
+ * Type of nss mirred action.
+ */
+#define TCA_ACT_MIRRED_NSS 17
+
+/*
+ * Types of parameters for nss mirred action.
+ */
+enum {
+	TC_NSS_MIRRED_UNSPEC,
+	TC_NSS_MIRRED_TM,
+	TC_NSS_MIRRED_PARMS,
+	__TC_NSS_MIRRED_MAX
+};
+#define TC_NSS_MIRRED_MAX (__TC_NSS_MIRRED_MAX - 1)
+
+/*
+ * tc_nss_mirred
+ *	tc command structure for nss mirred action.
+ */
+struct tc_nss_mirred {
+	tc_gen;			/* General tc structure. */
+	__u32 from_ifindex;	/* ifindex of the port from which traffic
+				 * will be redirected.
+				 */
+	__u32 to_ifindex;	/* ifindex of the port to which traffic
+				 * will be redirected.
+				 */
+};
+
+#endif	/* __LINUX_TC_NSS_MIRRED_H */
diff --git a/target/linux/ipq806x/files/net/netfilter/nf_conntrack_dscpremark_ext.c b/target/linux/ipq806x/files/net/netfilter/nf_conntrack_dscpremark_ext.c
new file mode 100644
index 0000000000..ded6d0290e
--- /dev/null
+++ b/target/linux/ipq806x/files/net/netfilter/nf_conntrack_dscpremark_ext.c
@@ -0,0 +1,92 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/* DSCP remark handling conntrack extension registration. */
+
+#include <linux/netfilter.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/export.h>
+
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+#include <net/netfilter/nf_conntrack_dscpremark_ext.h>
+
+/* DSCP remark conntrack extension type declaration */
+static struct nf_ct_ext_type dscpremark_extend __read_mostly = {
+	.len = sizeof(struct nf_ct_dscpremark_ext),
+	.align = __alignof__(struct nf_ct_dscpremark_ext),
+	.id = NF_CT_EXT_DSCPREMARK,
+};
+
+/* nf_conntrack_dscpremark_ext_init()
+ *	Initializes the DSCP remark conntrack extension.
+ */
+int nf_conntrack_dscpremark_ext_init(void)
+{
+	int ret;
+
+	ret = nf_ct_extend_register(&dscpremark_extend);
+	if (ret < 0) {
+		pr_warn("nf_conntrack_dscpremark: Unable to register extension\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+/* nf_conntrack_dscpremark_ext_set_dscp_rule_valid()
+ *	Set DSCP rule validity flag in the extension
+ */
+int nf_conntrack_dscpremark_ext_set_dscp_rule_valid(struct nf_conn *ct)
+{
+	struct nf_ct_dscpremark_ext *ncde;
+
+	ncde = nf_ct_dscpremark_ext_find(ct);
+	if (!ncde)
+		return -1;
+
+	ncde->rule_flags = NF_CT_DSCPREMARK_EXT_DSCP_RULE_VALID;
+	return 0;
+}
+EXPORT_SYMBOL(nf_conntrack_dscpremark_ext_set_dscp_rule_valid);
+
+/* nf_conntrack_dscpremark_ext_get_dscp_rule_validity()
+ *	Check if the DSCP rule flag is valid from the extension
+ */
+int nf_conntrack_dscpremark_ext_get_dscp_rule_validity(struct nf_conn *ct)
+{
+	struct nf_ct_dscpremark_ext *ncde;
+
+	ncde = nf_ct_dscpremark_ext_find(ct);
+	if (!ncde)
+		return NF_CT_DSCPREMARK_EXT_RULE_NOT_VALID;
+
+	if (ncde->rule_flags & NF_CT_DSCPREMARK_EXT_DSCP_RULE_VALID)
+		return NF_CT_DSCPREMARK_EXT_RULE_VALID;
+
+	return NF_CT_DSCPREMARK_EXT_RULE_NOT_VALID;
+}
+EXPORT_SYMBOL(nf_conntrack_dscpremark_ext_get_dscp_rule_validity);
+
+/* nf_conntrack_dscpremark_ext_fini()
+ *	De-initializes the DSCP remark conntrack extension.
+ */
+void nf_conntrack_dscpremark_ext_fini(void)
+{
+	nf_ct_extend_unregister(&dscpremark_extend);
+}
diff --git a/target/linux/ipq806x/patches-5.4/990-00-Add-required-entries-in-dts-files-for-NSS-support.patch.patch b/target/linux/ipq806x/patches-5.4/990-00-Add-required-entries-in-dts-files-for-NSS-support.patch.patch
new file mode 100644
index 0000000000..83d4ecf44d
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/990-00-Add-required-entries-in-dts-files-for-NSS-support.patch.patch
@@ -0,0 +1,170 @@
+--- b/arch/arm/boot/dts/qcom-ipq8064.dtsi
++++ a/arch/arm/boot/dts/qcom-ipq8064.dtsi
+@@ -1392,6 +1392,12 @@
+ 			status = "disabled";
+ 		};
+ 
++		nss-gmac-common {
++			compatible = "qcom,nss-gmac-common";
++			reg = <0x03000000 0x0000FFFF 0x1bb00000 0x0000FFFF 0x00900000 0x00004000>;
++			reg-names = "nss_reg_base", "qsgmii_reg_base", "clk_ctl_base";
++		};
++
+ 		gmac0: ethernet@37000000 {
+ 			device_type = "network";
+ 			compatible = "qcom,ipq806x-gmac";
+@@ -1492,7 +1498,132 @@
+ 			regulator-always-on;
+ 		};
+ 
+-		sdcc1bam:dma@12402000 {
++		nss0: nss@40000000 {
++			compatible = "qcom,nss";
++			qcom,low-frequency = <733000000>; /* orig value 110000000 */
++			qcom,mid-frequency = <733000000>; /* orig value 550000000 */
++			qcom,max-frequency = <733000000>;
++
++			interrupts = <GIC_SPI 213 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 232 IRQ_TYPE_LEVEL_HIGH>;
++			reg = <0x36000000 0x1000 0x39000000 0x10000>;
++			reg-names = "nphys", "vphys";
++			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK_SRC>,
++				 <&gcc NSSTCM_CLK>, <&rpmcc RPM_NSS_FABRIC_0_CLK>,
++				 <&rpmcc RPM_NSS_FABRIC_1_CLK>;
++			clock-names = "nss-core-clk", "nss-tcm-src",
++				      "nss-tcm-clk", "nss-fab0-clk",
++				      "nss-fab1-clk";
++			resets = <&gcc UBI32_CORE1_CLKRST_CLAMP_RESET>,
++				 <&gcc UBI32_CORE1_CLAMP_RESET>,
++				 <&gcc UBI32_CORE1_AHB_RESET>,
++				 <&gcc UBI32_CORE1_AXI_RESET>;
++			reset-names = "clkrst-clamp", "clamp", "ahb", "axi";
++
++			qcom,id = <0>;
++			qcom,num-irq = <2>;
++			qcom,num-queue = <2>;
++			qcom,load-addr = <0x40000000>;
++			qcom,turbo-frequency;
++
++			qcom,bridge-enabled;
++			qcom,gre-enabled;
++			qcom,gre-redir-enabled;
++			qcom,gre_tunnel_enabled;
++			qcom,ipv4-enabled;
++			qcom,ipv4-reasm-enabled;
++			qcom,ipv6-enabled;
++			qcom,ipv6-reasm-enabled;
++			qcom,l2tpv2-enabled;
++			qcom,map-t-enabled;
++			qcom,pppoe-enabled;
++			qcom,pptp-enabled;
++			qcom,portid-enabled;
++			qcom,shaping-enabled;
++			qcom,tun6rd-enabled;
++			qcom,tunipip6-enabled;
++			qcom,vlan-enabled;
++			qcom,wlan-dataplane-offload-enabled;
++			qcom,wlanredirect-enabled;
++			qcom,pxvlan-enabled;
++			qcom,vxlan-enabled;
++			qcom,match-enabled;
++			qcom,mirror-enabled;
++			qcom,rmnet-enabled;
++			qcom,clmap-enabled;
++		};
++
++		nss1: nss@40800000 {
++			compatible = "qcom,nss";
++			qcom,low-frequency = <733000000>; /* orig value 110000000 */
++			qcom,mid-frequency = <733000000>; /* orig value 550000000 */
++			qcom,max-frequency = <733000000>;
++
++			interrupts = <GIC_SPI 214 IRQ_TYPE_LEVEL_HIGH>,
++				     <GIC_SPI 233 IRQ_TYPE_LEVEL_HIGH>;
++			reg = <0x36400000 0x1000 0x39010000 0x10000>;
++			reg-names = "nphys", "vphys";
++			resets = <&gcc UBI32_CORE2_CLKRST_CLAMP_RESET>,
++				 <&gcc UBI32_CORE2_CLAMP_RESET>,
++				 <&gcc UBI32_CORE2_AHB_RESET>,
++				 <&gcc UBI32_CORE2_AXI_RESET>;
++			reset-names = "clkrst-clamp", "clamp", "ahb", "axi";
++
++			qcom,id = <1>;
++			qcom,num-irq = <2>;
++			qcom,load-addr = <0x40800000>;
++			qcom,num-queue = <2>;
++			qcom,turbo-frequency;
++
++			qcom,capwap-enabled;
++			qcom,crypto-enabled;
++			qcom,dtls-enabled;
++			qcom,ipsec-enabled;
++		};
++
++		crypto1: crypto@38000000 {
++			compatible = "qcom,nss-crypto";
++			reg = <0x38000000 0x20000>, <0x38004000 0x22000>;
++			reg-names = "crypto_pbase", "bam_base";
++			clocks = <&gcc CE5_CORE_CLK>, <&gcc CE5_A_CLK>, <&gcc CE5_H_CLK>;
++			clock-names = "ce5_core", "ce5_aclk", "ce5_hclk";
++			resets = <&gcc CRYPTO_ENG1_RESET>, <&gcc CRYPTO_AHB_RESET>;
++			reset-names = "rst_eng", "rst_ahb";
++			qcom,id = <0>;
++			qcom,ee = <0>;
++		};
++
++		crypto2: crypto@38400000 {
++			compatible = "qcom,nss-crypto";
++			reg = <0x38400000 0x20000>, <0x38404000 0x22000>;
++			reg-names = "crypto_pbase", "bam_base";
++			resets = <&gcc CRYPTO_ENG2_RESET>;
++			reset-names = "rst_eng";
++			qcom,id = <1>;
++			qcom,ee = <0>;
++		};
++
++		crypto3: crypto@38800000 {
++			compatible = "qcom,nss-crypto";
++			reg = <0x38800000 0x20000>, <0x38804000 0x22000>;
++			reg-names = "crypto_pbase", "bam_base";
++			resets = <&gcc CRYPTO_ENG3_RESET>;
++			reset-names = "rst_eng";
++			qcom,id = <2>;
++			qcom,ee = <0>;
++		};
++
++		crypto4: crypto@38c00000 {
++			compatible = "qcom,nss-crypto";
++			reg = <0x38c00000 0x20000>, <0x38c04000 0x22000>;
++			reg-names = "crypto_pbase", "bam_base";
++			resets = <&gcc CRYPTO_ENG4_RESET>;
++			reset-names = "rst_eng";
++			qcom,id = <3>;
++			qcom,ee = <0>;
++		};
++
++		sdcc1bam: dma@12402000 {
+ 			compatible = "qcom,bam-v1.3.0";
+ 			reg = <0x12402000 0x8000>;
+ 			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+@@ -1558,6 +1689,20 @@
+ 				dma-names = "tx", "rx";
+ 			};
+ 		};
++
++		nss-common {
++			compatible = "qcom,nss-common";
++			reg = <0x03000000 0x00001000>;
++			reg-names = "nss_fpb_base";
++			clocks = <&gcc NSS_CORE_CLK>, <&gcc NSSTCM_CLK>,
++				<&rpmcc RPM_NSS_FABRIC_0_CLK>, <&rpmcc RPM_NSS_FABRIC_1_CLK>;
++			clock-names = "nss_core_clk", "nss_tcm_clk",
++				"nss-fab0-clk", "nss-fab1-clk";
++			nss_core-supply = <&smb208_s1b>;
++			nss_core_vdd_nominal = <1100000>;
++			nss_core_vdd_high = <1150000>;
++			nss_core_threshold_freq = <733000000>;
++		};
+ 	};
+ 
+ 	sfpb_mutex: sfpb-mutex {
diff --git a/target/linux/ipq806x/patches-5.4/999-00-Regulator-Add-NSS-VOLT.patch b/target/linux/ipq806x/patches-5.4/999-00-Regulator-Add-NSS-VOLT.patch
new file mode 100644
index 0000000000..ebe3e83409
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-00-Regulator-Add-NSS-VOLT.patch
@@ -0,0 +1,212 @@
+From c70758d96b22e4421a6afd824cb59e350c6a8040 Mon Sep 17 00:00:00 2001
+From: Robert Marko <robert.marko@sartura.hr>
+Date: Tue, 2 Jun 2020 22:09:15 +0200
+Subject: [PATCH] Regulator: Add NSS VOLT
+
+Signed-off-by: Robert Marko <robert.marko@sartura.hr>
+---
+ drivers/regulator/Kconfig  | 7 +++++++
+ drivers/regulator/Makefile | 1 +
+ 2 files changed, 8 insertions(+)
+
+--- a/drivers/regulator/Kconfig
++++ b/drivers/regulator/Kconfig
+@@ -1105,5 +1105,12 @@ config REGULATOR_WM8994
+ 	  This driver provides support for the voltage regulators on the
+ 	  WM8994 CODEC.
+ 
++config REGULATOR_NSS_VOLT
++	bool "Qualcomm IPQ806X NSS Voltage regulator"
++	depends on ARCH_QCOM || COMPILE_TEST
++	help
++	  This driver provides support for the Qualcomm IPQ806X NSS Voltage
++	  regulator.
++
+ endif
+ 
+--- a/drivers/regulator/Makefile
++++ b/drivers/regulator/Makefile
+@@ -138,5 +138,6 @@ obj-$(CONFIG_REGULATOR_WM831X) += wm831x
+ obj-$(CONFIG_REGULATOR_WM8350) += wm8350-regulator.o
+ obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
+ obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
++obj-$(CONFIG_REGULATOR_NSS_VOLT) += nss-volt-ipq806x.o
+ 
+ ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
+--- a/dev/null
+--- b/drivers/regulator/nss-volt-ipq806x.c
+@@ -0,0 +1,146 @@
++/*
++ * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
++ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++#include <linux/kernel.h>
++#include <linux/err.h>
++#include <linux/platform_device.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/regulator/nss-volt-ipq806x.h>
++
++struct nss_data {
++	struct regulator *nss_reg;
++	u32 nss_core_vdd_nominal;
++	u32 nss_core_vdd_high;
++	u32 nss_core_threshold_freq;
++};
++
++static struct nss_data *data;
++
++int nss_ramp_voltage(unsigned long rate, bool ramp_up)
++{
++	int ret;
++	int curr_uV, uV;
++	struct regulator *reg;
++
++	if (!data) {
++		pr_err("NSS core regulator not init.\n");
++		return -ENODEV;
++	}
++
++	reg = data->nss_reg;
++
++	if (!reg) {
++		pr_err("NSS core regulator not found.\n");
++		return -EINVAL;
++	}
++
++	uV = data->nss_core_vdd_nominal;
++	if (rate >= data->nss_core_threshold_freq)
++		return data->nss_core_vdd_high;
++
++	curr_uV = regulator_get_voltage(reg);
++
++	if (ramp_up) {
++		if (uV <= curr_uV)
++			return 0;
++	} else {
++		if (uV >= curr_uV)
++			return 0;
++	}
++
++	ret = regulator_set_voltage(reg, uV, data->nss_core_vdd_high);
++	if (ret)
++		pr_err("NSS volt scaling failed (%d)\n", uV);
++
++	return ret;
++}
++
++static const struct of_device_id nss_ipq806x_match_table[] = {
++	{ .compatible = "qcom,nss-common" },
++	{}
++};
++
++static int nss_volt_ipq806x_probe(struct platform_device *pdev)
++{
++	struct device_node *np = pdev->dev.of_node;
++	int ret;
++
++	if (!np)
++		return -ENODEV;
++
++	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	data->nss_reg = devm_regulator_get(&pdev->dev, "nss_core");
++	ret = PTR_ERR_OR_ZERO(data->nss_reg);
++	if (ret) {
++		if (ret == -EPROBE_DEFER)
++			dev_dbg(&pdev->dev,
++				"nss_core regulator not ready, retry\n");
++		else
++			dev_err(&pdev->dev, "no regulator for nss_core: %d\n",
++				ret);
++
++		return ret;
++	}
++
++	if (of_property_read_u32(np, "nss_core_vdd_nominal",
++				 &data->nss_core_vdd_nominal)) {
++		pr_warn("NSS core vdd nominal not found. Using defaults...\n");
++		data->nss_core_vdd_nominal = 1100000;
++	}
++
++	if (of_property_read_u32(np, "nss_core_vdd_high",
++				 &data->nss_core_vdd_high)) {
++		pr_warn("NSS core vdd high not found. Using defaults...\n");
++		data->nss_core_vdd_high = 1150000;
++	}
++
++	if (of_property_read_u32(np, "nss_core_threshold_freq",
++				 &data->nss_core_threshold_freq)) {
++		pr_warn("NSS core thres freq not found. Using defaults...\n");
++		data->nss_core_threshold_freq = 733000000;
++	}
++
++	platform_set_drvdata(pdev, data);
++
++	return 0;
++}
++
++static struct platform_driver nss_ipq806x_driver = {
++	.probe          = nss_volt_ipq806x_probe,
++	.driver         = {
++		.name   = "nss-volt-ipq806x",
++		.owner  = THIS_MODULE,
++		.of_match_table = nss_ipq806x_match_table,
++	},
++};
++
++static int __init nss_ipq806x_init(void)
++{
++	return platform_driver_register(&nss_ipq806x_driver);
++}
++late_initcall(nss_ipq806x_init);
++
++static void __exit nss_ipq806x_exit(void)
++{
++	platform_driver_unregister(&nss_ipq806x_driver);
++}
++module_exit(nss_ipq806x_exit);
++
+--- a/dev/null
+--- b/include/linux/regulator/nss-volt-ipq806x.h
+@@ -0,0 +1,25 @@
++/*
++ * Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
++ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++#ifndef __QCOM_NSS_VOL_SCALING_H
++#define __QCOM_NSS_VOL_SCALING_H
++
++#include <linux/regulator/consumer.h>
++
++int nss_ramp_voltage(unsigned long rate, bool ramp_up);
++
++#endif
++
diff --git a/target/linux/ipq806x/patches-5.4/999-01-Revert-ARM-dma-mapping-remove-dmac_clean_range-and-d.patch b/target/linux/ipq806x/patches-5.4/999-01-Revert-ARM-dma-mapping-remove-dmac_clean_range-and-d.patch
new file mode 100644
index 0000000000..7e6d9b88ec
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-01-Revert-ARM-dma-mapping-remove-dmac_clean_range-and-d.patch
@@ -0,0 +1,144 @@
+From 733a75729c1fbb478caaed875dd9c09a878a553d Mon Sep 17 00:00:00 2001
+From: Robert Marko <robimarko@gmail.com>
+Date: Fri, 5 Jun 2020 11:44:27 +0200
+Subject: [PATCH] Revert "ARM: dma-mapping: remove dmac_clean_range and
+ dmac_inv_range"
+
+This partially reverts 'commit 702b94bff3c505 ("ARM: dma-mapping:
+remove dmac_clean_range and dmac_inv_range")'
+
+Some MSM drivers still use the dmac_clean and dmac_inv_range APIs.
+Bring back the defines and exports for v7 CPUs.
+
+Signed-off-by: Rohit Vaswani <rvaswani@codeaurora.org>
+Signed-off-by: Abhimanyu Kapur <abhimany@codeaurora.org>
+[sramana: resolved minor merge conflicts]
+Signed-off-by: Srinivas Ramana <sramana@codeaurora.org>
+(cherry picked from commit d6118c0a9f7ab2b131ca36dd3dbd5634603d14fe)
+
+Change-Id: Ib2ddb4452711c5c2013bf29f0b5d8a3572b10357
+Signed-off-by: Manoharan Vijaya Raghavan <mraghava@codeaurora.org>
+
+Signed-off-by: Robert Marko <robimarko@gmail.com>
+---
+ arch/arm/include/asm/cacheflush.h | 21 +++++++++++++++++++++
+ arch/arm/include/asm/glue-cache.h |  2 ++
+ arch/arm/mm/cache-v7.S            |  6 ++++--
+ arch/arm/mm/proc-macros.S         |  2 ++
+ arch/arm/mm/proc-syms.c           |  3 +++
+ 5 files changed, 32 insertions(+), 2 deletions(-)
+
+--- a/arch/arm/include/asm/cacheflush.h
++++ b/arch/arm/include/asm/cacheflush.h
+@@ -91,6 +91,21 @@
+  *	DMA Cache Coherency
+  *	===================
+  *
++ *	dma_inv_range(start, end)
++ *
++ *		Invalidate (discard) the specified virtual address range.
++ *		May not write back any entries.  If 'start' or 'end'
++ *		are not cache line aligned, those lines must be written
++ *		back.
++ *		- start  - virtual start address
++ *		- end    - virtual end address
++ *
++ *	dma_clean_range(start, end)
++ *
++ *		Clean (write back) the specified virtual address range.
++ *		- start  - virtual start address
++ *		- end    - virtual end address
++ *
+  *	dma_flush_range(start, end)
+  *
+  *		Clean and invalidate the specified virtual address range.
+@@ -112,6 +127,8 @@ struct cpu_cache_fns {
+ 	void (*dma_map_area)(const void *, size_t, int);
+ 	void (*dma_unmap_area)(const void *, size_t, int);
+ 
++	void (*dma_inv_range)(const void *, const void *);
++	void (*dma_clean_range)(const void *, const void *);
+ 	void (*dma_flush_range)(const void *, const void *);
+ } __no_randomize_layout;
+ 
+@@ -137,6 +154,8 @@ extern struct cpu_cache_fns cpu_cache;
+  * is visible to DMA, or data written by DMA to system memory is
+  * visible to the CPU.
+  */
++#define dmac_inv_range			cpu_cache.dma_inv_range
++#define dmac_clean_range		cpu_cache.dma_clean_range
+ #define dmac_flush_range		cpu_cache.dma_flush_range
+ 
+ #else
+@@ -156,6 +175,8 @@ extern void __cpuc_flush_dcache_area(voi
+  * is visible to DMA, or data written by DMA to system memory is
+  * visible to the CPU.
+  */
++extern void dmac_inv_range(const void *, const void *);
++extern void dmac_clean_range(const void *, const void *);
+ extern void dmac_flush_range(const void *, const void *);
+ 
+ #endif
+--- a/arch/arm/include/asm/glue-cache.h
++++ b/arch/arm/include/asm/glue-cache.h
+@@ -156,6 +156,8 @@ static inline void nop_dma_unmap_area(co
+ #define __cpuc_flush_dcache_area	__glue(_CACHE,_flush_kern_dcache_area)
+ 
+ #define dmac_flush_range		__glue(_CACHE,_dma_flush_range)
++#define dmac_inv_range			__glue(_CACHE, _dma_inv_range)
++#define dmac_clean_range		__glue(_CACHE, _dma_clean_range)
+ #endif
+ 
+ #endif
+--- a/arch/arm/mm/cache-v7.S
++++ b/arch/arm/mm/cache-v7.S
+@@ -363,7 +363,7 @@ ENDPROC(v7_flush_kern_dcache_area)
+  *	- start   - virtual start address of region
+  *	- end     - virtual end address of region
+  */
+-v7_dma_inv_range:
++ENTRY(v7_dma_inv_range)
+ 	dcache_line_size r2, r3
+ 	sub	r3, r2, #1
+ 	tst	r0, r3
+@@ -393,7 +393,7 @@ ENDPROC(v7_dma_inv_range)
+  *	- start   - virtual start address of region
+  *	- end     - virtual end address of region
+  */
+-v7_dma_clean_range:
++ENTRY(v7_dma_clean_range)
+ 	dcache_line_size r2, r3
+ 	sub	r3, r2, #1
+ 	bic	r0, r0, r3
+@@ -479,6 +479,8 @@ ENDPROC(v7_dma_unmap_area)
+ 
+ 	globl_equ	b15_dma_map_area,		v7_dma_map_area
+ 	globl_equ	b15_dma_unmap_area,		v7_dma_unmap_area
++	globl_equ	b15_dma_inv_range,		v7_dma_inv_range
++	globl_equ	b15_dma_clean_range,		v7_dma_clean_range
+ 	globl_equ	b15_dma_flush_range,		v7_dma_flush_range
+ 
+ 	define_cache_functions b15
+--- a/arch/arm/mm/proc-macros.S
++++ b/arch/arm/mm/proc-macros.S
+@@ -335,6 +335,8 @@ ENTRY(\name\()_cache_fns)
+ 	.long	\name\()_flush_kern_dcache_area
+ 	.long	\name\()_dma_map_area
+ 	.long	\name\()_dma_unmap_area
++	.long   \name\()_dma_inv_range
++	.long   \name\()_dma_clean_range
+ 	.long	\name\()_dma_flush_range
+ 	.size	\name\()_cache_fns, . - \name\()_cache_fns
+ .endm
+--- a/arch/arm/mm/proc-syms.c
++++ b/arch/arm/mm/proc-syms.c
+@@ -27,6 +27,9 @@ EXPORT_SYMBOL(__cpuc_flush_user_all);
+ EXPORT_SYMBOL(__cpuc_flush_user_range);
+ EXPORT_SYMBOL(__cpuc_coherent_kern_range);
+ EXPORT_SYMBOL(__cpuc_flush_dcache_area);
++EXPORT_SYMBOL(dmac_inv_range);
++EXPORT_SYMBOL(dmac_clean_range);
++EXPORT_SYMBOL(dmac_flush_range);
+ #else
+ EXPORT_SYMBOL(cpu_cache);
+ #endif
diff --git a/target/linux/ipq806x/patches-5.4/999-01a-nss_sfe-support.patch b/target/linux/ipq806x/patches-5.4/999-01a-nss_sfe-support.patch
new file mode 100644
index 0000000000..a0cf9b7b6f
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-01a-nss_sfe-support.patch
@@ -0,0 +1,263 @@
+--- a/include/linux/timer.h
++++ b/include/linux/timer.h
+@@ -17,6 +17,7 @@ struct timer_list {
+ 	unsigned long		expires;
+ 	void			(*function)(struct timer_list *);
+ 	u32			flags;
++	unsigned long		cust_data;
+ 
+ #ifdef CONFIG_LOCKDEP
+ 	struct lockdep_map	lockdep_map;
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -51,6 +51,8 @@
+ #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
+ 
+ extern void brioctl_set(int (*ioctl_hook)(struct net *, unsigned int, void __user *));
++extern void br_dev_update_stats(struct net_device *dev,
++				struct rtnl_link_stats64 *nlstats);
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
+ int br_multicast_list_adjacent(struct net_device *dev,
+--- a/include/net/netns/conntrack.h
++++ b/include/net/netns/conntrack.h
+@@ -112,6 +112,9 @@ struct netns_ct {
+ 
+ 	struct ct_pcpu __percpu *pcpu_lists;
+ 	struct ip_conntrack_stat __percpu *stat;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct atomic_notifier_head nf_conntrack_chain;
++#endif
+ 	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
+ 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
+ 	struct nf_ip_net	nf_ct_proto;
+--- a/include/net/netfilter/nf_conntrack_ecache.h
++++ b/include/net/netfilter/nf_conntrack_ecache.h
+@@ -72,6 +72,11 @@ struct nf_ct_event {
+ 	int report;
+ };
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++extern int nf_conntrack_register_chain_notifier(struct net *net, struct notifier_block *nb);
++extern int nf_conntrack_unregister_chain_notifier(struct net *net, struct notifier_block *nb);
++#endif
++
+ struct nf_ct_event_notifier {
+ 	int (*fcn)(unsigned int events, struct nf_ct_event *item);
+ };
+@@ -105,11 +110,13 @@ static inline void
+ nf_conntrack_event_cache(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+-	struct net *net = nf_ct_net(ct);
+ 	struct nf_conntrack_ecache *e;
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return;
++#endif
+ 
+ 	e = nf_ct_ecache_find(ct);
+ 	if (e == NULL)
+@@ -124,10 +131,12 @@ nf_conntrack_event_report(enum ip_conntr
+ 			  u32 portid, int report)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ 	const struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return 0;
++#endif
+ 
+ 	return nf_conntrack_eventmask_report(1 << event, ct, portid, report);
+ #else
+@@ -139,10 +148,12 @@ static inline int
+ nf_conntrack_event(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ 	const struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return 0;
++#endif
+ 
+ 	return nf_conntrack_eventmask_report(1 << event, ct, 0, 0);
+ #else
+--- a/net/netfilter/nf_conntrack_proto_tcp.c
++++ b/net/netfilter/nf_conntrack_proto_tcp.c
+@@ -33,11 +33,13 @@
+ 
+ /* Do not check the TCP window for incoming packets  */
+-static int nf_ct_tcp_no_window_check __read_mostly = 1;
++int nf_ct_tcp_no_window_check __read_mostly = 1;
++EXPORT_SYMBOL_GPL(nf_ct_tcp_no_window_check);
+ 
+ /* "Be conservative in what you do,
+     be liberal in what you accept from others."
+     If it's non-zero, we mark only out of window RST segments as INVALID. */
+-static int nf_ct_tcp_be_liberal __read_mostly = 0;
++int nf_ct_tcp_be_liberal __read_mostly = 0;
++EXPORT_SYMBOL_GPL(nf_ct_tcp_be_liberal);
+ 
+ /* If it is set to zero, we disable picking up already established
+    connections. */
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -757,3 +757,26 @@
+ 	return p->flags & flag;
+ }
+ EXPORT_SYMBOL_GPL(br_port_flag_is_set);
++
++/* Update bridge statistics for bridge packets processed by offload engines */
++void br_dev_update_stats(struct net_device *dev,
++			 struct rtnl_link_stats64 *nlstats)
++{
++	struct net_bridge *br;
++	struct pcpu_sw_netstats *stats;
++
++	/* Is this a bridge? */
++	if (!(dev->priv_flags & IFF_EBRIDGE))
++		return;
++
++	br = netdev_priv(dev);
++	stats = this_cpu_ptr(br->stats);
++
++	u64_stats_update_begin(&stats->syncp);
++	stats->rx_packets += nlstats->rx_packets;
++	stats->rx_bytes += nlstats->rx_bytes;
++	stats->tx_packets += nlstats->tx_packets;
++	stats->tx_bytes += nlstats->tx_bytes;
++	u64_stats_update_end(&stats->syncp);
++}
++EXPORT_SYMBOL_GPL(br_dev_update_stats);
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -158,6 +158,14 @@
+ 
+ 	  If unsure, say `N'.
+ 
++config NF_CONNTRACK_CHAIN_EVENTS
++	bool "Register multiple callbacks to ct events"
++	depends on NF_CONNTRACK_EVENTS
++	help
++	  Support multiple registrations.
++
++	  If unsure, say `N'.
++
+ config NF_CONNTRACK_TIMESTAMP
+ 	bool  'Connection tracking timestamping'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -2588,6 +2588,9 @@ int nf_conntrack_init_net(struct net *ne
+ 	nf_conntrack_ecache_pernet_init(net);
+ 	nf_conntrack_helper_pernet_init(net);
+ 	nf_conntrack_proto_pernet_init(net);
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	ATOMIC_INIT_NOTIFIER_HEAD(&net->ct.nf_conntrack_chain);
++#endif
+ 
+ 	return 0;
+ 
+--- a/net/netfilter/nf_conntrack_ecache.c
++++ b/net/netfilter/nf_conntrack_ecache.c
+@@ -17,6 +17,9 @@
+ #include <linux/stddef.h>
+ #include <linux/err.h>
+ #include <linux/percpu.h>
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++#include <linux/notifier.h>
++#endif
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/slab.h>
+@@ -127,7 +130,11 @@ int nf_conntrack_eventmask_report(unsign
+ 
+ 	rcu_read_lock();
+ 	notify = rcu_dereference(net->ct.nf_conntrack_event_cb);
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	if (!notify && !rcu_dereference_raw(net->ct.nf_conntrack_chain.head))
++#else
+ 	if (!notify)
++#endif
+ 		goto out_unlock;
+ 
+ 	e = nf_ct_ecache_find(ct);
+@@ -146,7 +153,15 @@ int nf_conntrack_eventmask_report(unsign
+ 		if (!((eventmask | missed) & e->ctmask))
+ 			goto out_unlock;
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++		ret = atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
++			eventmask | missed, &item);
++
++		if (notify)
++			ret = notify->fcn(eventmask | missed, &item);
++#else
+ 		ret = notify->fcn(eventmask | missed, &item);
++#endif
+ 		if (unlikely(ret < 0 || missed)) {
+ 			spin_lock_bh(&ct->lock);
+ 			if (ret < 0) {
+@@ -186,7 +201,11 @@ void nf_ct_deliver_cached_events(struct
+ 
+ 	rcu_read_lock();
+ 	notify = rcu_dereference(net->ct.nf_conntrack_event_cb);
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	if ((notify == NULL) && !rcu_dereference_raw(net->ct.nf_conntrack_chain.head))
++#else
+ 	if (notify == NULL)
++#endif
+ 		goto out_unlock;
+ 
+ 	e = nf_ct_ecache_find(ct);
+@@ -210,7 +229,16 @@ void nf_ct_deliver_cached_events(struct
+ 	item.portid = 0;
+ 	item.report = 0;
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	ret = atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
++			events | missed,
++			&item);
++
++	if (notify != NULL)
++		ret = notify->fcn(events | missed, &item);
++#else
+ 	ret = notify->fcn(events | missed, &item);
++#endif
+ 
+ 	if (likely(ret == 0 && !missed))
+ 		goto out_unlock;
+@@ -257,6 +285,14 @@ out_unlock:
+ 	rcu_read_unlock();
+ }
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_register_chain_notifier(struct net *net, struct notifier_block *nb)
++{
++	return atomic_notifier_chain_register(&net->ct.nf_conntrack_chain, nb);
++}
++EXPORT_SYMBOL_GPL(nf_conntrack_register_chain_notifier);
++#endif
++
+ int nf_conntrack_register_notifier(struct net *net,
+ 				   struct nf_ct_event_notifier *new)
+ {
+@@ -279,6 +315,14 @@ out_unlock:
+ }
+ EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_unregister_chain_notifier(struct net *net, struct notifier_block *nb)
++{
++	return atomic_notifier_chain_unregister(&net->ct.nf_conntrack_chain, nb);
++}
++EXPORT_SYMBOL_GPL(nf_conntrack_unregister_chain_notifier);
++#endif
++
+ void nf_conntrack_unregister_notifier(struct net *net,
+ 				      struct nf_ct_event_notifier *new)
+ {
diff --git a/target/linux/ipq806x/patches-5.4/999-01b-shortcut-fe-support.patch b/target/linux/ipq806x/patches-5.4/999-01b-shortcut-fe-support.patch
new file mode 100644
index 0000000000..7e0e03e57f
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-01b-shortcut-fe-support.patch
@@ -0,0 +1,82 @@
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -825,6 +825,9 @@
+ 	__u8			decrypted:1;
+ #endif
+ 	__u8			gro_skip:1;
++#ifdef CONFIG_SHORTCUT_FE
++	__u8			fast_forwarded:1;
++#endif
+ 
+ #ifdef CONFIG_NET_SCHED
+ 	__u16			tc_index;	/* traffic control index */
+ #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
+ int br_multicast_list_adjacent(struct net_device *dev,
+--- a/net/Kconfig
++++ b/net/Kconfig
+@@ -473,3 +473,6 @@ config HAVE_CBPF_JIT
+ # Extended BPF JIT (eBPF)
+ config HAVE_EBPF_JIT
+ 	bool
++
++config SHORTCUT_FE
++	bool "Enables kernel network stack path for Shortcut  Forwarding Engine
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -3192,8 +3192,17 @@ static int xmit_one(struct sk_buff *skb,
+ 	unsigned int len;
+ 	int rc;
+ 
++#ifdef CONFIG_SHORTCUT_FE
++	/* If this skb has been fast forwarded then we don't want it to
++	 * go to any taps (by definition we're trying to bypass them).
++	 */
++	if (!skb->fast_forwarded) {
++#endif
+ 	if (dev_nit_active(dev))
+ 		dev_queue_xmit_nit(skb, dev);
++#ifdef CONFIG_SHORTCUT_FE
++	}
++#endif
+ 
+ #ifdef CONFIG_ETHERNET_PACKET_MANGLE
+ 	if (!dev->eth_mangle_tx ||
+@@ -4684,6 +4693,11 @@ void netdev_rx_handler_unregister(struct
+ }
+ EXPORT_SYMBOL_GPL(netdev_rx_handler_unregister);
+ 
++#ifdef CONFIG_SHORTCUT_FE
++int (*athrs_fast_nat_recv)(struct sk_buff *skb) __rcu __read_mostly;
++EXPORT_SYMBOL_GPL(athrs_fast_nat_recv);
++#endif
++
+ /*
+  * Limit the use of PFMEMALLOC reserves to those protocols that implement
+  * the special handling of PFMEMALLOC skbs.
+@@ -4733,6 +4747,9 @@ static int __netif_receive_skb_core(stru
+ 	bool deliver_exact = false;
+ 	int ret = NET_RX_DROP;
+ 	__be16 type;
++#ifdef CONFIG_SHORTCUT_FE
++	int (*fast_recv)(struct sk_buff *skb);
++#endif
+ 
+ 	net_timestamp_check(!netdev_tstamp_prequeue, skb);
+ 
+@@ -4773,6 +4790,16 @@ another_round:
+ 			goto out;
+ 	}
+ 
++#ifdef CONFIG_SHORTCUT_FE
++	fast_recv = rcu_dereference(athrs_fast_nat_recv);
++	if (fast_recv) {
++		if (fast_recv(skb)) {
++			ret = NET_RX_SUCCESS;
++			goto out;
++		}
++	}
++#endif
++
+ 	if (skb_skip_tc_classify(skb))
+ 		goto skip_classify;
+ 
\ No newline at end of file
diff --git a/target/linux/ipq806x/patches-5.4/999-02-nss-core-and-crypto-clocks.patch b/target/linux/ipq806x/patches-5.4/999-02-nss-core-and-crypto-clocks.patch
new file mode 100644
index 0000000000..3706c1369c
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-02-nss-core-and-crypto-clocks.patch
@@ -0,0 +1,535 @@
+--- a/include/dt-bindings/clock/qcom,gcc-ipq806x.h
++++ b/include/dt-bindings/clock/qcom,gcc-ipq806x.h
+@@ -240,7 +240,7 @@
+ #define PLL14					232
+ #define PLL14_VOTE				233
+ #define PLL18					234
+-#define CE5_SRC					235
++#define CE5_A_CLK				235
+ #define CE5_H_CLK				236
+ #define CE5_CORE_CLK				237
+ #define CE3_SLEEP_CLK				238
+@@ -283,5 +283,9 @@
+ #define EBI2_AON_CLK				281
+ #define NSSTCM_CLK_SRC				282
+ #define NSSTCM_CLK				283
++#define NSS_CORE_CLK				284 /* Virtual */
++#define CE5_A_CLK_SRC				285
++#define CE5_H_CLK_SRC				286
++#define CE5_CORE_CLK_SRC			287
+ 
+ #endif
+--- a/include/dt-bindings/reset/qcom,gcc-ipq806x.h
++++ b/include/dt-bindings/reset/qcom,gcc-ipq806x.h
+@@ -163,5 +163,10 @@
+ #define NSS_CAL_PRBS_RST_N_RESET			154
+ #define NSS_LCKDT_RST_N_RESET				155
+ #define NSS_SRDS_N_RESET				156
++#define CRYPTO_ENG1_RESET				157
++#define CRYPTO_ENG2_RESET				158
++#define CRYPTO_ENG3_RESET				159
++#define CRYPTO_ENG4_RESET				160
++#define CRYPTO_AHB_RESET				161
+ 
+ #endif
+--- a/drivers/clk/qcom/gcc-ipq806x.c
++++ b/drivers/clk/qcom/gcc-ipq806x.c
+@@ -24,6 +24,10 @@
+ #include "clk-branch.h"
+ #include "clk-hfpll.h"
+ #include "reset.h"
++#include <linux/regulator/nss-volt-ipq806x.h>
++
++/* NSS safe parent index which will be used during NSS PLL rate change */
++static int gcc_ipq806x_nss_safe_parent;
+ 
+ static struct clk_pll pll0 = {
+ 	.l_reg = 0x30c4,
+@@ -222,7 +226,9 @@ static struct clk_regmap pll14_vote = {
+ 
+ static struct pll_freq_tbl pll18_freq_tbl[] = {
+ 	NSS_PLL_RATE(550000000, 44, 0, 1, 0x01495625),
++	NSS_PLL_RATE(600000000, 48, 0, 1, 0x01495625),
+ 	NSS_PLL_RATE(733000000, 58, 16, 25, 0x014b5625),
++	NSS_PLL_RATE(800000000, 64, 0, 1, 0x01495625),
+ };
+ 
+ static struct clk_pll pll18 = {
+@@ -244,6 +250,22 @@ static struct clk_pll pll18 = {
+ 	},
+ };
+ 
++static struct clk_pll pll11 = {
++	.l_reg = 0x3184,
++	.m_reg = 0x3188,
++	.n_reg = 0x318c,
++	.config_reg = 0x3194,
++	.mode_reg = 0x3180,
++	.status_reg = 0x3198,
++	.status_bit = 16,
++	.clkr.hw.init = &(struct clk_init_data){
++		.name = "pll11",
++		.parent_names = (const char *[]){ "pxo" },
++		.num_parents = 1,
++		.ops = &clk_pll_ops,
++	},
++};
++
+ enum {
+ 	P_PXO,
+ 	P_PLL8,
+@@ -252,6 +274,7 @@ enum {
+ 	P_CXO,
+ 	P_PLL14,
+ 	P_PLL18,
++	P_PLL11,
+ };
+ 
+ static const struct parent_map gcc_pxo_pll8_map[] = {
+@@ -319,6 +342,42 @@ static const char * const gcc_pxo_pll8_p
+ 	"pll18",
+ };
+ 
++static const struct parent_map gcc_pxo_pll8_pll0_pll14_pll18_pll11_map[] = {
++	{ P_PXO, 0 },
++	{ P_PLL8, 4 },
++	{ P_PLL0, 2 },
++	{ P_PLL14, 5 },
++	{ P_PLL18, 1 },
++	{ P_PLL11, 3 },
++};
++
++static const char *gcc_pxo_pll8_pll0_pll14_pll18_pll11[] = {
++	"pxo",
++	"pll8_vote",
++	"pll0_vote",
++	"pll14",
++	"pll18",
++	"pll11"
++};
++
++static const struct parent_map gcc_pxo_pll3_pll0_pll14_pll18_pll11_map[] = {
++	{ P_PXO, 0 },
++	{ P_PLL3, 6 },
++	{ P_PLL0, 2 },
++	{ P_PLL14, 5 },
++	{ P_PLL18, 1 },
++	{ P_PLL11, 3 },
++};
++
++static const char *gcc_pxo_pll3_pll0_pll14_pll18_pll11[] = {
++	"pxo",
++	"pll3",
++	"pll0_vote",
++	"pll14",
++	"pll18",
++	"pll11"
++};
++
+ static struct freq_tbl clk_tbl_gsbi_uart[] = {
+ 	{  1843200, P_PLL8, 2,  6, 625 },
+ 	{  3686400, P_PLL8, 2, 12, 625 },
+@@ -2643,7 +2702,9 @@ static const struct freq_tbl clk_tbl_nss
+ 	{ 110000000, P_PLL18, 1, 1, 5 },
+ 	{ 275000000, P_PLL18, 2, 0, 0 },
+ 	{ 550000000, P_PLL18, 1, 0, 0 },
++	{ 600000000, P_PLL18, 1, 0, 0 },
+ 	{ 733000000, P_PLL18, 1, 0, 0 },
++	{ 800000000, P_PLL18, 1, 0, 0 },
+ 	{ }
+ };
+ 
+@@ -2753,6 +2814,319 @@ static struct clk_dyn_rcg ubi32_core2_sr
+ 	},
+ };
+ 
++static const struct freq_tbl clk_tbl_ce5_core[] = {
++	{ 150000000, P_PLL3, 8, 1, 1 },
++	{ 213200000, P_PLL11, 5, 1, 1 },
++	{ }
++};
++
++static struct clk_dyn_rcg ce5_core_src = {
++	.ns_reg[0] = 0x36C4,
++	.ns_reg[1] = 0x36C8,
++	.bank_reg = 0x36C0,
++	.s[0] = {
++		.src_sel_shift = 0,
++		.parent_map = gcc_pxo_pll3_pll0_pll14_pll18_pll11_map,
++	},
++	.s[1] = {
++		.src_sel_shift = 0,
++		.parent_map = gcc_pxo_pll3_pll0_pll14_pll18_pll11_map,
++	},
++	.p[0] = {
++		.pre_div_shift = 3,
++		.pre_div_width = 4,
++	},
++	.p[1] = {
++		.pre_div_shift = 3,
++		.pre_div_width = 4,
++	},
++	.mux_sel_bit = 0,
++	.freq_tbl = clk_tbl_ce5_core,
++	.clkr = {
++		.enable_reg = 0x36C0,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data){
++			.name = "ce5_core_src",
++			.parent_names = gcc_pxo_pll3_pll0_pll14_pll18_pll11,
++			.num_parents = 6,
++			.ops = &clk_dyn_rcg_ops,
++		},
++	},
++};
++
++static struct clk_branch ce5_core_clk = {
++	.halt_reg = 0x2FDC,
++	.halt_bit = 5,
++	.hwcg_reg = 0x36CC,
++	.hwcg_bit = 6,
++	.clkr = {
++		.enable_reg = 0x36CC,
++		.enable_mask = BIT(4),
++		.hw.init = &(struct clk_init_data){
++			.name = "ce5_core_clk",
++			.parent_names = (const char *[]){
++				"ce5_core_src",
++			},
++			.num_parents = 1,
++			.ops = &clk_branch_ops,
++			.flags = CLK_SET_RATE_PARENT,
++		},
++	},
++};
++
++static const struct freq_tbl clk_tbl_ce5_a_clk[] = {
++	{ 160000000, P_PLL0, 5, 1, 1 },
++	{ 213200000, P_PLL11, 5, 1, 1 },
++	{ }
++};
++
++static struct clk_dyn_rcg ce5_a_clk_src = {
++	.ns_reg[0] = 0x3d84,
++	.ns_reg[1] = 0x3d88,
++	.bank_reg = 0x3d80,
++	.s[0] = {
++		.src_sel_shift = 0,
++		.parent_map = gcc_pxo_pll8_pll0_pll14_pll18_pll11_map,
++	},
++	.s[1] = {
++		.src_sel_shift = 0,
++		.parent_map = gcc_pxo_pll8_pll0_pll14_pll18_pll11_map,
++	},
++	.p[0] = {
++		.pre_div_shift = 3,
++		.pre_div_width = 4,
++	},
++	.p[1] = {
++		.pre_div_shift = 3,
++		.pre_div_width = 4,
++	},
++	.mux_sel_bit = 0,
++	.freq_tbl = clk_tbl_ce5_a_clk,
++	.clkr = {
++		.enable_reg = 0x3d80,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data){
++			.name = "ce5_a_clk_src",
++			.parent_names = gcc_pxo_pll8_pll0_pll14_pll18_pll11,
++			.num_parents = 6,
++			.ops = &clk_dyn_rcg_ops,
++		},
++	},
++};
++
++static struct clk_branch ce5_a_clk = {
++	.halt_reg = 0x3c20,
++	.halt_bit = 12,
++	.hwcg_reg = 0x3d8c,
++	.hwcg_bit = 6,
++	.clkr = {
++		.enable_reg = 0x3d8c,
++		.enable_mask = BIT(4),
++		.hw.init = &(struct clk_init_data){
++			.name = "ce5_a_clk",
++			.parent_names = (const char *[]){
++				"ce5_a_clk_src",
++			},
++			.num_parents = 1,
++			.ops = &clk_branch_ops,
++			.flags = CLK_SET_RATE_PARENT,
++		},
++	},
++};
++
++static const struct freq_tbl clk_tbl_ce5_h_clk[] = {
++	{ 160000000, P_PLL0, 5, 1, 1 },
++	{ 213200000, P_PLL11, 5, 1, 1 },
++	{ }
++};
++
++static struct clk_dyn_rcg ce5_h_clk_src = {
++	.ns_reg[0] = 0x3c64,
++	.ns_reg[1] = 0x3c68,
++	.bank_reg = 0x3c60,
++	.s[0] = {
++		.src_sel_shift = 0,
++		.parent_map = gcc_pxo_pll8_pll0_pll14_pll18_pll11_map,
++	},
++	.s[1] = {
++		.src_sel_shift = 0,
++		.parent_map = gcc_pxo_pll8_pll0_pll14_pll18_pll11_map,
++	},
++	.p[0] = {
++		.pre_div_shift = 3,
++		.pre_div_width = 4,
++	},
++	.p[1] = {
++		.pre_div_shift = 3,
++		.pre_div_width = 4,
++	},
++	.mux_sel_bit = 0,
++	.freq_tbl = clk_tbl_ce5_h_clk,
++	.clkr = {
++		.enable_reg = 0x3c60,
++		.enable_mask = BIT(1),
++		.hw.init = &(struct clk_init_data){
++			.name = "ce5_h_clk_src",
++			.parent_names = gcc_pxo_pll8_pll0_pll14_pll18_pll11,
++			.num_parents = 6,
++			.ops = &clk_dyn_rcg_ops,
++		},
++	},
++};
++
++static struct clk_branch ce5_h_clk = {
++	.halt_reg = 0x3c20,
++	.halt_bit = 11,
++	.hwcg_reg = 0x3c6c,
++	.hwcg_bit = 6,
++	.clkr = {
++		.enable_reg = 0x3c6c,
++		.enable_mask = BIT(4),
++		.hw.init = &(struct clk_init_data){
++			.name = "ce5_h_clk",
++			.parent_names = (const char *[]){
++				"ce5_h_clk_src",
++			},
++			.num_parents = 1,
++			.ops = &clk_branch_ops,
++			.flags = CLK_SET_RATE_PARENT,
++		},
++	},
++};
++
++static int nss_core_clk_set_rate(struct clk_hw *hw, unsigned long rate,
++				 unsigned long parent_rate)
++{
++	int ret;
++
++	/*
++	 * When ramping up voltage, it needs to be done first. This ensures that
++	 * the volt required will be available when you step up the frequency.
++	 */
++	ret = nss_ramp_voltage(rate, true);
++	if (ret)
++		return ret;
++
++	ret = clk_dyn_rcg_ops.set_rate(&ubi32_core1_src_clk.clkr.hw, rate,
++				    parent_rate);
++	if (ret)
++		return ret;
++
++	ret = clk_dyn_rcg_ops.set_rate(&ubi32_core2_src_clk.clkr.hw, rate,
++				    parent_rate);
++
++	if (ret)
++		return ret;
++
++	/*
++	 * When ramping down voltage, it needs to be set first. This ensures
++	 * that the volt required will be available until you step down the
++	 * frequency.
++	 */
++	ret = nss_ramp_voltage(rate, false);
++
++	return ret;
++}
++
++static int
++nss_core_clk_set_rate_and_parent(struct clk_hw *hw, unsigned long rate,
++				 unsigned long parent_rate, u8 index)
++{
++	int ret;
++
++	/*
++	 * When ramping up voltage needs to be done first. This ensures that
++	 * the voltage required will be available when you step up the
++	 * frequency.
++	 */
++	ret = nss_ramp_voltage(rate, true);
++	if (ret)
++		return ret;
++
++	ret = clk_dyn_rcg_ops.set_rate_and_parent(
++			&ubi32_core1_src_clk.clkr.hw, rate, parent_rate, index);
++	if (ret)
++		return ret;
++
++	ret = clk_dyn_rcg_ops.set_rate_and_parent(
++			&ubi32_core2_src_clk.clkr.hw, rate, parent_rate, index);
++
++	if (ret)
++		return ret;
++
++	/*
++	 * When ramping down voltage needs to be done last. This ensures that
++	 * the voltage required will be available when you step down the
++	 * frequency.
++	 */
++	ret = nss_ramp_voltage(rate, false);
++
++	return ret;
++}
++
++static int nss_core_clk_determine_rate(struct clk_hw *hw,
++					struct clk_rate_request *req)
++{
++	return clk_dyn_rcg_ops.determine_rate(&ubi32_core1_src_clk.clkr.hw,
++						req);
++}
++
++static unsigned long
++nss_core_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
++{
++	return clk_dyn_rcg_ops.recalc_rate(&ubi32_core1_src_clk.clkr.hw,
++						 parent_rate);
++}
++
++static u8 nss_core_clk_get_parent(struct clk_hw *hw)
++{
++	return clk_dyn_rcg_ops.get_parent(&ubi32_core1_src_clk.clkr.hw);
++}
++
++static int nss_core_clk_set_parent(struct clk_hw *hw, u8 i)
++{
++	int ret;
++	struct clk_dyn_rcg *rcg;
++	struct freq_tbl f = {  200000000, P_PLL0, 2,  1, 2 };
++
++	/* P_PLL0 is 800 Mhz which needs to be divided for 200 Mhz */
++	if (i == gcc_ipq806x_nss_safe_parent) {
++		rcg = to_clk_dyn_rcg(&ubi32_core1_src_clk.clkr.hw);
++		clk_dyn_configure_bank(rcg, &f);
++
++		rcg = to_clk_dyn_rcg(&ubi32_core2_src_clk.clkr.hw);
++		clk_dyn_configure_bank(rcg, &f);
++
++		return 0;
++	}
++
++	ret = clk_dyn_rcg_ops.set_parent(&ubi32_core1_src_clk.clkr.hw, i);
++	if (ret)
++		return ret;
++
++	return clk_dyn_rcg_ops.set_parent(&ubi32_core2_src_clk.clkr.hw, i);
++}
++
++static const struct clk_ops clk_ops_nss_core = {
++	.set_rate = nss_core_clk_set_rate,
++	.set_rate_and_parent = nss_core_clk_set_rate_and_parent,
++	.determine_rate = nss_core_clk_determine_rate,
++	.recalc_rate = nss_core_clk_recalc_rate,
++	.get_parent = nss_core_clk_get_parent,
++	.set_parent = nss_core_clk_set_parent,
++};
++
++/* Virtual clock for nss core clocks */
++static struct clk_regmap nss_core_clk = {
++	.hw.init = &(struct clk_init_data){
++		.name = "nss_core_clk",
++		.ops = &clk_ops_nss_core,
++		.parent_names = gcc_pxo_pll8_pll14_pll18_pll0,
++		.num_parents = 5,
++		.flags = CLK_SET_RATE_PARENT,
++	},
++};
++
+ static struct clk_regmap *gcc_ipq806x_clks[] = {
+ 	[PLL0] = &pll0.clkr,
+ 	[PLL0_VOTE] = &pll0_vote,
+@@ -2760,6 +3134,7 @@ static struct clk_regmap *gcc_ipq806x_cl
+ 	[PLL4_VOTE] = &pll4_vote,
+ 	[PLL8] = &pll8.clkr,
+ 	[PLL8_VOTE] = &pll8_vote,
++	[PLL11] = &pll11.clkr,
+ 	[PLL14] = &pll14.clkr,
+ 	[PLL14_VOTE] = &pll14_vote,
+ 	[PLL18] = &pll18.clkr,
+@@ -2871,9 +3246,16 @@ static struct clk_regmap *gcc_ipq806x_cl
+ 	[UBI32_CORE2_CLK_SRC] = &ubi32_core2_src_clk.clkr,
+ 	[NSSTCM_CLK_SRC] = &nss_tcm_src.clkr,
+ 	[NSSTCM_CLK] = &nss_tcm_clk.clkr,
++	[NSS_CORE_CLK] = &nss_core_clk,
+ 	[PLL9] = &hfpll0.clkr,
+ 	[PLL10] = &hfpll1.clkr,
+ 	[PLL12] = &hfpll_l2.clkr,
++	[CE5_A_CLK_SRC] = &ce5_a_clk_src.clkr,
++	[CE5_A_CLK] = &ce5_a_clk.clkr,
++	[CE5_H_CLK_SRC] = &ce5_h_clk_src.clkr,
++	[CE5_H_CLK] = &ce5_h_clk.clkr,
++	[CE5_CORE_CLK_SRC] = &ce5_core_src.clkr,
++	[CE5_CORE_CLK] = &ce5_core_clk.clkr,
+ };
+ 
+ static const struct qcom_reset_map gcc_ipq806x_resets[] = {
+@@ -3005,6 +3387,11 @@ static const struct qcom_reset_map gcc_i
+ 	[GMAC_CORE3_RESET] = { 0x3cfc, 0 },
+ 	[GMAC_CORE4_RESET] = { 0x3d1c, 0 },
+ 	[GMAC_AHB_RESET] = { 0x3e24, 0 },
++	[CRYPTO_ENG1_RESET] = { 0x3e00, 0},
++	[CRYPTO_ENG2_RESET] = { 0x3e04, 0},
++	[CRYPTO_ENG3_RESET] = { 0x3e08, 0},
++	[CRYPTO_ENG4_RESET] = { 0x3e0c, 0},
++	[CRYPTO_AHB_RESET] = { 0x3e10, 0},
+ 	[NSS_CH0_RST_RX_CLK_N_RESET] = { 0x3b60, 0 },
+ 	[NSS_CH0_RST_TX_CLK_N_RESET] = { 0x3b60, 1 },
+ 	[NSS_CH0_RST_RX_125M_N_RESET] = { 0x3b60, 2 },
+@@ -3080,6 +3467,12 @@ static int gcc_ipq806x_probe(struct plat
+ 	if (!regmap)
+ 		return -ENODEV;
+ 
++	gcc_ipq806x_nss_safe_parent = qcom_find_src_index(&nss_core_clk.hw,
++					gcc_pxo_pll8_pll14_pll18_pll0_map,
++					P_PLL0);
++	if (gcc_ipq806x_nss_safe_parent < 0)
++		return gcc_ipq806x_nss_safe_parent;
++
+ 	/* Setup PLL18 static bits */
+ 	regmap_update_bits(regmap, 0x31a4, 0xffffffc0, 0x40000400);
+ 	regmap_write(regmap, 0x31b0, 0x3080);
+--- a/drivers/clk/qcom/clk-rcg.c
++++ b/drivers/clk/qcom/clk-rcg.c
+@@ -805,6 +805,11 @@ static int clk_dyn_rcg_set_rate_and_pare
+ 	return __clk_dyn_rcg_set_rate(hw, rate);
+ }
+ 
++void clk_dyn_configure_bank(struct clk_dyn_rcg *rcg, const struct freq_tbl *f)
++{
++	configure_bank(rcg, f);
++}
++
+ const struct clk_ops clk_rcg_ops = {
+ 	.enable = clk_enable_regmap,
+ 	.disable = clk_disable_regmap,
+--- a/drivers/clk/qcom/clk-rcg.h
++++ b/drivers/clk/qcom/clk-rcg.h
+@@ -173,4 +173,7 @@ struct clk_rcg_dfs_data {
+ extern int qcom_cc_register_rcg_dfs(struct regmap *regmap,
+ 				    const struct clk_rcg_dfs_data *rcgs,
+ 				    size_t len);
++ 
++extern void clk_dyn_configure_bank(struct clk_dyn_rcg *rcg,
++					const struct freq_tbl *f);
+ #endif
diff --git a/target/linux/ipq806x/patches-5.4/999-03a-qca-nss-ecm-support.patch b/target/linux/ipq806x/patches-5.4/999-03a-qca-nss-ecm-support.patch
new file mode 100644
index 0000000000..9b9837abbc
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-03a-qca-nss-ecm-support.patch
@@ -0,0 +1,1581 @@
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -148,4 +148,39 @@ br_port_flag_is_set(const struct net_dev
+ }
+ #endif
+ 
++/* QCA NSS ECM support - Start */
++extern struct net_device *br_port_dev_get(struct net_device *dev,
++					  unsigned char *addr,
++					  struct sk_buff *skb,
++					  unsigned int cookie);
++extern void br_refresh_fdb_entry(struct net_device *dev, const char *addr);
++extern struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
++						     const char *addr,
++						     __u16 vid);
++extern void br_fdb_update_register_notify(struct notifier_block *nb);
++extern void br_fdb_update_unregister_notify(struct notifier_block *nb);
++
++typedef struct net_bridge_port *br_port_dev_get_hook_t(struct net_device *dev,
++						       struct sk_buff *skb,
++						       unsigned char *addr,
++						       unsigned int cookie);
++extern br_port_dev_get_hook_t __rcu *br_port_dev_get_hook;
++
++#define BR_FDB_EVENT_ADD     0x01
++#define BR_FDB_EVENT_DEL     0x02
++
++struct br_fdb_event {
++	struct net_device *dev;
++	unsigned char      addr[6];
++	unsigned char      is_local;
++};
++extern void br_fdb_register_notify(struct notifier_block *nb);
++extern void br_fdb_unregister_notify(struct notifier_block *nb);
++
++typedef struct net_bridge_port *br_get_dst_hook_t(
++		const struct net_bridge_port *src,
++		struct sk_buff **skb);
++extern br_get_dst_hook_t __rcu *br_get_dst_hook;
++/* QCA NSS ECM support - End */
++
+ #endif
+--- a/include/linux/if_pppol2tp.h
++++ b/include/linux/if_pppol2tp.h
+@@ -14,4 +14,30 @@
+ #include <linux/in6.h>
+ #include <uapi/linux/if_pppol2tp.h>
+ 
++/* QCA NSS ECM support - Start */
++/*
++ * Holds L2TP channel info
++ */
++struct  pppol2tp_common_addr {
++	int tunnel_version;				/* v2 or v3 */
++	__u32 local_tunnel_id, remote_tunnel_id;	/* tunnel id */
++	__u32 local_session_id, remote_session_id;	/* session id */
++	struct sockaddr_in local_addr, remote_addr; /* ip address and port */
++};
++
++/*
++ * L2TP channel operations
++ */
++struct pppol2tp_channel_ops {
++	struct ppp_channel_ops ops; /* ppp channel ops */
++};
++
++/*
++ * exported function which calls pppol2tp channel's get addressing
++ * function
++ */
++extern int pppol2tp_channel_addressing_get(struct ppp_channel *,
++					   struct pppol2tp_common_addr *);
++/* QCA NSS ECM support - End */
++
+ #endif
+--- a/include/linux/if_vlan.h
++++ b/include/linux/if_vlan.h
+@@ -220,7 +220,28 @@ extern void vlan_vids_del_by_dev(struct
+ 
+ extern bool vlan_uses_dev(const struct net_device *dev);
+ 
++/* QCA NSS ECM support - Start */
++extern void __vlan_dev_update_accel_stats(struct net_device *dev,
++                                    struct rtnl_link_stats64 *stats);
++extern u16 vlan_dev_get_egress_prio(struct net_device *dev, u32 skb_prio);
++extern struct net_device *vlan_dev_next_dev(const struct net_device *dev);
++/* QCA NSS ECM support - End */
++
+ #else
++/* QCA NSS ECM support - Start */
++static inline void __vlan_dev_update_accel_stats(struct net_device *dev,
++					   struct rtnl_link_stats64 *stats)
++{
++
++}
++
++static inline u16 vlan_dev_get_egress_prio(struct net_device *dev,
++						u32 skb_prio)
++{
++	return 0;
++}
++/* QCA NSS ECM support - End */
++
+ static inline struct net_device *
+ __vlan_find_dev_deep_rcu(struct net_device *real_dev,
+ 		     __be16 vlan_proto, u16 vlan_id)
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1581,6 +1581,20 @@ enum netdev_priv_flags {
+ #define IFF_LIVE_RENAME_OK		IFF_LIVE_RENAME_OK
+ #define IFF_NO_IP_ALIGN			IFF_NO_IP_ALIGN
+ 
++/* QCA NSS ECM support - Start */
++enum netdev_priv_qca_ecm_flags {
++	IFF_QCA_ECM_TUN_TAP		= 1<<0,
++	IFF_QCA_ECM_PPP_L2TPV2		= 1<<1,
++	IFF_QCA_ECM_PPP_L2TPV3		= 1<<2,
++	IFF_QCA_ECM_PPP_PPTP		= 1<<3,
++};
++
++#define IFF_QCA_ECM_TUN_TAP		IFF_QCA_ECM_TUN_TAP
++#define IFF_QCA_ECM_PPP_L2TPV2		IFF_QCA_ECM_PPP_L2TPV2
++#define IFF_QCA_ECM_PPP_L2TPV3		IFF_QCA_ECM_PPP_L2TPV3
++#define IFF_QCA_ECM_PPP_PPTP		IFF_QCA_ECM_PPP_PPTP
++/* QCA NSS ECM support - End */
++
+ /**
+  *	struct net_device - The DEVICE structure.
+  *
+@@ -1890,6 +1904,7 @@ struct net_device {
+ 
+ 	unsigned int		flags;
+ 	unsigned int		priv_flags;
++	unsigned int		priv_flags_qca_ecm;	/* QCA NSS ECM support */
+ 
+ 	unsigned short		gflags;
+ 	unsigned short		padded;
+@@ -2526,6 +2541,10 @@ enum netdev_cmd {
+ 	NETDEV_CVLAN_FILTER_DROP_INFO,
+ 	NETDEV_SVLAN_FILTER_PUSH_INFO,
+ 	NETDEV_SVLAN_FILTER_DROP_INFO,
++	/* QCA NSS ECM Support - Start */
++	NETDEV_BR_JOIN,
++	NETDEV_BR_LEAVE,
++	/* QCA NSS ECM Support - End */
+ };
+ const char *netdev_cmd_to_name(enum netdev_cmd cmd);
+ 
+--- a/include/net/bond_3ad.h
++++ b/include/net/bond_3ad.h
+@@ -307,5 +307,13 @@ void bond_3ad_update_lacp_rate(struct bo
+ void bond_3ad_update_ad_actor_settings(struct bonding *bond);
+ int bond_3ad_stats_fill(struct sk_buff *skb, struct bond_3ad_stats *stats);
+ size_t bond_3ad_stats_size(void);
++
++/* QCA NSS ECM support - Start */
++struct net_device *bond_3ad_get_tx_dev(struct sk_buff *skb, uint8_t *src_mac,
++				       uint8_t *dst_mac, void *src,
++				       void *dst, uint16_t protocol,
++				       struct net_device *bond_dev,
++				       __be16 *layer4hdr);
++/* QCA NSS ECM support - End */
+ #endif /* _NET_BOND_3AD_H */
+ 
+--- a/include/net/bonding.h
++++ b/include/net/bonding.h
+@@ -238,6 +238,7 @@ struct bonding {
+ #endif /* CONFIG_DEBUG_FS */
+ 	struct rtnl_link_stats64 bond_stats;
+ 	struct lock_class_key stats_lock_key;
++	u32      id; /* QCA NSS ECM support */
+ };
+
+ #define bond_slave_get_rcu(dev) \
+@@ -749,4 +749,12 @@ static inline void bond_tx_drop(struct n
+ 	dev_kfree_skb_any(skb);
+ }
+ 
++/* QCA NSS ECM support - Start */
++extern struct bond_cb __rcu *bond_cb;
++
++uint32_t bond_xmit_hash_without_skb(uint8_t *src_mac, uint8_t *dst_mac,
++				    void *psrc, void *pdst, uint16_t protocol,
++				    struct net_device *bond_dev,
++				    __be16 *layer4hdr);
++/* QCA NSS ECM support - End */
+ #endif /* _NET_BONDING_H */
+--- a/include/net/ip6_route.h
++++ b/include/net/ip6_route.h
+@@ -209,6 +209,11 @@ void rt6_multipath_rebalance(struct fib6
+ void rt6_uncached_list_add(struct rt6_info *rt);
+ void rt6_uncached_list_del(struct rt6_info *rt);
+ 
++/* QCA NSS ECM support - Start */
++int rt6_register_notifier(struct notifier_block *nb);
++int rt6_unregister_notifier(struct notifier_block *nb);
++/* QCA NSS ECM support - End */
++
+ static inline const struct rt6_info *skb_rt6_info(const struct sk_buff *skb)
+ {
+ 	const struct dst_entry *dst = skb_dst(skb);
+--- a/include/net/neighbour.h
++++ b/include/net/neighbour.h
+@@ -568,4 +568,15 @@ static inline void neigh_update_is_route
+ 		*notify = 1;
+ 	}
+ }
++
++/* QCA NSS ECM support - Start */
++struct neigh_mac_update {
++	unsigned char old_mac[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
++	unsigned char update_mac[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
++};
++
++extern void neigh_mac_update_register_notify(struct notifier_block *nb);
++extern void neigh_mac_update_unregister_notify(struct notifier_block *nb);
++/* QCA NSS ECM support - End */
++
+ #endif
+--- a/include/net/netfilter/nf_conntrack_extend.h
++++ b/include/net/netfilter/nf_conntrack_extend.h
+@@ -31,6 +31,10 @@ enum nf_ct_ext_id {
+ #if IS_ENABLED(CONFIG_NF_CONNTRACK_RTCACHE)
+ 	NF_CT_EXT_RTCACHE,
+ #endif
++#ifdef CONFIG_NF_CONNTRACK_DSCPREMARK_EXT
++	NF_CT_EXT_DSCPREMARK,	/* QCA NSS ECM support */
++#endif
++
+ 	NF_CT_EXT_NUM,
+ };
+ 
+@@ -44,6 +48,9 @@ enum nf_ct_ext_id {
+ #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
+ #define NF_CT_EXT_SYNPROXY_TYPE struct nf_conn_synproxy
+ #define NF_CT_EXT_RTCACHE_TYPE struct nf_conn_rtcache
++/* QCA NSS ECM support - Start */
++#define NF_CT_EXT_DSCPREMARK_TYPE struct nf_ct_dscpremark_ext
++/* QCA NSS ECM support - End */
+ 
+ /* Extensions: optional stuff which isn't permanently in struct. */
+ struct nf_ct_ext {
+--- a/include/net/route.h
++++ b/include/net/route.h
+@@ -224,6 +224,11 @@ struct rtable *rt_dst_alloc(struct net_d
+ 			     bool nopolicy, bool noxfrm, bool will_cache);
+ struct rtable *rt_dst_clone(struct net_device *dev, struct rtable *rt);
+ 
++/* QCA NSS ECM support - Start */
++int ip_rt_register_notifier(struct notifier_block *nb);
++int ip_rt_unregister_notifier(struct notifier_block *nb);
++/* QCA NSS ECM support - End */
++
+ struct in_ifaddr;
+ void fib_add_ifaddr(struct in_ifaddr *);
+ void fib_del_ifaddr(struct in_ifaddr *, struct in_ifaddr *);
+--- a/include/uapi/linux/if_bonding.h
++++ b/include/uapi/linux/if_bonding.h
+@@ -141,6 +141,23 @@ enum {
+ };
+ #define BOND_3AD_STAT_MAX (__BOND_3AD_STAT_MAX - 1)
+ 
++/* QCA NSS ECM support - Start */
++#ifdef __KERNEL__
++struct bond_cb {
++	void (*bond_cb_link_up)(struct net_device *slave);
++	void (*bond_cb_link_down)(struct net_device *slave);
++	void (*bond_cb_enslave)(struct net_device *slave);
++	void (*bond_cb_release)(struct net_device *slave);
++	void (*bond_cb_delete_by_slave)(struct net_device *slave);
++	void (*bond_cb_delete_by_mac)(uint8_t *mac_addr);
++};
++
++extern int bond_register_cb(struct bond_cb *cb);
++extern void bond_unregister_cb(void);
++extern int bond_get_id(struct net_device *bond_dev);
++#endif /* __KERNEL__ */
++/* QCA NSS ECM support - End */
++
+ #endif /* _LINUX_IF_BONDING_H */
+ 
+ /*
+--- a/drivers/net/bonding/bond_3ad.c
++++ b/drivers/net/bonding/bond_3ad.c
+@@ -121,6 +121,39 @@ static void ad_marker_response_received(
+ 					struct port *port);
+ static void ad_update_actor_keys(struct port *port, bool reset);
+ 
++/* QCA NSS ECM support - Start */
++struct bond_cb __rcu *bond_cb;
++
++int bond_register_cb(struct bond_cb *cb)
++{
++	struct bond_cb *lag_cb;
++
++	rcu_read_lock();
++	lag_cb = kzalloc(sizeof(*lag_cb), GFP_ATOMIC | __GFP_NOWARN);
++	if (!lag_cb) {
++		rcu_read_unlock();
++		return -1;
++	}
++
++	memcpy((void *)lag_cb, (void *)cb, sizeof(*cb));
++	rcu_assign_pointer(bond_cb, lag_cb);
++	rcu_read_unlock();
++	return 0;
++}
++EXPORT_SYMBOL(bond_register_cb);
++
++void bond_unregister_cb(void)
++{
++	struct bond_cb *lag_cb_main;
++
++	rcu_read_lock();
++	lag_cb_main = rcu_dereference(bond_cb);
++	kfree(lag_cb_main);
++	rcu_assign_pointer(bond_cb, NULL);
++	rcu_read_unlock();
++}
++EXPORT_SYMBOL(bond_unregister_cb);
++/* QCA NSS ECM support - Start */
+ 
+ /* ================= api to bonding and kernel code ================== */
+ 
+@@ -998,6 +1031,29 @@ static void ad_mux_machine(struct port *
+ 				port->actor_oper_port_state |=
+ 				    AD_STATE_SYNCHRONIZATION;
+ 			}
++
++			/* QCA NSS ECM support - Start */
++			/* Send a notificaton about change in state of this
++			 * port. We only want to handle case where port moves
++			 * from AD_MUX_COLLECTING_DISTRIBUTING ->
++			 * AD_MUX_ATTACHED.
++			 */
++			if (bond_slave_is_up(port->slave) &&
++			    (last_state == AD_MUX_COLLECTING_DISTRIBUTING)) {
++				struct bond_cb *lag_cb_main;
++
++				rcu_read_lock();
++				lag_cb_main = rcu_dereference(bond_cb);
++				if (lag_cb_main &&
++				    lag_cb_main->bond_cb_link_down) {
++					struct net_device *dev;
++
++					dev = port->slave->dev;
++					lag_cb_main->bond_cb_link_down(dev);
++				}
++				rcu_read_unlock();
++			}
++			/* QCA NSS ECM support - End */
+ 			break;
+ 		case AD_MUX_COLLECTING_DISTRIBUTING:
+ 			if (!(port->sm_vars & AD_PORT_SELECTED) ||
+@@ -1895,6 +1951,8 @@ static void ad_enable_collecting_distrib
+ 					      bool *update_slave_arr)
+ {
+ 	if (port->aggregator->is_active) {
++		struct bond_cb *lag_cb_main; /* QCA NSS ECM support */
++
+ 		slave_dbg(port->slave->bond->dev, port->slave->dev,
+ 			  "Enabling port %d (LAG %d)\n",
+ 			  port->actor_port_number,
+@@ -1902,6 +1960,16 @@ static void ad_enable_collecting_distrib
+ 		__enable_port(port);
+ 		/* Slave array needs update */
+ 		*update_slave_arr = true;
++
++		/* QCA NSS ECM support - Start */
++		rcu_read_lock();
++		lag_cb_main = rcu_dereference(bond_cb);
++
++		if (lag_cb_main && lag_cb_main->bond_cb_link_up)
++			lag_cb_main->bond_cb_link_up(port->slave->dev);
++
++		rcu_read_unlock();
++		/* QCA NSS ECM support - End */
+ 	}
+ }
+ 
+@@ -2759,3 +2827,101 @@ int bond_3ad_stats_fill(struct sk_buff *
+ 
+ 	return 0;
+ }
++
++/* QCA NSS ECM support - Start */
++/* bond_3ad_get_tx_dev - Calculate egress interface for a given packet,
++ * for a LAG that is configured in 802.3AD mode
++ * @skb: pointer to skb to be egressed
++ * @src_mac: pointer to source L2 address
++ * @dst_mac: pointer to destination L2 address
++ * @src: pointer to source L3 address
++ * @dst: pointer to destination L3 address
++ * @protocol: L3 protocol id from L2 header
++ * @bond_dev: pointer to bond master device
++ *
++ * If @skb is NULL, bond_xmit_hash is used to calculate hash using L2/L3
++ * addresses.
++ *
++ * Returns: Either valid slave device, or NULL otherwise
++ */
++struct net_device *bond_3ad_get_tx_dev(struct sk_buff *skb, u8 *src_mac,
++				       u8 *dst_mac, void *src,
++				       void *dst, u16 protocol,
++				       struct net_device *bond_dev,
++				       __be16 *layer4hdr)
++{
++	struct bonding *bond = netdev_priv(bond_dev);
++	struct aggregator *agg;
++	struct ad_info ad_info;
++	struct list_head *iter;
++	struct slave *slave;
++	struct slave *first_ok_slave = NULL;
++	u32 hash = 0;
++	int slaves_in_agg;
++	int slave_agg_no = 0;
++	int agg_id;
++
++	if (__bond_3ad_get_active_agg_info(bond, &ad_info)) {
++		pr_debug("%s: Error: __bond_3ad_get_active_agg_info failed\n",
++			 bond_dev->name);
++		return NULL;
++	}
++
++	slaves_in_agg = ad_info.ports;
++	agg_id = ad_info.aggregator_id;
++
++	if (slaves_in_agg == 0) {
++		pr_debug("%s: Error: active aggregator is empty\n",
++			 bond_dev->name);
++		return NULL;
++	}
++
++	if (skb) {
++		hash = bond_xmit_hash(bond, skb);
++		slave_agg_no = hash % slaves_in_agg;
++	} else {
++		if (bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER23 &&
++		    bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER2 &&
++		    bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER34) {
++			pr_debug("%s: Error: Unsupported hash policy for 802.3AD fast path\n",
++				 bond_dev->name);
++			return NULL;
++		}
++
++		hash = bond_xmit_hash_without_skb(src_mac, dst_mac,
++						  src, dst, protocol,
++						  bond_dev, layer4hdr);
++		slave_agg_no = hash % slaves_in_agg;
++	}
++
++	bond_for_each_slave_rcu(bond, slave, iter) {
++		agg = SLAVE_AD_INFO(slave)->port.aggregator;
++		if (!agg || agg->aggregator_identifier != agg_id)
++			continue;
++
++		if (slave_agg_no >= 0) {
++			if (!first_ok_slave && bond_slave_can_tx(slave))
++				first_ok_slave = slave;
++			slave_agg_no--;
++			continue;
++		}
++
++		if (bond_slave_can_tx(slave))
++			return slave->dev;
++	}
++
++	if (slave_agg_no >= 0) {
++		pr_err("%s: Error: Couldn't find a slave to tx on for aggregator ID %d\n",
++		       bond_dev->name, agg_id);
++		return NULL;
++	}
++
++	/* we couldn't find any suitable slave after the agg_no, so use the
++	 * first suitable found, if found.
++	 */
++	if (first_ok_slave)
++		return first_ok_slave->dev;
++
++	return NULL;
++}
++/* QCA NSS ECM support - End */
+--- a/drivers/net/bonding/bond_main.c
++++ b/drivers/net/bonding/bond_main.c
+@@ -199,6 +199,7 @@ atomic_t netpoll_block_tx = ATOMIC_INIT(
+ #endif
+
+ unsigned int bond_net_id __read_mostly;
++static unsigned long bond_id_mask = 0xFFFFFFF0; /* QCA NSS ECM Support */
+
+ /*-------------------------- Forward declarations ---------------------------*/
+
+@@ -847,6 +847,23 @@ void bond_change_active_slave(struct bon
+ 			if (BOND_MODE(bond) == BOND_MODE_8023AD)
+ 				bond_3ad_handle_link_change(new_active, BOND_LINK_UP);
+ 
++			/* QCA NSS ECM support - Start */
++			if (bond->params.mode == BOND_MODE_XOR) {
++				struct bond_cb *lag_cb_main;
++
++				rcu_read_lock();
++				lag_cb_main = rcu_dereference(bond_cb);
++				if (lag_cb_main &&
++				    lag_cb_main->bond_cb_link_up) {
++					struct net_device *dev;
++
++					dev = new_active->dev;
++					lag_cb_main->bond_cb_link_up(dev);
++				}
++				rcu_read_unlock();
++			}
++			/* QCA NSS ECM support - End */
++
+ 			if (bond_is_lb(bond))
+ 				bond_alb_handle_link_change(bond, new_active, BOND_LINK_UP);
+ 		} else {
+@@ -1379,6 +1396,7 @@ int bond_enslave(struct net_device *bond
+ 	const struct net_device_ops *slave_ops = slave_dev->netdev_ops;
+ 	struct slave *new_slave = NULL, *prev_slave;
+ 	struct sockaddr_storage ss;
++	struct bond_cb *lag_cb_main; /* QCA NSS ECM support */
+ 	int link_reporting;
+ 	int res = 0, i;
+ 
+@@ -1780,6 +1798,13 @@ int bond_enslave(struct net_device *bond
+ 	if (bond_mode_can_use_xmit_hash(bond))
+ 		bond_update_slave_arr(bond, NULL);
+ 
++	/* QCA NSS ECM support - Start */
++	rcu_read_lock();
++	lag_cb_main = rcu_dereference(bond_cb);
++	if (lag_cb_main && lag_cb_main->bond_cb_enslave)
++		lag_cb_main->bond_cb_enslave(slave_dev);
++	rcu_read_unlock();
++	/* QCA NSS ECM support - End */
+ 
+ 	slave_info(bond_dev, slave_dev, "Enslaving as %s interface with %s link\n",
+ 		   bond_is_active_slave(new_slave) ? "an active" : "a backup",
+@@ -1852,6 +1877,14 @@ err_undo_flags:
+ 		}
+ 	}
+ 
++	/* QCA NSS ECM support - Start */
++	rcu_read_lock();
++	lag_cb_main = rcu_dereference(bond_cb);
++	if (lag_cb_main && lag_cb_main->bond_cb_enslave)
++		lag_cb_main->bond_cb_enslave(slave_dev);
++	rcu_read_unlock();
++	/* QCA NSS ECM support - End */
++
+ 	return res;
+ }
+ 
+@@ -1873,6 +1906,7 @@ static int __bond_release_one(struct net
+ 	struct bonding *bond = netdev_priv(bond_dev);
+ 	struct slave *slave, *oldcurrent;
+ 	struct sockaddr_storage ss;
++	struct bond_cb *lag_cb_main; /* QCA NSS ECM support */
+ 	int old_flags = bond_dev->flags;
+ 	netdev_features_t old_features = bond_dev->features;
+ 
+@@ -1895,6 +1929,14 @@ static int __bond_release_one(struct net
+ 
+ 	bond_set_slave_inactive_flags(slave, BOND_SLAVE_NOTIFY_NOW);
+ 
++	/* QCA NSS ECM support - Start */
++	rcu_read_lock();
++	lag_cb_main = rcu_dereference(bond_cb);
++	if (lag_cb_main && lag_cb_main->bond_cb_release)
++		lag_cb_main->bond_cb_release(slave_dev);
++	rcu_read_unlock();
++	/* QCA NSS ECM support - End */
++
+ 	bond_sysfs_slave_del(slave);
+ 
+ 	/* recompute stats just before removing the slave */
+@@ -2190,6 +2232,10 @@ static void bond_miimon_commit(struct bo
+ {
+ 	struct list_head *iter;
+ 	struct slave *slave, *primary;
++	/* QCA NSS ECM support - Start */
++	struct net_device *slave_dev = NULL;
++	struct bond_cb *lag_cb_main;
++	/* QCA NSS ECM support - End */
+ 
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		switch (slave->link_new_state) {
+@@ -2233,6 +2279,12 @@ static void bond_miimon_commit(struct bo
+ 
+ 			bond_miimon_link_change(bond, slave, BOND_LINK_UP);
+ 
++			/* QCA NSS ECM support - Start */
++			if ((bond->params.mode == BOND_MODE_XOR) &&
++			    (!slave_dev))
++				slave_dev = slave->dev;
++			/* QCA NSS ECM support - End */
++
+ 			if (!bond->curr_active_slave || slave == primary)
+ 				goto do_failover;
+ 
+@@ -2274,6 +2326,15 @@ do_failover:
+ 	}
+ 
+ 	bond_set_carrier(bond);
++
++	/* QCA NSS ECM support - Start */
++	rcu_read_lock();
++	lag_cb_main = rcu_dereference(bond_cb);
++
++	if (slave_dev && lag_cb_main && lag_cb_main->bond_cb_link_up)
++		lag_cb_main->bond_cb_link_up(slave_dev);
++	rcu_read_unlock();
++	/* QCA NSS ECM support - End */
+ }
+ 
+ /* bond_mii_monitor
+@@ -4327,6 +4389,11 @@ static void bond_destructor(struct net_d
+ 	struct bonding *bond = netdev_priv(bond_dev);
+ 	if (bond->wq)
+ 		destroy_workqueue(bond->wq);
++
++	/* QCA NSS ECM Support - Start */
++	if (bond->id != (~0U))
++		clear_bit(bond->id, &bond_id_mask);
++	/* QCA NSS ECM Support - End */
+ }
+ 
+ void bond_setup(struct net_device *bond_dev)
+@@ -4872,6 +4939,16 @@ int bond_create(struct net *net, const c
+ 	bond_work_init_all(bond);
+ 
+ 	rtnl_unlock();
++
++	/* QCA NSS ECM Support - Start */
++	bond = netdev_priv(bond_dev);
++	bond->id = ~0U;
++	if (bond_id_mask != (~0UL)) {
++		bond->id = (u32)ffz(bond_id_mask);
++		set_bit(bond->id, &bond_id_mask);
++	}
++	/* QCA NSS ECM Support - End */
++
+ 	return 0;
+ }
+ 
+@@ -4967,6 +5028,203 @@ static void __exit bonding_exit(void)
+ #endif
+ }
+ 
++/* QCA NSS ECM support - Start */
++static bool bond_flow_dissect_without_skb(struct bonding *bond,
++					  u8 *src_mac, u8 *dst_mac,
++					  void *psrc, void *pdst,
++					  u16 protocol, __be16 *layer4hdr,
++					  struct flow_keys *fk)
++{
++	u32 *src = NULL;
++	u32 *dst = NULL;
++
++	fk->ports.ports = 0;
++	src = (uint32_t *)psrc;
++	dst = (uint32_t *)pdst;
++
++	if (protocol == htons(ETH_P_IP)) {
++		/* V4 addresses and address type*/
++		fk->addrs.v4addrs.src = src[0];
++		fk->addrs.v4addrs.dst = dst[0];
++		fk->control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
++	} else if (protocol == htons(ETH_P_IPV6)) {
++		/* V6 addresses and address type*/
++		memcpy(&fk->addrs.v6addrs.src, src, sizeof(struct in6_addr));
++		memcpy(&fk->addrs.v6addrs.dst, dst, sizeof(struct in6_addr));
++		fk->control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
++	} else {
++		return false;
++	}
++	if ((bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER34) &&
++	    (layer4hdr))
++		fk->ports.ports = *layer4hdr;
++
++	return true;
++}
++
++/* Extract the appropriate headers based on bond's xmit policy */
++
++/* bond_xmit_hash_without_skb - Applies load balancing algorithm for a packet,
++ * to calculate hash for a given set of L2/L3 addresses. Does not
++ * calculate egress interface.
++ */
++uint32_t bond_xmit_hash_without_skb(u8 *src_mac, u8 *dst_mac,
++				    void *psrc, void *pdst, u16 protocol,
++				    struct net_device *bond_dev,
++				    __be16 *layer4hdr)
++{
++	struct bonding *bond = netdev_priv(bond_dev);
++	struct flow_keys flow;
++	u32 hash = 0;
++
++	if (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER2 ||
++	    !bond_flow_dissect_without_skb(bond, src_mac, dst_mac, psrc,
++					   pdst, protocol, layer4hdr, &flow))
++		return (dst_mac[5] ^ src_mac[5]);
++
++	if (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER23)
++		hash = dst_mac[5] ^ src_mac[5];
++	else if (layer4hdr)
++		hash = (__force u32)flow.ports.ports;
++
++	hash ^= (__force u32)flow_get_u32_dst(&flow) ^
++		(__force u32)flow_get_u32_src(&flow);
++	hash ^= (hash >> 16);
++	hash ^= (hash >> 8);
++
++	return hash;
++}
++
++/* bond_xor_get_tx_dev - Calculate egress interface for a given packet for a LAG
++ * that is configured in balance-xor mode
++ * @skb: pointer to skb to be egressed
++ * @src_mac: pointer to source L2 address
++ * @dst_mac: pointer to destination L2 address
++ * @src: pointer to source L3 address in network order
++ * @dst: pointer to destination L3 address in network order
++ * @protocol: L3 protocol
++ * @bond_dev: pointer to bond master device
++ *
++ * If @skb is NULL, bond_xmit_hash_without_skb is used to calculate hash using
++ * L2/L3 addresses.
++ *
++ * Returns: Either valid slave device, or NULL otherwise
++ */
++static struct net_device *bond_xor_get_tx_dev(struct sk_buff *skb,
++					      u8 *src_mac, u8 *dst_mac,
++					      void *src, void *dst,
++					      u16 protocol,
++					      struct net_device *bond_dev,
++					      __be16 *layer4hdr)
++{
++	struct bonding *bond = netdev_priv(bond_dev);
++	int slave_cnt = READ_ONCE(bond->slave_cnt);
++	int slave_id = 0, i = 0;
++	u32 hash;
++	struct list_head *iter;
++	struct slave *slave;
++
++	if (slave_cnt == 0) {
++		pr_debug("%s: Error: No slave is attached to the interface\n",
++			 bond_dev->name);
++		return NULL;
++	}
++
++	if (skb) {
++		hash = bond_xmit_hash(bond, skb);
++		slave_id = hash % slave_cnt;
++	} else {
++		if (bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER23 &&
++		    bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER2	&&
++		    bond->params.xmit_policy != BOND_XMIT_POLICY_LAYER34) {
++			pr_debug("%s: Error: Unsupported hash policy for balance-XOR fast path\n",
++				 bond_dev->name);
++			return NULL;
++		}
++
++		hash = bond_xmit_hash_without_skb(src_mac, dst_mac, src,
++						  dst, protocol, bond_dev,
++						  layer4hdr);
++		slave_id = hash % slave_cnt;
++	}
++
++	i = slave_id;
++
++	/* Here we start from the slave with slave_id */
++	bond_for_each_slave_rcu(bond, slave, iter) {
++		if (--i < 0) {
++			if (bond_slave_can_tx(slave))
++				return slave->dev;
++		}
++	}
++
++	/* Here we start from the first slave up to slave_id */
++	i = slave_id;
++	bond_for_each_slave_rcu(bond, slave, iter) {
++		if (--i < 0)
++			break;
++		if (bond_slave_can_tx(slave))
++			return slave->dev;
++	}
++
++	return NULL;
++}
++
++/* bond_get_tx_dev - Calculate egress interface for a given packet.
++ *
++ * Supports 802.3AD and balance-xor modes
++ *
++ * @skb: pointer to skb to be egressed, if valid
++ * @src_mac: pointer to source L2 address
++ * @dst_mac: pointer to destination L2 address
++ * @src: pointer to source L3 address in network order
++ * @dst: pointer to destination L3 address in network order
++ * @protocol: L3 protocol id from L2 header
++ * @bond_dev: pointer to bond master device
++ *
++ * Returns: Either valid slave device, or NULL for un-supported LAG modes
++ */
++struct net_device *bond_get_tx_dev(struct sk_buff *skb, uint8_t *src_mac,
++				   u8 *dst_mac, void *src,
++				   void *dst, u16 protocol,
++				   struct net_device *bond_dev,
++				   __be16 *layer4hdr)
++{
++	struct bonding *bond = netdev_priv(bond_dev);
++
++	if (!bond)
++		return NULL;
++
++	switch (bond->params.mode) {
++	case BOND_MODE_XOR:
++		return bond_xor_get_tx_dev(skb, src_mac, dst_mac,
++					   src, dst, protocol,
++					   bond_dev, layer4hdr);
++	case BOND_MODE_8023AD:
++		return bond_3ad_get_tx_dev(skb, src_mac, dst_mac,
++					   src, dst, protocol,
++					   bond_dev, layer4hdr);
++	default:
++		return NULL;
++	}
++}
++EXPORT_SYMBOL(bond_get_tx_dev);
++
++int bond_get_id(struct net_device *bond_dev)
++{
++	struct bonding *bond;
++
++	if (!((bond_dev->priv_flags & IFF_BONDING) &&
++	      (bond_dev->flags & IFF_MASTER)))
++		return -EINVAL;
++
++	bond = netdev_priv(bond_dev);
++
++	return bond->id;
++}
++EXPORT_SYMBOL(bond_get_id);
++/* QCA NSS ECM support - End */
++
+ module_init(bonding_init);
+ module_exit(bonding_exit);
+ MODULE_LICENSE("GPL");
+--- a/net/8021q/vlan_core.c
++++ b/net/8021q/vlan_core.c
+@@ -551,4 +551,52 @@ static int __init vlan_offload_init(void
+ 	return 0;
+ }
+ 
++/* QCA NSS ECM support - Start */
++/* Update the VLAN device with statistics from network offload engines */
++void __vlan_dev_update_accel_stats(struct net_device *dev,
++				   struct rtnl_link_stats64 *nlstats)
++{
++	struct vlan_pcpu_stats *stats;
++
++	if (!is_vlan_dev(dev))
++		return;
++
++	stats = per_cpu_ptr(vlan_dev_priv(dev)->vlan_pcpu_stats, 0);
++
++	u64_stats_update_begin(&stats->syncp);
++	stats->rx_packets += nlstats->rx_packets;
++	stats->rx_bytes += nlstats->rx_bytes;
++	stats->tx_packets += nlstats->tx_packets;
++	stats->tx_bytes += nlstats->tx_bytes;
++	u64_stats_update_end(&stats->syncp);
++}
++EXPORT_SYMBOL(__vlan_dev_update_accel_stats);
++
++/* Lookup the 802.1p egress_map table and return the 802.1p value */
++u16 vlan_dev_get_egress_prio(struct net_device *dev, u32 skb_prio)
++{
++	struct vlan_priority_tci_mapping *mp;
++
++	mp = vlan_dev_priv(dev)->egress_priority_map[(skb_prio & 0xf)];
++	while (mp) {
++		if (mp->priority == skb_prio) {
++			/* This should already be shifted
++			 * to mask correctly with the
++			 * VLAN's TCI
++			 */
++			return mp->vlan_qos;
++		}
++		mp = mp->next;
++	}
++	return 0;
++}
++EXPORT_SYMBOL(vlan_dev_get_egress_prio);
++
++struct net_device *vlan_dev_next_dev(const struct net_device *dev)
++{
++	return vlan_dev_priv(dev)->real_dev;
++}
++EXPORT_SYMBOL(vlan_dev_next_dev);
++/* QCA NSS ECM support - End */
++
+ fs_initcall(vlan_offload_init);
+--- a/net/bridge/br_fdb.c
++++ b/net/bridge/br_fdb.c
+@@ -37,6 +37,35 @@ static int fdb_insert(struct net_bridge
+ static void fdb_notify(struct net_bridge *br,
+ 		       const struct net_bridge_fdb_entry *, int, bool);
+ 
++/* QCA NSS ECM support - Start */
++ATOMIC_NOTIFIER_HEAD(br_fdb_notifier_list);
++ATOMIC_NOTIFIER_HEAD(br_fdb_update_notifier_list);
++
++void br_fdb_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&br_fdb_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_register_notify);
++
++void br_fdb_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&br_fdb_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_unregister_notify);
++
++void br_fdb_update_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&br_fdb_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_update_register_notify);
++
++void br_fdb_update_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&br_fdb_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(br_fdb_update_unregister_notify);
++/* QCA NSS ECM support - End */
++
+ int __init br_fdb_init(void)
+ {
+ 	br_fdb_cache = kmem_cache_create("bridge_fdb_cache",
+@@ -337,6 +366,7 @@ void br_fdb_cleanup(struct work_struct *
+ 	unsigned long delay = hold_time(br);
+ 	unsigned long work_delay = delay;
+ 	unsigned long now = jiffies;
++	u8 mac_addr[6]; /* QCA NSS ECM support */
+ 
+ 	/* this part is tricky, in order to avoid blocking learning and
+ 	 * consequently forwarding, we rely on rcu to delete objects with
+@@ -353,8 +383,15 @@ void br_fdb_cleanup(struct work_struct *
+ 			work_delay = min(work_delay, this_timer - now);
+ 		} else {
+ 			spin_lock_bh(&br->hash_lock);
+-			if (!hlist_unhashed(&f->fdb_node))
++			if (!hlist_unhashed(&f->fdb_node)) {
++				ether_addr_copy(mac_addr, f->key.addr.addr);
+ 				fdb_delete(br, f, true);
++				/* QCA NSS ECM support - Start */
++				atomic_notifier_call_chain(
++					&br_fdb_update_notifier_list, 0,
++					(void *)mac_addr);
++				/* QCA NSS ECM support - End */
++			}
+ 			spin_unlock_bh(&br->hash_lock);
+ 		}
+ 	}
+@@ -586,6 +623,12 @@ void br_fdb_update(struct net_bridge *br
+ 				/* Take over HW learned entry */
+ 				if (unlikely(fdb->added_by_external_learn))
+ 					fdb->added_by_external_learn = 0;
++
++				/* QCA NSS ECM support - Start */
++				atomic_notifier_call_chain(
++					&br_fdb_update_notifier_list,
++					0, (void *)addr);
++				/* QCA NSS ECM support - End */
+ 			}
+ 			if (now != fdb->updated)
+ 				fdb->updated = now;
+@@ -695,6 +738,25 @@ static void fdb_notify(struct net_bridge
+ 	struct sk_buff *skb;
+ 	int err = -ENOBUFS;
+ 
++	/* QCA NSS ECM support - Start */
++	if (fdb->dst) {
++		int event;
++		struct br_fdb_event fdb_event;
++
++		if (type == RTM_NEWNEIGH)
++			event = BR_FDB_EVENT_ADD;
++		else
++			event = BR_FDB_EVENT_DEL;
++
++		fdb_event.dev = fdb->dst->dev;
++		ether_addr_copy(fdb_event.addr, fdb->key.addr.addr);
++		fdb_event.is_local = fdb->is_local;
++		atomic_notifier_call_chain(&br_fdb_notifier_list,
++					   event,
++					   (void *)&fdb_event);
++	}
++	/* QCA NSS ECM support - End */
++
+ 	if (swdev_notify)
+ 		br_switchdev_fdb_notify(fdb, type);
+ 
+@@ -1211,3 +1273,44 @@ void br_fdb_clear_offload(const struct n
+ 	spin_unlock_bh(&p->br->hash_lock);
+ }
+ EXPORT_SYMBOL_GPL(br_fdb_clear_offload);
++
++/* QCA NSS ECM support - Start */
++/* Refresh FDB entries for bridge packets being forwarded by offload engines */
++void br_refresh_fdb_entry(struct net_device *dev, const char *addr)
++{
++	struct net_bridge_port *p = br_port_get_rcu(dev);
++
++	if (!p || p->state == BR_STATE_DISABLED)
++		return;
++
++	if (!is_valid_ether_addr(addr)) {
++		pr_info("bridge: Attempt to refresh with invalid ether address %pM\n",
++			addr);
++		return;
++	}
++
++	rcu_read_lock();
++	br_fdb_update(p->br, p, addr, 0, true);
++	rcu_read_unlock();
++}
++EXPORT_SYMBOL_GPL(br_refresh_fdb_entry);
++
++/* Look up the MAC address in the device's bridge fdb table */
++struct net_bridge_fdb_entry *br_fdb_has_entry(struct net_device *dev,
++					      const char *addr, __u16 vid)
++{
++	struct net_bridge_port *p = br_port_get_rcu(dev);
++	struct net_bridge_fdb_entry *fdb;
++
++	if (!p || p->state == BR_STATE_DISABLED)
++		return NULL;
++
++	rcu_read_lock();
++	fdb = fdb_find_rcu(&p->br->fdb_hash_tbl, addr, vid);
++	rcu_read_unlock();
++
++	return fdb;
++}
++EXPORT_SYMBOL_GPL(br_fdb_has_entry);
++/* QCA NSS ECM support - End */
++
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -26,6 +26,12 @@
+ 
+ #include "br_private.h"
+ 
++/* QCA NSS ECM support - Start */
++/* Hook for external forwarding logic */
++br_port_dev_get_hook_t __rcu *br_port_dev_get_hook __read_mostly;
++EXPORT_SYMBOL_GPL(br_port_dev_get_hook);
++/* QCA NSS ECM support - End */
++
+ /*
+  * Determine initial path cost based on speed.
+  * using recommendations from 802.1d standard
+@@ -681,6 +687,8 @@ int br_add_if(struct net_bridge *br, str
+ 
+ 	kobject_uevent(&p->kobj, KOBJ_ADD);
+ 
++	call_netdevice_notifiers(NETDEV_BR_JOIN, dev); /* QCA NSS ECM support */
++
+ 	return 0;
+ 
+ err7:
+@@ -714,6 +722,8 @@ int br_del_if(struct net_bridge *br, str
+ 	if (!p || p->br != br)
+ 		return -EINVAL;
+ 
++	call_netdevice_notifiers(NETDEV_BR_LEAVE, dev); /* QCA NSS ECM support */
++
+ 	/* Since more than one interface can be attached to a bridge,
+ 	 * there still maybe an alternate path for netconsole to use;
+ 	 * therefore there is no reason for a NETDEV_RELEASE event.
+@@ -780,3 +790,64 @@ void br_dev_update_stats(struct net_devi
+ 	u64_stats_update_end(&stats->syncp);
+ }
+ EXPORT_SYMBOL_GPL(br_dev_update_stats);
++
++/* QCA NSS ECM support - Start */
++/* br_port_dev_get()
++ *      If a skb is provided, and the br_port_dev_get_hook_t hook exists,
++ *      use that to try and determine the egress port for that skb.
++ *      If not, or no egress port could be determined, use the given addr
++ *      to identify the port to which it is reachable,
++ *	returing a reference to the net device associated with that port.
++ *
++ * NOTE: Return NULL if given dev is not a bridge or the mac has no
++ * associated port.
++ */
++struct net_device *br_port_dev_get(struct net_device *dev, unsigned char *addr,
++				   struct sk_buff *skb,
++				   unsigned int cookie)
++{
++	struct net_bridge_fdb_entry *fdbe;
++	struct net_bridge *br;
++	struct net_device *netdev = NULL;
++
++	/* Is this a bridge? */
++	if (!(dev->priv_flags & IFF_EBRIDGE))
++		return NULL;
++
++	rcu_read_lock();
++
++	/* If the hook exists and the skb isn't NULL, try and get the port */
++	if (skb) {
++		br_port_dev_get_hook_t *port_dev_get_hook;
++
++		port_dev_get_hook = rcu_dereference(br_port_dev_get_hook);
++		if (port_dev_get_hook) {
++			struct net_bridge_port *pdst =
++				__br_get(port_dev_get_hook, NULL, dev, skb,
++					 addr, cookie);
++			if (pdst) {
++				dev_hold(pdst->dev);
++				netdev = pdst->dev;
++				goto out;
++			}
++		}
++	}
++
++	/* Either there is no hook, or can't
++	 * determine the port to use - fall back to using FDB
++	 */
++
++	br = netdev_priv(dev);
++
++	/* Lookup the fdb entry and get reference to the port dev */
++	fdbe = br_fdb_find_rcu(br, addr, 0);
++	if (fdbe && fdbe->dst) {
++		netdev = fdbe->dst->dev; /* port device */
++		dev_hold(netdev);
++	}
++out:
++	rcu_read_unlock();
++	return netdev;
++}
++EXPORT_SYMBOL_GPL(br_port_dev_get);
++/* QCA NSS ECM support - End */
+--- a/net/bridge/br_private.h
++++ b/net/bridge/br_private.h
+@@ -1258,4 +1258,9 @@ void br_do_proxy_suppress_arp(struct sk_
+ void br_do_suppress_nd(struct sk_buff *skb, struct net_bridge *br,
+ 		       u16 vid, struct net_bridge_port *p, struct nd_msg *msg);
+ struct nd_msg *br_is_nd_neigh_msg(struct sk_buff *skb, struct nd_msg *m);
++
++/* QCA NSS ECM support - Start */
++#define __br_get(__hook, __default, __args ...) \
++		(__hook ? (__hook(__args)) : (__default))
++/* QCA NSS ECM support - End */
+ #endif
+--- a/net/core/neighbour.c
++++ b/net/core/neighbour.c
+@@ -1202,7 +1202,21 @@ static void neigh_update_hhs(struct neig
+ 	}
+ }
+ 
++/* QCA NSS ECM support - start */
++ATOMIC_NOTIFIER_HEAD(neigh_mac_update_notifier_list);
++ 
++void neigh_mac_update_register_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_register(&neigh_mac_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(neigh_mac_update_register_notify);
+ 
++void neigh_mac_update_unregister_notify(struct notifier_block *nb)
++{
++	atomic_notifier_chain_unregister(&neigh_mac_update_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(neigh_mac_update_unregister_notify);
++/* QCA NSS ECM support - End */
+ 
+ /* Generic update routine.
+    -- lladdr is new lladdr or NULL, if it is not supplied.
+@@ -1233,6 +1247,7 @@ static int __neigh_update(struct neighbo
+ 	int notify = 0;
+ 	struct net_device *dev;
+ 	int update_isrouter = 0;
++	struct neigh_mac_update nmu; /* QCA NSS ECM support */
+ 
+ 	trace_neigh_update(neigh, lladdr, new, flags, nlmsg_pid);
+ 
+@@ -1259,6 +1259,8 @@ static int __neigh_update(struct neighbo
+ 	old    = neigh->nud_state;
+ 	err    = -EPERM;
+ 
++	memset(&nmu, 0, sizeof(struct neigh_mac_update)); /* QCA NSS ECM support */
++
+ 	if (neigh->dead) {
+ 		NL_SET_ERR_MSG(extack, "Neighbor entry is now dead");
+ 		new = old;
+@@ -1277,6 +1294,11 @@ static int __neigh_update(struct neighbo
+ 		   - compare new & old
+ 		   - if they are different, check override flag
+ 		 */
++		/* QCA NSS ECM update - Start */
++		memcpy(nmu.old_mac, neigh->ha, dev->addr_len);
++		memcpy(nmu.update_mac, lladdr, dev->addr_len);
++		/* QCA NSS ECM update - End */
++
+ 		if ((old & NUD_VALID) &&
+ 		    !memcmp(lladdr, neigh->ha, dev->addr_len))
+ 			lladdr = neigh->ha;
+@@ -1399,8 +1421,11 @@ out:
+ 	if (((new ^ old) & NUD_PERMANENT) || ext_learn_change)
+ 		neigh_update_gc_list(neigh);
+ 
+-	if (notify)
++	if (notify) {
+ 		neigh_update_notify(neigh, nlmsg_pid);
++		atomic_notifier_call_chain(&neigh_mac_update_notifier_list, 0,
++					   (struct neigh_mac_update *)&nmu); /* QCA NSS ECM support */
++	}
+ 
+ 	trace_neigh_update_done(neigh, err);
+ 
+--- a/net/ipv4/fib_trie.c
++++ b/net/ipv4/fib_trie.c
+@@ -1116,6 +1116,9 @@ static bool fib_valid_key_len(u32 key, u
+ 	return true;
+ }
+ 
++/* Define route change notification chain. */
++static BLOCKING_NOTIFIER_HEAD(iproute_chain);	/* QCA NSS ECM support */
++
+ /* Caller must hold RTNL. */
+ int fib_table_insert(struct net *net, struct fib_table *tb,
+ 		     struct fib_config *cfg, struct netlink_ext_ack *extack)
+@@ -1283,6 +1286,9 @@ int fib_table_insert(struct net *net, st
+ 	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, new_fa->tb_id,
+ 		  &cfg->fc_nlinfo, nlflags);
+ succeeded:
++	blocking_notifier_call_chain(&iproute_chain,
++				     RTM_NEWROUTE, fi);
++
+ 	return 0;
+ 
+ out_fib_notif:
+@@ -1609,6 +1615,9 @@ int fib_table_delete(struct net *net, st
+ 	if (fa_to_delete->fa_state & FA_S_ACCESSED)
+ 		rt_cache_flush(cfg->fc_nlinfo.nl_net);
+ 
++	blocking_notifier_call_chain(&iproute_chain,
++				     RTM_DELROUTE, fa_to_delete->fa_info);
++
+ 	fib_release_info(fa_to_delete->fa_info);
+ 	alias_free_mem_rcu(fa_to_delete);
+ 	return 0;
+@@ -2219,6 +2228,20 @@ void __init fib_trie_init(void)
+ 					   0, SLAB_PANIC, NULL);
+ }
+ 
++/* QCA NSS ECM support - Start */
++int ip_rt_register_notifier(struct notifier_block *nb)
++{
++	return blocking_notifier_chain_register(&iproute_chain, nb);
++}
++EXPORT_SYMBOL(ip_rt_register_notifier);
++
++int ip_rt_unregister_notifier(struct notifier_block *nb)
++{
++	return blocking_notifier_chain_unregister(&iproute_chain, nb);
++}
++EXPORT_SYMBOL(ip_rt_unregister_notifier);
++/* QCA NSS ECM support - End */
++
+ struct fib_table *fib_trie_table(u32 id, struct fib_table *alias)
+ {
+ 	struct fib_table *tb;
+--- a/net/ipv6/addrconf.c
++++ b/net/ipv6/addrconf.c
+@@ -7173,3 +7173,35 @@ void addrconf_cleanup(void)
+ 
+ 	destroy_workqueue(addrconf_wq);
+ }
++
++/* QCA NSS ECM support - Start */
++/* ipv6_dev_find()
++ *	Find (and hold) net device that has the given address.
++ *	Or NULL on failure.
++ */
++struct net_device *ipv6_dev_find(struct net *net, struct in6_addr *addr,
++				 int strict)
++{
++	struct inet6_ifaddr *ifp;
++	struct net_device *dev;
++
++	ifp = ipv6_get_ifaddr(net, addr, NULL, strict);
++	if (!ifp)
++		return NULL;
++
++	if (!ifp->idev) {
++		in6_ifa_put(ifp);
++		return NULL;
++	}
++
++	dev = ifp->idev->dev;
++	if (dev)
++		dev_hold(dev);
++
++	in6_ifa_put(ifp);
++
++	return dev;
++}
++EXPORT_SYMBOL(ipv6_dev_find);
++/* QCA NSS ECM support - End */
++
+--- a/net/ipv6/ndisc.c
++++ b/net/ipv6/ndisc.c
+@@ -646,6 +646,7 @@ void ndisc_send_ns(struct net_device *de
+ 
+ 	ndisc_send_skb(skb, daddr, saddr);
+ }
++EXPORT_SYMBOL(ndisc_send_ns);
+ 
+ void ndisc_send_rs(struct net_device *dev, const struct in6_addr *saddr,
+ 		   const struct in6_addr *daddr)
+--- a/net/ipv6/route.c
++++ b/net/ipv6/route.c
+@@ -3747,6 +3747,9 @@ out:
+ 	return ERR_PTR(err);
+ }
+ 
++/* Define route change notification chain. */
++ATOMIC_NOTIFIER_HEAD(ip6route_chain);	/* QCA NSS ECM support */
++
+ int ip6_route_add(struct fib6_config *cfg, gfp_t gfp_flags,
+ 		  struct netlink_ext_ack *extack)
+ {
+@@ -3758,6 +3761,10 @@ int ip6_route_add(struct fib6_config *cf
+ 		return PTR_ERR(rt);
+ 
+ 	err = __ip6_ins_rt(rt, &cfg->fc_nlinfo, extack);
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   RTM_NEWROUTE, rt);
++
+ 	fib6_info_release(rt);
+ 
+ 	return err;
+@@ -3779,6 +3786,9 @@ static int __ip6_del_rt(struct fib6_info
+ 	err = fib6_del(rt, info);
+ 	spin_unlock_bh(&table->tb6_lock);
+ 
++	if (!err)
++		atomic_notifier_call_chain(&ip6route_chain,
++					   RTM_DELROUTE, rt);
+ out:
+ 	fib6_info_release(rt);
+ 	return err;
+@@ -6068,6 +6078,20 @@ static int ip6_route_dev_notify(struct n
+ 	return NOTIFY_OK;
+ }
+ 
++/* QCA NSS ECM support - Start */
++int rt6_register_notifier(struct notifier_block *nb)
++{
++	return atomic_notifier_chain_register(&ip6route_chain, nb);
++}
++EXPORT_SYMBOL(rt6_register_notifier);
++
++int rt6_unregister_notifier(struct notifier_block *nb)
++{
++	return atomic_notifier_chain_unregister(&ip6route_chain, nb);
++}
++EXPORT_SYMBOL(rt6_unregister_notifier);
++/* QCA NSS ECM support - End */
++
+ /*
+  *	/proc
+  */
+--- a/net/l2tp/l2tp_ppp.c
++++ b/net/l2tp/l2tp_ppp.c
+@@ -92,6 +92,7 @@
+ #include <net/ip.h>
+ #include <net/udp.h>
+ #include <net/inet_common.h>
++#include <linux/if_pppox.h>
+ 
+ #include <asm/byteorder.h>
+ #include <linux/atomic.h>
+@@ -125,9 +126,19 @@ struct pppol2tp_session {
+ 
+ static int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb);
+ 
+-static const struct ppp_channel_ops pppol2tp_chan_ops = {
+-	.start_xmit =  pppol2tp_xmit,
++/* QCA NSS ECM support - Start */
++static int pppol2tp_get_channel_protocol(struct ppp_channel *);
++static int pppol2tp_get_channel_protocol_ver(struct ppp_channel *);
++static void pppol2tp_hold_chan(struct ppp_channel *);
++static void pppol2tp_release_chan(struct ppp_channel *);
++static const struct pppol2tp_channel_ops pppol2tp_chan_ops = {
++	.ops.start_xmit =  pppol2tp_xmit,
++	.ops.get_channel_protocol = pppol2tp_get_channel_protocol,
++	.ops.get_channel_protocol_ver = pppol2tp_get_channel_protocol_ver,
++	.ops.hold = pppol2tp_hold_chan,
++	.ops.release = pppol2tp_release_chan,
+ };
++/* QCA NSS ECM support - End */
+ 
+ static const struct proto_ops pppol2tp_ops;
+ 
+@@ -240,6 +251,7 @@ static void pppol2tp_recv(struct l2tp_se
+ 			 session->name, data_len);
+ 
+ 		po = pppox_sk(sk);
++		skb->skb_iif = ppp_dev_index(&po->chan); /* QCA NSS ECM support */
+ 		ppp_input(&po->chan, skb);
+ 	} else {
+ 		l2tp_dbg(session, L2TP_MSG_DATA,
+@@ -380,6 +392,13 @@ static int pppol2tp_xmit(struct ppp_chan
+ 	skb->data[0] = PPP_ALLSTATIONS;
+ 	skb->data[1] = PPP_UI;
+ 
++	/* QCA NSS ECM support - start */
++	/* set incoming interface as the ppp interface */
++	if ((skb->protocol == htons(ETH_P_IP)) ||
++	    (skb->protocol == htons(ETH_P_IPV6)))
++		skb->skb_iif = ppp_dev_index(chan);
++	/* QCA NSS ECM support - End */
++
+ 	local_bh_disable();
+ 	l2tp_xmit_skb(session, skb, session->hdr_len);
+ 	local_bh_enable();
+@@ -816,7 +835,7 @@ static int pppol2tp_connect(struct socke
+ 	po->chan.hdrlen = PPPOL2TP_L2TP_HDR_SIZE_NOSEQ;
+ 
+ 	po->chan.private = sk;
+-	po->chan.ops	 = &pppol2tp_chan_ops;
++	po->chan.ops	 = &pppol2tp_chan_ops.ops; /* QCA NSS ECM support */
+ 	po->chan.mtu	 = pppol2tp_tunnel_mtu(tunnel);
+ 
+ 	error = ppp_register_net_channel(sock_net(sk), &po->chan);
+@@ -1749,6 +1768,109 @@ static void __exit pppol2tp_exit(void)
+ 	unregister_pernet_device(&pppol2tp_net_ops);
+ }
+ 
++/* QCA NSS ECM support - Start */
++/* pppol2tp_hold_chan() */
++static void pppol2tp_hold_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_hold(sk);
++}
++
++/* pppol2tp_release_chan() */
++static void pppol2tp_release_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_put(sk);
++}
++
++/* pppol2tp_get_channel_protocol()
++ * Return the protocol type of the L2TP over PPP protocol
++ */
++static int pppol2tp_get_channel_protocol(struct ppp_channel *chan)
++{
++	return PX_PROTO_OL2TP;
++}
++
++/* pppol2tp_get_channel_protocol_ver()
++ * Return the protocol version of the L2TP over PPP protocol
++ */
++static int pppol2tp_get_channel_protocol_ver(struct ppp_channel *chan)
++{
++	struct sock *sk;
++	struct l2tp_session *session;
++	struct l2tp_tunnel *tunnel;
++	int version = 0;
++
++	if (chan && chan->private)
++		sk = (struct sock *)chan->private;
++	else
++		return -1;
++
++	/* Get session and tunnel contexts from the socket */
++	session = pppol2tp_sock_to_session(sk);
++	if (!session)
++		return -1;
++
++	tunnel = session->tunnel;
++	if (!tunnel) {
++		sock_put(sk);
++		return -1;
++	}
++
++	version = tunnel->version;
++
++	sock_put(sk);
++
++	return version;
++}
++
++/* pppol2tp_get_addressing() */
++static int pppol2tp_get_addressing(struct ppp_channel *chan,
++				   struct pppol2tp_common_addr *addr)
++{
++	struct sock *sk = (struct sock *)chan->private;
++	struct l2tp_session *session;
++	struct l2tp_tunnel *tunnel;
++	struct inet_sock *isk = NULL;
++	int err = -ENXIO;
++
++	/* Get session and tunnel contexts from the socket */
++	session = pppol2tp_sock_to_session(sk);
++	if (!session)
++		return err;
++
++	tunnel = session->tunnel;
++	if (!tunnel) {
++		sock_put(sk);
++		return err;
++	}
++	isk = inet_sk(tunnel->sock);
++
++	addr->local_tunnel_id = tunnel->tunnel_id;
++	addr->remote_tunnel_id = tunnel->peer_tunnel_id;
++	addr->local_session_id = session->session_id;
++	addr->remote_session_id = session->peer_session_id;
++
++	addr->local_addr.sin_port = isk->inet_sport;
++	addr->remote_addr.sin_port = isk->inet_dport;
++	addr->local_addr.sin_addr.s_addr = isk->inet_saddr;
++	addr->remote_addr.sin_addr.s_addr = isk->inet_daddr;
++
++	sock_put(sk);
++	return 0;
++}
++
++/* pppol2tp_channel_addressing_get() */
++int pppol2tp_channel_addressing_get(struct ppp_channel *chan,
++				    struct pppol2tp_common_addr *addr)
++{
++	return pppol2tp_get_addressing(chan, addr);
++}
++EXPORT_SYMBOL(pppol2tp_channel_addressing_get);
++/* QCA NSS ECM support - End */
++
+ module_init(pppol2tp_init);
+ module_exit(pppol2tp_exit);
+ 
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -158,6 +158,13 @@ config NF_CONNTRACK_TIMEOUT
+ 
+ 	  If unsure, say `N'.
+ 
++config NF_CONNTRACK_DSCPREMARK_EXT
++	bool  'Connection tracking extension for dscp remark target'
++	depends on NETFILTER_ADVANCED
++	help
++	  This option enables support for connection tracking extension
++	  for dscp remark.
++
+ config NF_CONNTRACK_CHAIN_EVENTS
+ 	bool "Register multiple callbacks to ct events"
+ 	depends on NF_CONNTRACK_EVENTS
+--- a/net/netfilter/Makefile
++++ b/net/netfilter/Makefile
+@@ -14,6 +14,7 @@ nf_conntrack-$(CONFIG_NF_CONNTRACK_LABEL
+ nf_conntrack-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
+ nf_conntrack-$(CONFIG_NF_CT_PROTO_SCTP) += nf_conntrack_proto_sctp.o
+ nf_conntrack-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
++nf_conntrack-$(CONFIG_NF_CONNTRACK_DSCPREMARK_EXT) += nf_conntrack_dscpremark_ext.o
+ 
+ obj-$(CONFIG_NETFILTER) = netfilter.o
+ 
diff --git a/target/linux/ipq806x/patches-5.4/999-03b-qca-nss-ecm-support.patch b/target/linux/ipq806x/patches-5.4/999-03b-qca-nss-ecm-support.patch
new file mode 100644
index 0000000000..3fe582c44b
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-03b-qca-nss-ecm-support.patch
@@ -0,0 +1,143 @@
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -173,6 +173,8 @@ struct br_fdb_event {
+ 	struct net_device *dev;
+ 	unsigned char      addr[6];
+ 	unsigned char      is_local;
++	struct net_bridge *br;
++	struct net_device *orig_dev;
+ };
+ extern void br_fdb_register_notify(struct notifier_block *nb);
+ extern void br_fdb_unregister_notify(struct notifier_block *nb);
+--- a/include/linux/netdevice.h
++++ b/include/linux/netdevice.h
+@@ -1587,12 +1587,18 @@ enum netdev_priv_qca_ecm_flags {
+ 	IFF_QCA_ECM_PPP_L2TPV2		= 1<<1,
+ 	IFF_QCA_ECM_PPP_L2TPV3		= 1<<2,
+ 	IFF_QCA_ECM_PPP_PPTP		= 1<<3,
++	IFF_QCA_ECM_GRE_V4_TAP		= 1<<4,
++	IFF_QCA_ECM_GRE_V6_TAP		= 1<<5,
++	IFF_QCA_ECM_IFB			= 1<<6,
+ };
+ 
+ #define IFF_QCA_ECM_TUN_TAP		IFF_QCA_ECM_TUN_TAP
+ #define IFF_QCA_ECM_PPP_L2TPV2		IFF_QCA_ECM_PPP_L2TPV2
+ #define IFF_QCA_ECM_PPP_L2TPV3		IFF_QCA_ECM_PPP_L2TPV3
+ #define IFF_QCA_ECM_PPP_PPTP		IFF_QCA_ECM_PPP_PPTP
++#define IFF_QCA_ECM_GRE_V4_TAP		IFF_QCA_ECM_GRE_V4_TAP
++#define	IFF_QCA_ECM_GRE_V6_TAP		IFF_QCA_ECM_GRE_V6_TAP
++#define	IFF_QCA_ECM_IFB			IFF_QCA_ECM_IFB
+ /* QCA NSS ECM support - End */
+ 
+ /**
+--- a/include/linux/netfilter/nf_conntrack_proto_gre.h
++++ b/include/linux/netfilter/nf_conntrack_proto_gre.h
+@@ -31,4 +31,35 @@ void nf_ct_gre_keymap_destroy(struct nf_
+ 
+ bool gre_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
+ 		      struct net *net, struct nf_conntrack_tuple *tuple);
++
++/* QCA NSS ECM Support - Start */
++/* GRE is a mess: Four different standards */
++struct gre_hdr {
++#if defined(__LITTLE_ENDIAN_BITFIELD)
++	__u16	rec:3,
++		srr:1,
++		seq:1,
++		key:1,
++		routing:1,
++		csum:1,
++		version:3,
++		reserved:4,
++		ack:1;
++#elif defined(__BIG_ENDIAN_BITFIELD)
++	__u16	csum:1,
++		routing:1,
++		key:1,
++		seq:1,
++		srr:1,
++		rec:3,
++		ack:1,
++		reserved:4,
++		version:3;
++#else
++#error "Adjust your <asm/byteorder.h> defines"
++#endif
++	__be16	protocol;
++};
++/* QCA NSS ECM Support - End */
++
+ #endif /* _CONNTRACK_PROTO_GRE_H */
+--- a/include/net/addrconf.h
++++ b/include/net/addrconf.h
+@@ -497,4 +497,9 @@ int if6_proc_init(void);
+ void if6_proc_exit(void);
+ #endif
+ 
++/* QCA NSS ECM support - Start */
++struct net_device *ipv6_dev_find(struct net *net, struct in6_addr *addr,
++				 int strict);
++/* QCA NSS ECM support - End */
++
+ #endif
+--- a/drivers/net/tun.c
++++ b/drivers/net/tun.c
+@@ -2833,6 +2833,8 @@ static int tun_set_iff(struct net *net,
+ 				     ~(NETIF_F_HW_VLAN_CTAG_TX |
+ 				       NETIF_F_HW_VLAN_STAG_TX);
+ 
++		dev->priv_flags_qca_ecm |= IFF_QCA_ECM_TUN_TAP; /* QCA NSS ECM Support */
++
+ 		tun->flags = (tun->flags & ~TUN_FEATURES) |
+ 			      (ifr->ifr_flags & TUN_FEATURES);
+ 
+--- a/net/ipv4/ip_gre.c
++++ b/net/ipv4/ip_gre.c
+@@ -1287,6 +1287,7 @@ static void ipgre_tap_setup(struct net_d
+ 	dev->netdev_ops	= &gre_tap_netdev_ops;
+ 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+ 	dev->priv_flags	|= IFF_LIVE_ADDR_CHANGE;
++	dev->priv_flags_qca_ecm |= IFF_QCA_ECM_GRE_V4_TAP; /* QCA NSS ECM Support */
+ 	ip_tunnel_setup(dev, gre_tap_net_id);
+ }
+ 
+--- a/net/ipv6/ip6_gre.c
++++ b/net/ipv6/ip6_gre.c
+@@ -1895,6 +1895,7 @@ static void ip6gre_tap_setup(struct net_
+ 
+ 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+ 	dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
++	dev->priv_flags_qca_ecm |= IFF_QCA_ECM_GRE_V6_TAP; /* QCA NSS ECM Support */
+ 	netif_keep_dst(dev);
+ }
+ 
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -68,6 +68,7 @@ extern void br_fdb_update_unregister_notify(struct notifier_block *nb);
+ extern void brioctl_set(int (*ioctl_hook)(struct net *, unsigned int, void __user *));
+ extern void br_dev_update_stats(struct net_device *dev,
+ 				struct rtnl_link_stats64 *nlstats);
++extern bool br_is_hairpin_enabled(struct net_device *dev);
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
+ int br_multicast_list_adjacent(struct net_device *dev,
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -684,6 +684,17 @@ void br_dev_update_stats(struct net_device *dev,
+ EXPORT_SYMBOL_GPL(br_dev_update_stats);
+ 
+ /* QCA NSS ECM support - Start */
++/* API to know if hairpin feature is enabled/disabled on this bridge port */
++bool br_is_hairpin_enabled(struct net_device *dev)
++{
++	struct net_bridge_port *port = br_port_get_check_rcu(dev);
++
++	if (likely(port))
++		return port->flags & BR_HAIRPIN_MODE;
++	return false;
++}
++EXPORT_SYMBOL_GPL(br_is_hairpin_enabled);
++
+ /* br_port_dev_get()
+  *      If a skb is provided, and the br_port_dev_get_hook_t hook exists,
+  *      use that to try and determine the egress port for that skb.
diff --git a/target/linux/ipq806x/patches-5.4/999-03c-qca-nss-pppoe-offload-support.patch b/target/linux/ipq806x/patches-5.4/999-03c-qca-nss-pppoe-offload-support.patch
new file mode 100644
index 0000000000..519953118f
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-03c-qca-nss-pppoe-offload-support.patch
@@ -0,0 +1,447 @@
+From 5f3ab2b6d1a6cadc1b7c231cefdf91b14972e436 Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 16 Jan 2015 15:28:47 -0800
+Subject: ppp: PPPoE acceleration support.
+
+Added some new APIs to the PPP/PPPoE kernel modules
+for using from the hardware acceleration connection managers.
+
+Change-Id: I2c16c6d6ccba8ffa14aec077c8dad1681535ae0b
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ drivers/net/ppp/ppp_generic.c | 190 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/net/ppp/pppoe.c       |  79 ++++++++++++++++--
+ include/linux/if_pppox.h      |  16 +++-
+ include/linux/ppp_channel.h   |  38 +++++++++
+ 4 files changed, 317 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c
+index 56af90b..58b889e 100644
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -1,5 +1,21 @@
+ // SPDX-License-Identifier: GPL-2.0-or-later
+ /*
++ **************************************************************************
++ * Copyright (c) 2016, The Linux Foundation.  All rights reserved.
++ * Permission to use, copy, modify, and/or distribute this software for
++ * any purpose with or without fee is hereby granted, provided that the
++ * above copyright notice and this permission notice appear in all copies.
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
++ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ **************************************************************************
++ */
++
++/*
+  * Generic PPP layer for Linux.
+  *
+  * Copyright 1999-2002 Paul Mackerras.
+@@ -3341,6 +3357,178 @@ static void *unit_find(struct idr *p, int n)
+ 	return idr_find(p, n);
+ }
+ 
++/* Updates the PPP interface statistics. */
++void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
++		      unsigned long rx_bytes, unsigned long tx_packets,
++		      unsigned long tx_bytes)
++{
++	struct ppp *ppp;
++
++	if (!dev)
++		return;
++
++	if (dev->type != ARPHRD_PPP)
++		return;
++
++	ppp = netdev_priv(dev);
++
++	ppp_xmit_lock(ppp);
++	ppp->stats64.tx_packets += tx_packets;
++	ppp->stats64.tx_bytes += tx_bytes;
++	ppp_xmit_unlock(ppp);
++
++	ppp_recv_lock(ppp);
++	ppp->stats64.rx_packets += rx_packets;
++	ppp->stats64.rx_bytes += rx_bytes;
++	ppp_recv_unlock(ppp);
++}
++
++/* Returns >0 if the device is a multilink PPP netdevice, 0 if not or < 0 if
++ * the device is not PPP.
++ */
++int ppp_is_multilink(struct net_device *dev)
++{
++	struct ppp *ppp;
++	unsigned int flags;
++
++	if (!dev)
++		return -1;
++
++	if (dev->type != ARPHRD_PPP)
++		return -1;
++
++	ppp = netdev_priv(dev);
++	ppp_lock(ppp);
++	flags = ppp->flags;
++	ppp_unlock(ppp);
++
++	if (flags & SC_MULTILINK)
++		return 1;
++
++	return 0;
++}
++EXPORT_SYMBOL(ppp_is_multilink);
++
++/* ppp_channel_get_protocol()
++ *	Call this to obtain the underlying protocol of the PPP channel,
++ *	e.g. PX_PROTO_OE
++ *
++ * NOTE: Some channels do not use PX sockets so the protocol value may be very
++ * different for them.
++ * NOTE: -1 indicates failure.
++ * NOTE: Once you know the channel protocol you may then either cast 'chan' to
++ * its sub-class or use the channel protocol specific API's as provided by that
++ * channel sub type.
++ */
++int ppp_channel_get_protocol(struct ppp_channel *chan)
++{
++	if (!chan->ops->get_channel_protocol)
++		return -1;
++
++	return chan->ops->get_channel_protocol(chan);
++}
++EXPORT_SYMBOL(ppp_channel_get_protocol);
++
++/* ppp_channel_hold()
++ *	Call this to hold a channel.
++ *
++ * Returns true on success or false if the hold could not happen.
++ *
++ * NOTE: chan must be protected against destruction during this call -
++ * either by correct locking etc. or because you already have an implicit
++ * or explicit hold to the channel already and this is an additional hold.
++ */
++bool ppp_channel_hold(struct ppp_channel *chan)
++{
++	if (!chan->ops->hold)
++		return false;
++
++	chan->ops->hold(chan);
++	return true;
++}
++EXPORT_SYMBOL(ppp_channel_hold);
++
++/* ppp_channel_release()
++ *	Call this to release a hold you have upon a channel
++ */
++void ppp_channel_release(struct ppp_channel *chan)
++{
++	chan->ops->release(chan);
++}
++EXPORT_SYMBOL(ppp_channel_release);
++
++/* ppp_hold_channels()
++ *	Returns the PPP channels of the PPP device, storing each one into
++ *	channels[].
++ *
++ * channels[] has chan_sz elements.
++ * This function returns the number of channels stored, up to chan_sz.
++ * It will return < 0 if the device is not PPP.
++ *
++ * You MUST release the channels using ppp_release_channels().
++ */
++int ppp_hold_channels(struct net_device *dev, struct ppp_channel *channels[],
++		      unsigned int chan_sz)
++{
++	struct ppp *ppp;
++	int c;
++	struct channel *pch;
++
++	if (!dev)
++		return -1;
++
++	if (dev->type != ARPHRD_PPP)
++		return -1;
++
++	ppp = netdev_priv(dev);
++
++	c = 0;
++	ppp_lock(ppp);
++	list_for_each_entry(pch, &ppp->channels, clist) {
++		struct ppp_channel *chan;
++
++		if (!pch->chan) {
++			/* Channel is going / gone away */
++			continue;
++		}
++
++		if (c == chan_sz) {
++			/* No space to record channel */
++			ppp_unlock(ppp);
++			return c;
++		}
++
++		/* Hold the channel, if supported */
++		chan = pch->chan;
++		if (!chan->ops->hold)
++			continue;
++
++		chan->ops->hold(chan);
++
++		 /* Record the channel */
++		channels[c++] = chan;
++	}
++	ppp_unlock(ppp);
++	return c;
++}
++EXPORT_SYMBOL(ppp_hold_channels);
++
++/* ppp_release_channels()
++ *	Releases channels
++ */
++void ppp_release_channels(struct ppp_channel *channels[], unsigned int chan_sz)
++{
++	unsigned int c;
++
++	for (c = 0; c < chan_sz; ++c) {
++		struct ppp_channel *chan;
++
++		chan = channels[c];
++		chan->ops->release(chan);
++	}
++}
++EXPORT_SYMBOL(ppp_release_channels);
++
+ /* Module/initialization stuff */
+ 
+ module_init(ppp_init);
+@@ -3357,6 +3545,8 @@ EXPORT_SYMBOL(ppp_input_error);
+ EXPORT_SYMBOL(ppp_output_wakeup);
+ EXPORT_SYMBOL(ppp_register_compressor);
+ EXPORT_SYMBOL(ppp_unregister_compressor);
++EXPORT_SYMBOL(ppp_update_stats);
++
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS_CHARDEV(PPP_MAJOR, 0);
+ MODULE_ALIAS_RTNL_LINK("ppp");
+diff --git a/drivers/net/ppp/pppoe.c b/drivers/net/ppp/pppoe.c
+index df5d418..23590dd 100644
+--- a/drivers/net/ppp/pppoe.c
++++ b/drivers/net/ppp/pppoe.c
+@@ -62,6 +62,7 @@
+ #include <linux/inetdevice.h>
+ #include <linux/etherdevice.h>
+ #include <linux/skbuff.h>
++#include <linux/if_arp.h>
+ #include <linux/init.h>
+ #include <linux/if_ether.h>
+ #include <linux/if_pppox.h>
+@@ -92,7 +93,7 @@
+ static int __pppoe_xmit(struct sock *sk, struct sk_buff *skb);
+ 
+ static const struct proto_ops pppoe_ops;
+-static const struct ppp_channel_ops pppoe_chan_ops;
++static const struct pppoe_channel_ops pppoe_chan_ops;
+ 
+ /* per-net private data for this module */
+ static unsigned int pppoe_net_id __read_mostly;
+@@ -649,6 +650,7 @@ static int pppoe_connect(struct socket *sock, struct sockaddr *uservaddr,
+ 	if (stage_session(po->pppoe_pa.sid)) {
+ 		pppox_unbind_sock(sk);
+ 		pn = pppoe_pernet(sock_net(sk));
++
+ 		delete_item(pn, po->pppoe_pa.sid,
+ 			    po->pppoe_pa.remote, po->pppoe_ifindex);
+ 		if (po->pppoe_dev) {
+@@ -696,7 +698,7 @@ static int pppoe_connect(struct socket *sock, struct sockaddr *uservaddr,
+ 
+ 		po->chan.mtu = dev->mtu - sizeof(struct pppoe_hdr) - 2;
+ 		po->chan.private = sk;
+-		po->chan.ops = &pppoe_chan_ops;
++		po->chan.ops = (struct ppp_channel_ops *)&pppoe_chan_ops;
+ 
+ 		error = ppp_register_net_channel(dev_net(dev), &po->chan);
+ 		if (error) {
+@@ -1001,11 +1003,78 @@ static int pppoe_flow_offload_check(struct ppp_channel *chan,
+ }
+ #endif /* CONFIG_NF_FLOW_TABLE */
+ 
+-static const struct ppp_channel_ops pppoe_chan_ops = {
+-	.start_xmit = pppoe_xmit,
++/************************************************************************
++ *
++ * function called by generic PPP driver to hold channel
++ *
++ ***********************************************************************/
++static void pppoe_hold_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_hold(sk);
++}
++
++/************************************************************************
++ *
++ * function called by generic PPP driver to release channel
++ *
++ ***********************************************************************/
++static void pppoe_release_chan(struct ppp_channel *chan)
++{
++	struct sock *sk = (struct sock *)chan->private;
++
++	sock_put(sk);
++}
++
++/************************************************************************
++ *
++ * function called to get the channel protocol type
++ *
++ ***********************************************************************/
++static int pppoe_get_channel_protocol(struct ppp_channel *chan)
++{
++	return PX_PROTO_OE;
++}
++
++/************************************************************************
++ *
++ * function called to get the PPPoE channel addressing
++ * NOTE: This function returns a HOLD to the netdevice
++ *
++ ***********************************************************************/
++static void pppoe_get_addressing(struct ppp_channel *chan,
++				 struct pppoe_opt *addressing)
++{
++	struct sock *sk = (struct sock *)chan->private;
++	struct pppox_sock *po = pppox_sk(sk);
++
++	*addressing = po->proto.pppoe;
++	if (addressing->dev)
++		dev_hold(addressing->dev);
++}
++
++/* pppoe_channel_addressing_get()
++ *	Return PPPoE channel specific addressing information.
++ */
++void pppoe_channel_addressing_get(struct ppp_channel *chan,
++				  struct pppoe_opt *addressing)
++{
++	pppoe_get_addressing(chan, addressing);
++}
++EXPORT_SYMBOL(pppoe_channel_addressing_get);
++
++static const struct pppoe_channel_ops pppoe_chan_ops = {
++	/* PPPoE specific channel ops */
++	.get_addressing = pppoe_get_addressing,
++	/* General ppp channel ops */
++	.ops.start_xmit = pppoe_xmit,
+ #if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
+-	.flow_offload_check = pppoe_flow_offload_check,
++	.ops.flow_offload_check = pppoe_flow_offload_check,
+ #endif
++	.ops.get_channel_protocol = pppoe_get_channel_protocol,
++	.ops.hold = pppoe_hold_chan,
++	.ops.release = pppoe_release_chan,
+ };
+ 
+ static int pppoe_recvmsg(struct socket *sock, struct msghdr *m,
+diff --git a/include/linux/if_pppox.h b/include/linux/if_pppox.h
+index 69e813b..98131ea 100644
+--- a/include/linux/if_pppox.h
++++ b/include/linux/if_pppox.h
+@@ -1,13 +1,14 @@
+ /* SPDX-License-Identifier: GPL-2.0-or-later */
+ /***************************************************************************
+  * Linux PPP over X - Generic PPP transport layer sockets
+- * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516) 
++ * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516)
+  *
+  * This file supplies definitions required by the PPP over Ethernet driver
+  * (pppox.c).  All version information wrt this file is located in pppox.c
+  *
+  * License:
+  */
++
+ #ifndef __LINUX_IF_PPPOX_H
+ #define __LINUX_IF_PPPOX_H
+ 
+@@ -93,4 +94,17 @@ enum {
+     PPPOX_DEAD		= 16  /* dead, useless, please clean me up!*/
+ };
+ 
++/*
++ * PPPoE Channel specific operations
++ */
++struct pppoe_channel_ops {
++	/* Must be first - general to all PPP channels */
++	struct ppp_channel_ops ops;
++	void (*get_addressing)(struct ppp_channel *, struct pppoe_opt *);
++};
++
++/* Return PPPoE channel specific addressing information */
++extern void pppoe_channel_addressing_get(struct ppp_channel *chan,
++					 struct pppoe_opt *addressing);
++
+ #endif /* !(__LINUX_IF_PPPOX_H) */
+diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
+index 326a6fa..db352ff 100644
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -32,6 +32,14 @@ struct ppp_channel_ops {
+ #if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
+ 	int	(*flow_offload_check)(struct ppp_channel *, struct flow_offload_hw_path *);
+ #endif
++	/* Get channel protocol type, one of PX_PROTO_XYZ or specific to
++	 * the channel subtype
++	 */
++	int (*get_channel_protocol)(struct ppp_channel *);
++	/* Hold the channel from being destroyed */
++	void (*hold)(struct ppp_channel *);
++	/* Release hold on the channel */
++	void (*release)(struct ppp_channel *);
+ };
+ 
+ struct ppp_channel {
+@@ -46,6 +54,36 @@ struct ppp_channel {
+ };
+ 
+ #ifdef __KERNEL__
++/* Call this to obtain the underlying protocol of the PPP channel,
++ * e.g. PX_PROTO_OE
++ */
++extern int ppp_channel_get_protocol(struct ppp_channel *);
++
++/* Call this to hold a channel */
++extern bool ppp_channel_hold(struct ppp_channel *);
++
++/* Call this to release a hold you have upon a channel */
++extern void ppp_channel_release(struct ppp_channel *);
++
++/* Release hold on PPP channels */
++extern void ppp_release_channels(struct ppp_channel *channels[],
++				 unsigned int chan_sz);
++
++/* Hold PPP channels for the PPP device */
++extern int ppp_hold_channels(struct net_device *dev,
++			     struct ppp_channel *channels[],
++			     unsigned int chan_sz);
++
++/* Test if the ppp device is a multi-link ppp device */
++extern int ppp_is_multilink(struct net_device *dev);
++
++/* Update statistics of the PPP net_device by incrementing related
++ * statistics field value with corresponding parameter
++ */
++extern void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
++			     unsigned long rx_bytes, unsigned long tx_packets,
++			     unsigned long tx_bytes);
++
+ /* Called by the channel when it can send some more data. */
+ extern void ppp_output_wakeup(struct ppp_channel *);
+ 
+-- 
+cgit v1.1
diff --git a/target/linux/ipq806x/patches-5.4/999-03d-qca-nss-pppoe-offload-support.patch b/target/linux/ipq806x/patches-5.4/999-03d-qca-nss-pppoe-offload-support.patch
new file mode 100644
index 0000000000..c086e1d75e
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-03d-qca-nss-pppoe-offload-support.patch
@@ -0,0 +1,115 @@
+From 4df2e1c28e8e3baadd50bdafa40fb35ea99cc52f Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Fri, 26 Feb 2016 14:59:20 -0800
+Subject: net: ppp: rx/tx error and dropped pkt stats support
+
+ppp_update_stats functions accepts rx/tx errors and dropped
+pkt stats args.
+
+Change-Id: Iba2f6ea2114d8a4678254332fec0ef7bc35bed2c
+Signed-off-by: ratheesh kannoth <rkannoth@codeaurora.org>
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ drivers/net/ppp/ppp_generic.c |  8 +++++++-
+ include/linux/ppp_channel.h   |  4 +++-
+ net/l2tp/l2tp_core.c          | 24 ++++++++++++++++++++++++
+ net/l2tp/l2tp_core.h          |  2 ++
+ 4 files changed, 36 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c
+index 58b889e..9cf7fe3 100644
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -3360,7 +3360,9 @@ static void *unit_find(struct idr *p, int n)
+ /* Updates the PPP interface statistics. */
+ void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
+ 		      unsigned long rx_bytes, unsigned long tx_packets,
+-		      unsigned long tx_bytes)
++		      unsigned long tx_bytes, unsigned long rx_errors,
++		      unsigned long tx_errors, unsigned long rx_dropped,
++		      unsigned long tx_dropped)
+ {
+ 	struct ppp *ppp;
+ 
+@@ -3375,11 +3377,15 @@ void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
+ 	ppp_xmit_lock(ppp);
+ 	ppp->stats64.tx_packets += tx_packets;
+ 	ppp->stats64.tx_bytes += tx_bytes;
++	ppp->dev->stats.tx_errors += tx_errors;
++	ppp->dev->stats.tx_dropped += tx_dropped;
+ 	ppp_xmit_unlock(ppp);
+ 
+ 	ppp_recv_lock(ppp);
+ 	ppp->stats64.rx_packets += rx_packets;
+ 	ppp->stats64.rx_bytes += rx_bytes;
++	ppp->dev->stats.rx_errors += rx_errors;
++	ppp->dev->stats.rx_dropped += rx_dropped;
+ 	ppp_recv_unlock(ppp);
+ }
+ 
+diff --git a/include/linux/ppp_channel.h b/include/linux/ppp_channel.h
+index db352ff..82d51537 100644
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -82,7 +82,9 @@ extern int ppp_is_multilink(struct net_device *dev);
+  */
+ extern void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
+ 			     unsigned long rx_bytes, unsigned long tx_packets,
+-			     unsigned long tx_bytes);
++			     unsigned long tx_bytes, unsigned long rx_errors,
++			     unsigned long tx_errors, unsigned long rx_dropped,
++			     unsigned long tx_dropped);
+ 
+ /* Called by the channel when it can send some more data. */
+ extern void ppp_output_wakeup(struct ppp_channel *);
+diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c
+index 425b95e..b098099 100644
+--- a/net/l2tp/l2tp_core.c
++++ b/net/l2tp/l2tp_core.c
+@@ -355,6 +355,30 @@ err_tlock:
+ }
+ EXPORT_SYMBOL_GPL(l2tp_session_register);
+ 
++void l2tp_stats_update(struct l2tp_tunnel *tunnel,
++		       struct l2tp_session *session,
++		       struct l2tp_stats *stats)
++{
++	atomic_long_add(atomic_long_read(&stats->rx_packets),
++			&tunnel->stats.rx_packets);
++	atomic_long_add(atomic_long_read(&stats->rx_bytes),
++			&tunnel->stats.rx_bytes);
++	atomic_long_add(atomic_long_read(&stats->tx_packets),
++			&tunnel->stats.tx_packets);
++	atomic_long_add(atomic_long_read(&stats->tx_bytes),
++			&tunnel->stats.tx_bytes);
++
++	atomic_long_add(atomic_long_read(&stats->rx_packets),
++			&session->stats.rx_packets);
++	atomic_long_add(atomic_long_read(&stats->rx_bytes),
++			&session->stats.rx_bytes);
++	atomic_long_add(atomic_long_read(&stats->tx_packets),
++			&session->stats.tx_packets);
++	atomic_long_add(atomic_long_read(&stats->tx_bytes),
++			&session->stats.tx_bytes);
++}
++EXPORT_SYMBOL_GPL(l2tp_stats_update);
++
+ /*****************************************************************************
+  * Receive data handling
+  *****************************************************************************/
+diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h
+index 2db3d50..5cc42a4 100644
+--- a/net/l2tp/l2tp_core.h
++++ b/net/l2tp/l2tp_core.h
+@@ -200,6 +200,8 @@ struct l2tp_session *l2tp_session_get(const struct net *net, u32 session_id);
+ struct l2tp_session *l2tp_session_get_nth(struct l2tp_tunnel *tunnel, int nth);
+ struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,
+ 						const char *ifname);
++void l2tp_stats_update(struct l2tp_tunnel *tunnel, struct l2tp_session *session,
++		       struct l2tp_stats *stats);
+ 
+ int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id,
+ 		       u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg,
+-- 
+cgit v1.1
+
diff --git a/target/linux/ipq806x/patches-5.4/999-03e-qca-nss-pppoe-offload-support.patch b/target/linux/ipq806x/patches-5.4/999-03e-qca-nss-pppoe-offload-support.patch
new file mode 100644
index 0000000000..09b931119b
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-03e-qca-nss-pppoe-offload-support.patch
@@ -0,0 +1,38 @@
+From 0ebfa720350a5fde3efb45872f867ac30074a43c Mon Sep 17 00:00:00 2001
+From: Murat Sezgin <msezgin@codeaurora.org>
+Date: Tue, 13 Oct 2015 22:40:25 -0700
+Subject: ppp: Update the last_recv and last_xmit times.
+
+These need to be updated for accelerated connections, so that
+on demand mode will recognize the active traffic.
+
+Change-Id: I3c0ee4e8f4c3bc4c7ce221e6109bfd82046d11b4
+Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
+---
+ drivers/net/ppp/ppp_generic.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c
+index 9cf7fe3..b7bab8e 100644
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -3379,6 +3379,8 @@ void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
+ 	ppp->stats64.tx_bytes += tx_bytes;
+ 	ppp->dev->stats.tx_errors += tx_errors;
+ 	ppp->dev->stats.tx_dropped += tx_dropped;
++	if (tx_packets)
++		ppp->last_xmit = jiffies;
+ 	ppp_xmit_unlock(ppp);
+ 
+ 	ppp_recv_lock(ppp);
+@@ -3386,6 +3388,8 @@ void ppp_update_stats(struct net_device *dev, unsigned long rx_packets,
+ 	ppp->stats64.rx_bytes += rx_bytes;
+ 	ppp->dev->stats.rx_errors += rx_errors;
+ 	ppp->dev->stats.rx_dropped += rx_dropped;
++	if (rx_packets)
++		ppp->last_recv = jiffies;
+ 	ppp_recv_unlock(ppp);
+ }
+ 
+-- 
+cgit v1.1
diff --git a/target/linux/ipq806x/patches-5.4/999-04-qca-nss-cfi-support.patch b/target/linux/ipq806x/patches-5.4/999-04-qca-nss-cfi-support.patch
new file mode 100644
index 0000000000..649621c7e3
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-04-qca-nss-cfi-support.patch
@@ -0,0 +1,119 @@
+diff --git a/crypto/authenc.c b/crypto/authenc.c
+index 3f0ed9402..17ce66bba 100644
+--- a/crypto/authenc.c
++++ b/crypto/authenc.c
+@@ -449,6 +449,8 @@ static int crypto_authenc_create(struct crypto_template *tmpl,
+ 
+ 	inst->alg.base.cra_flags = (auth_base->cra_flags |
+ 				    enc->base.cra_flags) & CRYPTO_ALG_ASYNC;
++	inst->alg.base.cra_flags |= (auth_base->cra_flags |
++				    enc->base.cra_flags) & CRYPTO_ALG_NOSUPP_SG;
+ 	inst->alg.base.cra_priority = enc->base.cra_priority * 10 +
+ 				      auth_base->cra_priority;
+ 	inst->alg.base.cra_blocksize = enc->base.cra_blocksize;
+diff --git a/include/linux/crypto.h b/include/linux/crypto.h
+index 19ea3a371..1463e824c 100644
+--- a/include/linux/crypto.h
++++ b/include/linux/crypto.h
+@@ -104,6 +104,11 @@
+  */
+ #define CRYPTO_NOLOAD			0x00008000
+ 
++/*
++ * Set this flag if algorithm does not support SG list transforms
++ */
++#define CRYPTO_ALG_NOSUPP_SG		0x0000c000
++
+ /*
+  * Transform masks and values (for crt_flags).
+  */
+diff --git a/net/ipv4/esp4.c b/net/ipv4/esp4.c
+index 5c9677640..23b3a9e91 100644
+--- a/net/ipv4/esp4.c
++++ b/net/ipv4/esp4.c
+@@ -488,6 +488,7 @@ static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
+ 	struct ip_esp_hdr *esph;
+ 	struct crypto_aead *aead;
+ 	struct esp_info esp;
++	bool nosupp_sg;
+ 
+ 	esp.inplace = true;
+ 
+@@ -499,6 +500,11 @@ static int esp_output(struct xfrm_state *x, struct sk_buff *skb)
+ 	aead = x->data;
+ 	alen = crypto_aead_authsize(aead);
+ 
++	nosupp_sg = crypto_tfm_alg_type(&aead->base) & CRYPTO_ALG_NOSUPP_SG;
++	if (nosupp_sg && skb_linearize(skb)) {
++		return -ENOMEM;
++	}
++
+ 	esp.tfclen = 0;
+ 	if (x->tfcpad) {
+ 		struct xfrm_dst *dst = (struct xfrm_dst *)skb_dst(skb);
+@@ -708,6 +714,7 @@ static int esp_input(struct xfrm_state *x, struct sk_buff *skb)
+ 	u8 *iv;
+ 	struct scatterlist *sg;
+ 	int err = -EINVAL;
++	bool nosupp_sg;
+ 
+ 	if (!pskb_may_pull(skb, sizeof(struct ip_esp_hdr) + ivlen))
+ 		goto out;
+@@ -715,6 +722,12 @@ static int esp_input(struct xfrm_state *x, struct sk_buff *skb)
+ 	if (elen <= 0)
+ 		goto out;
+ 
++	nosupp_sg = crypto_tfm_alg_type(&aead->base) & CRYPTO_ALG_NOSUPP_SG;
++	if (nosupp_sg && skb_linearize(skb)) {
++		err = -ENOMEM;
++		goto out;
++	}
++
+ 	assoclen = sizeof(struct ip_esp_hdr);
+ 	seqhilen = 0;
+ 
+diff --git a/net/ipv6/esp6.c b/net/ipv6/esp6.c
+index a3b403ba8..019bea284 100644
+--- a/net/ipv6/esp6.c
++++ b/net/ipv6/esp6.c
+@@ -429,6 +429,7 @@ static int esp6_output(struct xfrm_state *x, struct sk_buff *skb)
+ 	struct ip_esp_hdr *esph;
+ 	struct crypto_aead *aead;
+ 	struct esp_info esp;
++	bool nosupp_sg;
+ 
+ 	esp.inplace = true;
+ 
+@@ -440,6 +441,11 @@ static int esp6_output(struct xfrm_state *x, struct sk_buff *skb)
+ 	aead = x->data;
+ 	alen = crypto_aead_authsize(aead);
+ 
++	nosupp_sg = crypto_tfm_alg_type(&aead->base) & CRYPTO_ALG_NOSUPP_SG;
++	if (nosupp_sg && skb_linearize(skb)) {
++		return -ENOMEM;
++	}
++
+ 	esp.tfclen = 0;
+ 	if (x->tfcpad) {
+ 		struct xfrm_dst *dst = (struct xfrm_dst *)skb_dst(skb);
+@@ -603,6 +609,7 @@ static int esp6_input(struct xfrm_state *x, struct sk_buff *skb)
+ 	__be32 *seqhi;
+ 	u8 *iv;
+ 	struct scatterlist *sg;
++	bool nosupp_sg;
+ 
+ 	if (!pskb_may_pull(skb, sizeof(struct ip_esp_hdr) + ivlen)) {
+ 		ret = -EINVAL;
+@@ -614,6 +621,12 @@ static int esp6_input(struct xfrm_state *x, struct sk_buff *skb)
+ 		goto out;
+ 	}
+ 
++	nosupp_sg = crypto_tfm_alg_type(&aead->base) & CRYPTO_ALG_NOSUPP_SG;
++	if (nosupp_sg && skb_linearize(skb)) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
+ 	assoclen = sizeof(struct ip_esp_hdr);
+ 	seqhilen = 0;
+ 
diff --git a/target/linux/ipq806x/patches-5.4/999-07a-qca-nss-drv-qdisc-support.patch b/target/linux/ipq806x/patches-5.4/999-07a-qca-nss-drv-qdisc-support.patch
new file mode 100644
index 0000000000..e7d451246d
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-07a-qca-nss-drv-qdisc-support.patch
@@ -0,0 +1,28 @@
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -816,6 +816,8 @@ struct sk_buff {
+ #ifdef CONFIG_NET_CLS_ACT
+ 	__u8			tc_skip_classify:1;
+ 	__u8			tc_at_ingress:1;
++
++	__u16			tc_verd_qca_nss; /* QCA NSS Qdisc Support */
+ #endif
+ #ifdef CONFIG_NET_REDIRECT
+ 	__u8			redirected:1;
+--- a/include/uapi/linux/pkt_cls.h
++++ b/include/uapi/linux/pkt_cls.h
+@@ -687,4 +687,14 @@ enum {
+ 	TCF_EM_OPND_LT
+ };
+ 
++/* QCA NSS Qdisc Support - Start */
++#define _TC_MAKE32(x)		((x))
++#define _TC_MAKEMASK1(n)	(_TC_MAKE32(1) << _TC_MAKE32(n))
++
++#define TC_NCLS                 _TC_MAKEMASK1(8)
++#define TC_NCLS_NSS		_TC_MAKEMASK1(12)
++#define SET_TC_NCLS_NSS(v)	( TC_NCLS_NSS | ((v) & ~TC_NCLS_NSS))
++#define CLR_TC_NCLS_NSS(v)	( (v) & ~TC_NCLS_NSS)
++/* QCA NSS Qdisc Support - End */
++
+ #endif
diff --git a/target/linux/ipq806x/patches-5.4/999-07b-qca-nss-clients-qdisc-support.patch b/target/linux/ipq806x/patches-5.4/999-07b-qca-nss-clients-qdisc-support.patch
new file mode 100644
index 0000000000..13a8588ad0
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-07b-qca-nss-clients-qdisc-support.patch
@@ -0,0 +1,319 @@
+--- a/include/net/sch_generic.h
++++ b/include/net/sch_generic.h
+@@ -79,6 +79,7 @@ struct Qdisc {
+ #define TCQ_F_INVISIBLE		0x80 /* invisible by default in dump */
+ #define TCQ_F_NOLOCK		0x100 /* qdisc does not require locking */
+ #define TCQ_F_OFFLOADED		0x200 /* qdisc is offloaded to HW */
++#define TCQ_F_NSS		0x1000 /* NSS qdisc flag. */
+ 	u32			limit;
+ 	const struct Qdisc_ops	*ops;
+ 	struct qdisc_size_table	__rcu *stab;
+@@ -1295,4 +1296,9 @@ static inline void skb_tc_reinsert(struc
+ 		qstats_overlimit_inc(res->qstats);
+ }
+ 
++/* QCA NSS Qdisc Support - Start */
++void qdisc_destroy(struct Qdisc *qdisc);
++void tcf_destroy_chain(struct tcf_proto __rcu **fl);
++/* QCA NSS Qdisc Support - End */
++
+ #endif
+--- a/include/uapi/linux/pkt_sched.h
++++ b/include/uapi/linux/pkt_sched.h
+@@ -1181,4 +1181,248 @@ enum {
+ 
+ #define TCA_TAPRIO_ATTR_MAX (__TCA_TAPRIO_ATTR_MAX - 1)
+ 
++/* QCA NSS Clients Support - Start */
++enum {
++	TCA_NSS_ACCEL_MODE_NSS_FW,
++	TCA_NSS_ACCEL_MODE_PPE,
++	TCA_NSS_ACCEL_MODE_MAX
++};
++
++/* NSSFIFO section */
++
++enum {
++	TCA_NSSFIFO_UNSPEC,
++	TCA_NSSFIFO_PARMS,
++	__TCA_NSSFIFO_MAX
++};
++
++#define TCA_NSSFIFO_MAX	(__TCA_NSSFIFO_MAX - 1)
++
++struct tc_nssfifo_qopt {
++	__u32	limit;		/* Queue length: bytes for bfifo, packets for pfifo */
++	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSWRED section */
++
++enum {
++	TCA_NSSWRED_UNSPEC,
++	TCA_NSSWRED_PARMS,
++	__TCA_NSSWRED_MAX
++};
++
++#define TCA_NSSWRED_MAX (__TCA_NSSWRED_MAX - 1)
++#define NSSWRED_CLASS_MAX 6
++struct tc_red_alg_parameter {
++	__u32	min;	/* qlen_avg < min: pkts are all enqueued */
++	__u32	max;	/* qlen_avg > max: pkts are all dropped */
++	__u32	probability;/* Drop probability at qlen_avg = max */
++	__u32	exp_weight_factor;/* exp_weight_factor for calculate qlen_avg */
++};
++
++struct tc_nsswred_traffic_class {
++	__u32 limit;			/* Queue length */
++	__u32 weight_mode_value;	/* Weight mode value */
++	struct tc_red_alg_parameter rap;/* Parameters for RED alg */
++};
++
++/*
++ * Weight modes for WRED
++ */
++enum tc_nsswred_weight_modes {
++	TC_NSSWRED_WEIGHT_MODE_DSCP = 0,/* Weight mode is DSCP */
++	TC_NSSWRED_WEIGHT_MODES,	/* Must be last */
++};
++
++struct tc_nsswred_qopt {
++	__u32	limit;			/* Queue length */
++	enum tc_nsswred_weight_modes weight_mode;
++					/* Weight mode */
++	__u32	traffic_classes;	/* How many traffic classes: DPs */
++	__u32	def_traffic_class;	/* Default traffic if no match: def_DP */
++	__u32	traffic_id;		/* The traffic id to be configured: DP */
++	__u32	weight_mode_value;	/* Weight mode value */
++	struct tc_red_alg_parameter rap;/* RED algorithm parameters */
++	struct tc_nsswred_traffic_class tntc[NSSWRED_CLASS_MAX];
++					/* Traffic settings for dumpping */
++	__u8	ecn;			/* Setting ECN bit or dropping */
++	__u8	set_default;		/* Sets qdisc to be the default for enqueue */
++	__u8	accel_mode;		/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSCODEL section */
++
++enum {
++	TCA_NSSCODEL_UNSPEC,
++	TCA_NSSCODEL_PARMS,
++	__TCA_NSSCODEL_MAX
++};
++
++#define TCA_NSSCODEL_MAX	(__TCA_NSSCODEL_MAX - 1)
++
++struct tc_nsscodel_qopt {
++	__u32	target;		/* Acceptable queueing delay */
++	__u32	limit;		/* Max number of packets that can be held in the queue */
++	__u32	interval;	/* Monitoring interval */
++	__u32	flows;		/* Number of flow buckets */
++	__u32	quantum;	/* Weight (in bytes) used for DRR of flow buckets */
++	__u8	ecn;		/* 0 - disable ECN, 1 - enable ECN */
++	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++struct tc_nsscodel_xstats {
++	__u32 peak_queue_delay;	/* Peak delay experienced by a dequeued packet */
++	__u32 peak_drop_delay;	/* Peak delay experienced by a dropped packet */
++};
++
++/* NSSFQ_CODEL section */
++
++struct tc_nssfq_codel_xstats {
++	__u32 new_flow_count;	/* Total number of new flows seen */
++	__u32 new_flows_len;	/* Current number of new flows */
++	__u32 old_flows_len;	/* Current number of old flows */
++	__u32 ecn_mark;		/* Number of packets marked with ECN */
++	__u32 drop_overlimit;	/* Number of packets dropped due to overlimit */
++	__u32 maxpacket;	/* The largest packet seen so far in the queue */
++};
++
++/* NSSTBL section */
++
++enum {
++	TCA_NSSTBL_UNSPEC,
++	TCA_NSSTBL_PARMS,
++	__TCA_NSSTBL_MAX
++};
++
++#define TCA_NSSTBL_MAX	(__TCA_NSSTBL_MAX - 1)
++
++struct tc_nsstbl_qopt {
++	__u32	burst;		/* Maximum burst size */
++	__u32	rate;		/* Limiting rate of TBF */
++	__u32	peakrate;	/* Maximum rate at which TBF is allowed to send */
++	__u32	mtu;		/* Max size of packet, or minumim burst size */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSPRIO section */
++
++#define TCA_NSSPRIO_MAX_BANDS 256
++
++enum {
++	TCA_NSSPRIO_UNSPEC,
++	TCA_NSSPRIO_PARMS,
++	__TCA_NSSPRIO_MAX
++};
++
++#define TCA_NSSPRIO_MAX	(__TCA_NSSPRIO_MAX - 1)
++
++struct tc_nssprio_qopt {
++	__u32	bands;		/* Number of bands */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSBF section */
++
++enum {
++	TCA_NSSBF_UNSPEC,
++	TCA_NSSBF_CLASS_PARMS,
++	TCA_NSSBF_QDISC_PARMS,
++	__TCA_NSSBF_MAX
++};
++
++#define TCA_NSSBF_MAX	(__TCA_NSSBF_MAX - 1)
++
++struct tc_nssbf_class_qopt {
++	__u32	burst;		/* Maximum burst size */
++	__u32	rate;		/* Allowed bandwidth for this class */
++	__u32	mtu;		/* MTU of the associated interface */
++	__u32	quantum;	/* Quantum allocation for DRR */
++};
++
++struct tc_nssbf_qopt {
++	__u16	defcls;		/* Default class value */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSWRR section */
++
++enum {
++	TCA_NSSWRR_UNSPEC,
++	TCA_NSSWRR_CLASS_PARMS,
++	TCA_NSSWRR_QDISC_PARMS,
++	__TCA_NSSWRR_MAX
++};
++
++#define TCA_NSSWRR_MAX	(__TCA_NSSWRR_MAX - 1)
++
++struct tc_nsswrr_class_qopt {
++	__u32	quantum;	/* Weight associated to this class */
++};
++
++struct tc_nsswrr_qopt {
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSWFQ section */
++
++enum {
++	TCA_NSSWFQ_UNSPEC,
++	TCA_NSSWFQ_CLASS_PARMS,
++	TCA_NSSWFQ_QDISC_PARMS,
++	__TCA_NSSWFQ_MAX
++};
++
++#define TCA_NSSWFQ_MAX	(__TCA_NSSWFQ_MAX - 1)
++
++struct tc_nsswfq_class_qopt {
++	__u32	quantum;	/* Weight associated to this class */
++};
++
++struct tc_nsswfq_qopt {
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSHTB section */
++
++enum {
++	TCA_NSSHTB_UNSPEC,
++	TCA_NSSHTB_CLASS_PARMS,
++	TCA_NSSHTB_QDISC_PARMS,
++	__TCA_NSSHTB_MAX
++};
++
++#define TCA_NSSHTB_MAX	(__TCA_NSSHTB_MAX - 1)
++
++struct tc_nsshtb_class_qopt {
++	__u32	burst;		/* Allowed burst size */
++	__u32	rate;		/* Allowed bandwidth for this class */
++	__u32	cburst;		/* Maximum burst size */
++	__u32	crate;		/* Maximum bandwidth for this class */
++	__u32	quantum;	/* Quantum allocation for DRR */
++	__u32	priority;	/* Priority value associated with this class */
++	__u32	overhead;	/* Overhead in bytes per packet */
++};
++
++struct tc_nsshtb_qopt {
++	__u32	r2q;		/* Rate to quantum ratio */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++
++/* NSSBLACKHOLE section */
++
++enum {
++	TCA_NSSBLACKHOLE_UNSPEC,
++	TCA_NSSBLACKHOLE_PARMS,
++	__TCA_NSSBLACKHOLE_MAX
++};
++
++#define TCA_NSSBLACKHOLE_MAX	(__TCA_NSSBLACKHOLE_MAX - 1)
++
++struct tc_nssblackhole_qopt {
++	__u8	set_default;	/* Sets qdisc to be the default qdisc for enqueue */
++	__u8	accel_mode;	/* Dictates which data plane offloads the qdisc */
++};
++/* QCA NSS Clients Support - End */
+ #endif
+--- a/net/sched/sch_api.c
++++ b/net/sched/sch_api.c
+@@ -2290,4 +2290,26 @@ static int __init pktsched_init(void)
+ 	return 0;
+ }
+ 
++/* QCA NSS Qdisc Support - Start */
++bool tcf_destroy(struct tcf_proto *tp, bool force)
++{
++	tp->ops->destroy(tp, force, NULL);
++	module_put(tp->ops->owner);
++	kfree_rcu(tp, rcu);
++
++	return true;
++}
++
++void tcf_destroy_chain(struct tcf_proto __rcu **fl)
++{
++	struct tcf_proto *tp;
++
++	while ((tp = rtnl_dereference(*fl)) != NULL) {
++		RCU_INIT_POINTER(*fl, tp->next);
++		tcf_destroy(tp, true);
++	}
++}
++EXPORT_SYMBOL(tcf_destroy_chain);
++/* QCA NSS Qdisc Support - End */
++
+ subsys_initcall(pktsched_init);
+--- a/net/sched/sch_generic.c
++++ b/net/sched/sch_generic.c
+@@ -741,7 +741,7 @@ static void qdisc_free_cb(struct rcu_hea
+ 	qdisc_free(q);
+ }
+
+-static void qdisc_destroy(struct Qdisc *qdisc)
++void qdisc_destroy(struct Qdisc *qdisc)
+ {
+ 	const struct Qdisc_ops  *ops = qdisc->ops;
+ 	struct sk_buff *skb, *tmp;
+@@ -772,6 +772,7 @@ static void qdisc_destroy(struct Qdisc *
+ 
+ 	call_rcu(&qdisc->rcu, qdisc_free_cb);
+ }
++EXPORT_SYMBOL(qdisc_destroy);
+ 
+ void qdisc_put(struct Qdisc *qdisc)
+ {
diff --git a/target/linux/ipq806x/patches-5.4/999-07c-qca-nss-clients-ppp-support.patch b/target/linux/ipq806x/patches-5.4/999-07c-qca-nss-clients-ppp-support.patch
new file mode 100644
index 0000000000..3fd3ce297b
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-07c-qca-nss-clients-ppp-support.patch
@@ -0,0 +1,132 @@
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -48,6 +48,7 @@
+ #include <net/slhc_vj.h>
+ #include <linux/atomic.h>
+ #include <linux/refcount.h>
++#include <linux/if_pppox.h>
+ 
+ #include <linux/nsproxy.h>
+ #include <net/net_namespace.h>
+@@ -3207,6 +3208,10 @@ ppp_connect_channel(struct channel *pch,
+ 	struct ppp_net *pn;
+ 	int ret = -ENXIO;
+ 	int hdrlen;
++	/* QCA NSS ECM Support - Start */
++	int ppp_proto;
++	int version;
++	/* QCA NSS ECM Support - End */
+ 
+ 	pn = ppp_pernet(pch->chan_net);
+ 
+@@ -3238,6 +3243,26 @@ ppp_connect_channel(struct channel *pch,
+ 	++ppp->n_channels;
+ 	pch->ppp = ppp;
+ 	refcount_inc(&ppp->file.refcnt);
++
++	/* QCA NSS ECM support - Start */
++	/* Set the netdev priv flag if the prototype
++	 * is L2TP or PPTP. Return success in all cases
++	 */
++	if (!pch->chan)
++		goto out2;
++
++	ppp_proto = ppp_channel_get_protocol(pch->chan);
++	if (ppp_proto == PX_PROTO_PPTP) {
++		ppp->dev->priv_flags_qca_ecm |= IFF_QCA_ECM_PPP_PPTP;
++	} else if (ppp_proto == PX_PROTO_OL2TP) {
++		version = ppp_channel_get_proto_version(pch->chan);
++		if (version == 2)
++			ppp->dev->priv_flags_qca_ecm |= IFF_QCA_ECM_PPP_L2TPV2;
++		else if (version == 3)
++			ppp->dev->priv_flags_qca_ecm |= IFF_QCA_ECM_PPP_L2TPV3;
++	}
++	/* QCA NSS ECM support - End */
++ out2:
+ 	ppp_unlock(ppp);
+ 	ret = 0;
+ 
+@@ -3341,6 +3366,56 @@
+ }
+ EXPORT_SYMBOL(ppp_release_channels);
+ 
++/* Return the PPP net device index */
++int ppp_dev_index(struct ppp_channel *chan)
++{
++	struct channel *pch = chan->ppp;
++	int ifindex = 0;
++
++	if (pch) {
++		read_lock_bh(&pch->upl);
++		if (pch->ppp && pch->ppp->dev)
++			ifindex = pch->ppp->dev->ifindex;
++		read_unlock_bh(&pch->upl);
++	}
++	return ifindex;
++}
++EXPORT_SYMBOL(ppp_dev_index);
++
++/* ppp_channel_get_proto_version()
++ *	Call this to get channel protocol version
++ */
++int ppp_channel_get_proto_version(struct ppp_channel *chan)
++{
++	if (!chan->ops->get_channel_protocol_ver)
++		return -1;
++
++	return chan->ops->get_channel_protocol_ver(chan);
++}
++EXPORT_SYMBOL(ppp_channel_get_proto_version);
++
++/* Check if ppp xmit lock is on hold */
++bool ppp_is_xmit_locked(struct net_device *dev)
++{
++	struct ppp *ppp;
++
++	if (!dev)
++		return false;
++
++	if (dev->type != ARPHRD_PPP)
++		return false;
++
++	ppp = netdev_priv(dev);
++	if (!ppp)
++		return false;
++
++	if (spin_is_locked(&(ppp)->wlock))
++		return true;
++
++	return false;
++}
++EXPORT_SYMBOL(ppp_is_xmit_locked);
++
+ /* Module/initialization stuff */
+ 
+ module_init(ppp_init);
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -32,6 +32,8 @@ struct ppp_channel_ops {
+ 	 * the channel subtype
+ 	 */
+ 	int (*get_channel_protocol)(struct ppp_channel *);
++	/* Get channel protocol version */
++	int (*get_channel_protocol_ver)(struct ppp_channel *);
+	/* Hold the channel from being destroyed */
+	void (*hold)(struct ppp_channel *);
+	/* Release hold on the channel */
+@@ -84,6 +96,15 @@
+ /* Test if ppp xmit lock is locked */
+ extern bool ppp_is_xmit_locked(struct net_device *dev);
+ 
++/* Test if ppp xmit lock is locked */
++extern bool ppp_is_xmit_locked(struct net_device *dev);
++
++/* Call this get protocol version */
++extern int ppp_channel_get_proto_version(struct ppp_channel *);
++
++/* Get the device index  associated with a channel, or 0, if none */
++extern int ppp_dev_index(struct ppp_channel *);
++
+ /* Hold PPP channels for the PPP device */
+ extern int __ppp_hold_channels(struct net_device *dev,
+ 			       struct ppp_channel *channels[],
diff --git a/target/linux/ipq806x/patches-5.4/999-07d-qca-nss-clients-ppp-support.patch b/target/linux/ipq806x/patches-5.4/999-07d-qca-nss-clients-ppp-support.patch
new file mode 100644
index 0000000000..5c743902fa
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-07d-qca-nss-clients-ppp-support.patch
@@ -0,0 +1,99 @@
+--- a/include/linux/ppp_channel.h
++++ b/include/linux/ppp_channel.h
+@@ -146,5 +146,17 @@ extern void ppp_update_stats(struct net_
+ extern int ppp_dev_index(struct ppp_channel *);
+ /* QCA NSS ECM Support - End */
+ 
++/* QCA NSS Clients Support - Start */
++/* PPP channel connection event types */
++#define PPP_CHANNEL_DISCONNECT	0
++#define PPP_CHANNEL_CONNECT	1
++
++/* Register the PPP channel connect notifier */
++extern void ppp_channel_connection_register_notify(struct notifier_block *nb);
++
++/* Unregister the PPP channel connect notifier */
++extern void ppp_channel_connection_unregister_notify(struct notifier_block *nb);
++/* QCA NSS Clients Support - End */
++
+ #endif /* __KERNEL__ */
+ #endif
+--- a/drivers/net/ppp/ppp_generic.c
++++ b/drivers/net/ppp/ppp_generic.c
+@@ -256,6 +256,26 @@ struct ppp_net {
+ #define seq_before(a, b)	((s32)((a) - (b)) < 0)
+ #define seq_after(a, b)		((s32)((a) - (b)) > 0)
+ 
++/* QCA NSS Client Support - Start */
++/*
++ * Registration/Unregistration methods
++ * for PPP channel connect and disconnect event notifications.
++ */
++RAW_NOTIFIER_HEAD(ppp_channel_connection_notifier_list);
++
++void ppp_channel_connection_register_notify(struct notifier_block *nb)
++{
++	raw_notifier_chain_register(&ppp_channel_connection_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(ppp_channel_connection_register_notify);
++
++void ppp_channel_connection_unregister_notify(struct notifier_block *nb)
++{
++	raw_notifier_chain_unregister(&ppp_channel_connection_notifier_list, nb);
++}
++EXPORT_SYMBOL_GPL(ppp_channel_connection_unregister_notify);
++/* QCA NSS Client Support - End */
++
+ /* Prototypes. */
+ static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,
+ 			struct file *file, unsigned int cmd, unsigned long arg);
+@@ -3212,6 +3232,7 @@ ppp_connect_channel(struct channel *pch,
+ 	int ppp_proto;
+ 	int version;
+ 	/* QCA NSS ECM Support - End */
++	int notify = 0; /* QCA NSS Client Support */
+ 
+ 	pn = ppp_pernet(pch->chan_net);
+ 
+@@ -3262,6 +3283,8 @@ ppp_connect_channel(struct channel *pch,
+ 			ppp->dev->priv_flags_qca_ecm |= IFF_QCA_ECM_PPP_L2TPV3;
+ 	}
+ 	/* QCA NSS ECM support - End */
++
++	notify = 1; /* QCA NSS Clients Support */
+  out2:
+ 	ppp_unlock(ppp);
+ 	ret = 0;
+@@ -3270,6 +3293,16 @@ ppp_connect_channel(struct channel *pch,
+ 	write_unlock_bh(&pch->upl);
+  out:
+ 	mutex_unlock(&pn->all_ppp_mutex);
++
++	/* QCA NSS Clients Support - Start */
++	if (notify && ppp && ppp->dev) {
++		dev_hold(ppp->dev);
++		raw_notifier_call_chain(&ppp_channel_connection_notifier_list,
++					   PPP_CHANNEL_CONNECT, ppp->dev);
++		dev_put(ppp->dev);
++	}
++	/* QCA NSS Clients Support - End */
++
+ 	return ret;
+ }
+ 
+@@ -3287,6 +3320,15 @@ ppp_disconnect_channel(struct channel *p
+ 	pch->ppp = NULL;
+ 	write_unlock_bh(&pch->upl);
+ 	if (ppp) {
++		/* QCA NSS Clients Support - Start */
++		if (ppp->dev) {
++			dev_hold(ppp->dev);
++			raw_notifier_call_chain(&ppp_channel_connection_notifier_list,
++					   PPP_CHANNEL_DISCONNECT, ppp->dev);
++			dev_put(ppp->dev);
++		}
++		/* QCA NSS Clients Support - Start */
++
+ 		/* remove it from the ppp unit's list */
+ 		ppp_lock(ppp);
+ 		list_del(&pch->clist);
\ No newline at end of file
diff --git a/target/linux/ipq806x/patches-5.4/999-07e-qca-nss-clients-iptunnel-support.patch b/target/linux/ipq806x/patches-5.4/999-07e-qca-nss-clients-iptunnel-support.patch
new file mode 100644
index 0000000000..7422ba4193
--- /dev/null
+++ b/target/linux/ipq806x/patches-5.4/999-07e-qca-nss-clients-iptunnel-support.patch
@@ -0,0 +1,77 @@
+--- a/include/net/ip6_tunnel.h
++++ b/include/net/ip6_tunnel.h
+@@ -36,6 +36,7 @@ struct __ip6_tnl_parm {
+ 	__u8 proto;		/* tunnel protocol */
+ 	__u8 encap_limit;	/* encapsulation limit for tunnel */
+ 	__u8 hop_limit;		/* hop limit for tunnel */
++	__u8 draft03;		/* FMR using draft03 of map-e - QCA NSS Clients Support */
+ 	bool collect_md;
+ 	__be32 flowinfo;	/* traffic class and flowlabel for tunnel */
+ 	__u32 flags;		/* tunnel flags */
+--- a/include/net/ip_tunnels.h
++++ b/include/net/ip_tunnels.h
+@@ -525,4 +525,9 @@ static inline void ip_tunnel_info_opts_s
+ 
+ #endif /* CONFIG_INET */
+ 
++/* QCA NSS Clients Support - Start */
++void ipip6_update_offload_stats(struct net_device *dev, void *ptr);
++void ip6_update_offload_stats(struct net_device *dev, void *ptr);
++/* QCA NSS Clients Support - End */
++
+ #endif /* __NET_IP_TUNNELS_H */
+--- a/net/ipv6/ip6_tunnel.c
++++ b/net/ipv6/ip6_tunnel.c
+@@ -2392,6 +2392,26 @@ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
++/* QCA NSS Client Support - Start */
++/*
++ * Update offload stats
++ */
++void ip6_update_offload_stats(struct net_device *dev, void *ptr)
++{
++	struct pcpu_sw_netstats *tstats = per_cpu_ptr(dev->tstats, 0);
++	const struct pcpu_sw_netstats *offload_stats =
++					(struct pcpu_sw_netstats *)ptr;
++
++	u64_stats_update_begin(&tstats->syncp);
++	tstats->tx_packets += offload_stats->tx_packets;
++	tstats->tx_bytes   += offload_stats->tx_bytes;
++	tstats->rx_packets += offload_stats->rx_packets;
++	tstats->rx_bytes   += offload_stats->rx_bytes;
++	u64_stats_update_end(&tstats->syncp);
++}
++EXPORT_SYMBOL(ip6_update_offload_stats);
++/* QCA NSS Client Support - End */
++
+ struct net *ip6_tnl_get_link_net(const struct net_device *dev)
+ {
+ 	struct ip6_tnl *tunnel = netdev_priv(dev);
+--- a/net/ipv6/sit.c
++++ b/net/ipv6/sit.c
+@@ -1741,6 +1741,23 @@ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
++/* QCA NSS Clients Support - Start */
++void ipip6_update_offload_stats(struct net_device *dev, void *ptr)
++{
++	struct pcpu_sw_netstats *tstats = per_cpu_ptr(dev->tstats, 0);
++	const struct pcpu_sw_netstats *offload_stats =
++					(struct pcpu_sw_netstats *)ptr;
++
++	u64_stats_update_begin(&tstats->syncp);
++	tstats->tx_packets += offload_stats->tx_packets;
++	tstats->tx_bytes   += offload_stats->tx_bytes;
++	tstats->rx_packets += offload_stats->rx_packets;
++	tstats->rx_bytes   += offload_stats->rx_bytes;
++	u64_stats_update_end(&tstats->syncp);
++}
++EXPORT_SYMBOL(ipip6_update_offload_stats);
++/* QCA NSS Clients Support - End */
++
+ static const struct nla_policy ipip6_policy[IFLA_IPTUN_MAX + 1] = {
+ 	[IFLA_IPTUN_LINK]		= { .type = NLA_U32 },
+ 	[IFLA_IPTUN_LOCAL]		= { .type = NLA_U32 },
